var background = (function() {
  "use strict";
  const browser$1 = globalThis.browser?.runtime?.id ? globalThis.browser : globalThis.chrome;
  const browser = browser$1;
  function defineBackground(arg) {
    if (arg == null || typeof arg === "function") return { main: arg };
    return arg;
  }
  var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
  var adapter = {};
  var chrome$1 = {};
  var dist$1 = {};
  var config194bdd43 = {};
  var TRPCErrorCa37bf1a = {};
  var getCauseFromUnknownD535264a = {};
  var hasRequiredGetCauseFromUnknownD535264a;
  function requireGetCauseFromUnknownD535264a() {
    if (hasRequiredGetCauseFromUnknownD535264a) return getCauseFromUnknownD535264a;
    hasRequiredGetCauseFromUnknownD535264a = 1;
    function isObject2(value) {
      return !!value && !Array.isArray(value) && typeof value === "object";
    }
    class UnknownCauseError2 extends Error {
    }
    function getCauseFromUnknown2(cause) {
      if (cause instanceof Error) {
        return cause;
      }
      const type = typeof cause;
      if (type === "undefined" || type === "function" || cause === null) {
        return void 0;
      }
      if (type !== "object") {
        return new Error(String(cause));
      }
      if (isObject2(cause)) {
        const err = new UnknownCauseError2();
        for (const key in cause) {
          err[key] = cause[key];
        }
        return err;
      }
      return void 0;
    }
    getCauseFromUnknownD535264a.getCauseFromUnknown = getCauseFromUnknown2;
    return getCauseFromUnknownD535264a;
  }
  var hasRequiredTRPCErrorCa37bf1a;
  function requireTRPCErrorCa37bf1a() {
    if (hasRequiredTRPCErrorCa37bf1a) return TRPCErrorCa37bf1a;
    hasRequiredTRPCErrorCa37bf1a = 1;
    var getCauseFromUnknown2 = requireGetCauseFromUnknownD535264a();
    function getTRPCErrorFromUnknown2(cause) {
      if (cause instanceof TRPCError2) {
        return cause;
      }
      if (cause instanceof Error && cause.name === "TRPCError") {
        return cause;
      }
      const trpcError = new TRPCError2({
        code: "INTERNAL_SERVER_ERROR",
        cause
      });
      if (cause instanceof Error && cause.stack) {
        trpcError.stack = cause.stack;
      }
      return trpcError;
    }
    class TRPCError2 extends Error {
      constructor(opts) {
        const cause = getCauseFromUnknown2.getCauseFromUnknown(opts.cause);
        const message = opts.message ?? cause?.message ?? opts.code;
        super(message, {
          cause
        });
        this.code = opts.code;
        this.name = "TRPCError";
        if (!this.cause) {
          this.cause = cause;
        }
      }
    }
    TRPCErrorCa37bf1a.TRPCError = TRPCError2;
    TRPCErrorCa37bf1a.getTRPCErrorFromUnknown = getTRPCErrorFromUnknown2;
    return TRPCErrorCa37bf1a;
  }
  var index784ff647 = {};
  var codes87f6824b = {};
  var hasRequiredCodes87f6824b;
  function requireCodes87f6824b() {
    if (hasRequiredCodes87f6824b) return codes87f6824b;
    hasRequiredCodes87f6824b = 1;
    function invert2(obj) {
      const newObj = /* @__PURE__ */ Object.create(null);
      for (const key in obj) {
        const v = obj[key];
        newObj[v] = key;
      }
      return newObj;
    }
    const TRPC_ERROR_CODES_BY_KEY2 = {
      /**
      * Invalid JSON was received by the server.
      * An error occurred on the server while parsing the JSON text.
      */
      PARSE_ERROR: -32700,
      /**
      * The JSON sent is not a valid Request object.
      */
      BAD_REQUEST: -32600,
      // Internal JSON-RPC error
      INTERNAL_SERVER_ERROR: -32603,
      NOT_IMPLEMENTED: -32603,
      // Implementation specific errors
      UNAUTHORIZED: -32001,
      FORBIDDEN: -32003,
      NOT_FOUND: -32004,
      METHOD_NOT_SUPPORTED: -32005,
      TIMEOUT: -32008,
      CONFLICT: -32009,
      PRECONDITION_FAILED: -32012,
      PAYLOAD_TOO_LARGE: -32013,
      UNPROCESSABLE_CONTENT: -32022,
      TOO_MANY_REQUESTS: -32029,
      CLIENT_CLOSED_REQUEST: -32099
    };
    const TRPC_ERROR_CODES_BY_NUMBER = invert2(TRPC_ERROR_CODES_BY_KEY2);
    codes87f6824b.TRPC_ERROR_CODES_BY_KEY = TRPC_ERROR_CODES_BY_KEY2;
    codes87f6824b.TRPC_ERROR_CODES_BY_NUMBER = TRPC_ERROR_CODES_BY_NUMBER;
    codes87f6824b.invert = invert2;
    return codes87f6824b;
  }
  var hasRequiredIndex784ff647;
  function requireIndex784ff647() {
    if (hasRequiredIndex784ff647) return index784ff647;
    hasRequiredIndex784ff647 = 1;
    var codes = requireCodes87f6824b();
    const TRPC_ERROR_CODES_BY_NUMBER = codes.invert(codes.TRPC_ERROR_CODES_BY_KEY);
    const JSONRPC2_TO_HTTP_CODE2 = {
      PARSE_ERROR: 400,
      BAD_REQUEST: 400,
      UNAUTHORIZED: 401,
      NOT_FOUND: 404,
      FORBIDDEN: 403,
      METHOD_NOT_SUPPORTED: 405,
      TIMEOUT: 408,
      CONFLICT: 409,
      PRECONDITION_FAILED: 412,
      PAYLOAD_TOO_LARGE: 413,
      UNPROCESSABLE_CONTENT: 422,
      TOO_MANY_REQUESTS: 429,
      CLIENT_CLOSED_REQUEST: 499,
      INTERNAL_SERVER_ERROR: 500,
      NOT_IMPLEMENTED: 501
    };
    function getStatusCodeFromKey2(code) {
      return JSONRPC2_TO_HTTP_CODE2[code] ?? 500;
    }
    function getHTTPStatusCode(json) {
      const arr = Array.isArray(json) ? json : [
        json
      ];
      const httpStatuses = new Set(arr.map((res) => {
        if ("error" in res) {
          const data = res.error.data;
          if (typeof data.httpStatus === "number") {
            return data.httpStatus;
          }
          const code = TRPC_ERROR_CODES_BY_NUMBER[res.error.code];
          return getStatusCodeFromKey2(code);
        }
        return 200;
      }));
      if (httpStatuses.size !== 1) {
        return 207;
      }
      const httpStatus = httpStatuses.values().next().value;
      return httpStatus;
    }
    function getHTTPStatusCodeFromError2(error) {
      return getStatusCodeFromKey2(error.code);
    }
    const noop2 = () => {
    };
    function createInnerProxy2(callback, path) {
      const proxy = new Proxy(noop2, {
        get(_obj, key) {
          if (typeof key !== "string" || key === "then") {
            return void 0;
          }
          return createInnerProxy2(callback, [
            ...path,
            key
          ]);
        },
        apply(_1, _2, args) {
          const isApply = path[path.length - 1] === "apply";
          return callback({
            args: isApply ? args.length >= 2 ? args[1] : [] : args,
            path: isApply ? path.slice(0, -1) : path
          });
        }
      });
      return proxy;
    }
    const createRecursiveProxy2 = (callback) => createInnerProxy2(callback, []);
    const createFlatProxy2 = (callback) => {
      return new Proxy(noop2, {
        get(_obj, name) {
          if (typeof name !== "string" || name === "then") {
            return void 0;
          }
          return callback(name);
        }
      });
    };
    index784ff647.TRPC_ERROR_CODES_BY_NUMBER = TRPC_ERROR_CODES_BY_NUMBER;
    index784ff647.createFlatProxy = createFlatProxy2;
    index784ff647.createRecursiveProxy = createRecursiveProxy2;
    index784ff647.getHTTPStatusCode = getHTTPStatusCode;
    index784ff647.getHTTPStatusCodeFromError = getHTTPStatusCodeFromError2;
    return index784ff647;
  }
  var hasRequiredConfig194bdd43;
  function requireConfig194bdd43() {
    if (hasRequiredConfig194bdd43) return config194bdd43;
    hasRequiredConfig194bdd43 = 1;
    var TRPCError2 = requireTRPCErrorCa37bf1a();
    var index = requireIndex784ff647();
    var codes = requireCodes87f6824b();
    function getDataTransformer2(transformer) {
      if ("input" in transformer) {
        return transformer;
      }
      return {
        input: transformer,
        output: transformer
      };
    }
    const defaultTransformer2 = {
      _default: true,
      input: {
        serialize: (obj) => obj,
        deserialize: (obj) => obj
      },
      output: {
        serialize: (obj) => obj,
        deserialize: (obj) => obj
      }
    };
    const defaultFormatter2 = ({ shape }) => {
      return shape;
    };
    function omitPrototype2(obj) {
      return Object.assign(/* @__PURE__ */ Object.create(null), obj);
    }
    const procedureTypes2 = [
      "query",
      "mutation",
      "subscription"
    ];
    function isRouter2(procedureOrRouter) {
      return "router" in procedureOrRouter._def;
    }
    const emptyRouter2 = {
      _ctx: null,
      _errorShape: null,
      _meta: null,
      queries: {},
      mutations: {},
      subscriptions: {},
      errorFormatter: defaultFormatter2,
      transformer: defaultTransformer2
    };
    const reservedWords2 = [
      /**
      * Then is a reserved word because otherwise we can't return a promise that returns a Proxy
      * since JS will think that `.then` is something that exists
      */
      "then"
    ];
    function createRouterFactory2(config) {
      return function createRouterInner(procedures) {
        const reservedWordsUsed = new Set(Object.keys(procedures).filter((v) => reservedWords2.includes(v)));
        if (reservedWordsUsed.size > 0) {
          throw new Error("Reserved words used in `router({})` call: " + Array.from(reservedWordsUsed).join(", "));
        }
        const routerProcedures = omitPrototype2({});
        function recursiveGetPaths(procedures2, path = "") {
          for (const [key, procedureOrRouter] of Object.entries(procedures2 ?? {})) {
            const newPath = `${path}${key}`;
            if (isRouter2(procedureOrRouter)) {
              recursiveGetPaths(procedureOrRouter._def.procedures, `${newPath}.`);
              continue;
            }
            if (routerProcedures[newPath]) {
              throw new Error(`Duplicate key: ${newPath}`);
            }
            routerProcedures[newPath] = procedureOrRouter;
          }
        }
        recursiveGetPaths(procedures);
        const _def = {
          _config: config,
          router: true,
          procedures: routerProcedures,
          ...emptyRouter2,
          record: procedures,
          queries: Object.entries(routerProcedures).filter((pair) => pair[1]._def.query).reduce((acc, [key, val]) => ({
            ...acc,
            [key]: val
          }), {}),
          mutations: Object.entries(routerProcedures).filter((pair) => pair[1]._def.mutation).reduce((acc, [key, val]) => ({
            ...acc,
            [key]: val
          }), {}),
          subscriptions: Object.entries(routerProcedures).filter((pair) => pair[1]._def.subscription).reduce((acc, [key, val]) => ({
            ...acc,
            [key]: val
          }), {})
        };
        const router2 = {
          ...procedures,
          _def,
          createCaller(ctx) {
            return createCallerFactory2()(router2)(ctx);
          },
          getErrorShape(opts) {
            const { path, error } = opts;
            const { code } = opts.error;
            const shape = {
              message: error.message,
              code: codes.TRPC_ERROR_CODES_BY_KEY[code],
              data: {
                code,
                httpStatus: index.getHTTPStatusCodeFromError(error)
              }
            };
            if (config.isDev && typeof opts.error.stack === "string") {
              shape.data.stack = opts.error.stack;
            }
            if (typeof path === "string") {
              shape.data.path = path;
            }
            return this._def._config.errorFormatter({
              ...opts,
              shape
            });
          }
        };
        return router2;
      };
    }
    function callProcedure2(opts) {
      const { type, path } = opts;
      if (!(path in opts.procedures) || !opts.procedures[path]?._def[type]) {
        throw new TRPCError2.TRPCError({
          code: "NOT_FOUND",
          message: `No "${type}"-procedure on path "${path}"`
        });
      }
      const procedure = opts.procedures[path];
      return procedure(opts);
    }
    function createCallerFactory2() {
      return function createCallerInner(router2) {
        const def = router2._def;
        return function createCaller(ctx) {
          const proxy = index.createRecursiveProxy(({ path, args }) => {
            if (path.length === 1 && procedureTypes2.includes(path[0])) {
              return callProcedure2({
                procedures: def.procedures,
                path: args[0],
                rawInput: args[1],
                ctx,
                type: path[0]
              });
            }
            const fullPath = path.join(".");
            const procedure = def.procedures[fullPath];
            let type = "query";
            if (procedure._def.mutation) {
              type = "mutation";
            } else if (procedure._def.subscription) {
              type = "subscription";
            }
            return procedure({
              path: fullPath,
              rawInput: args[0],
              ctx,
              type
            });
          });
          return proxy;
        };
      };
    }
    const isServerDefault2 = typeof window === "undefined" || "Deno" in window || globalThis.process?.env?.NODE_ENV === "test" || !!globalThis.process?.env?.JEST_WORKER_ID || !!globalThis.process?.env?.VITEST_WORKER_ID;
    config194bdd43.callProcedure = callProcedure2;
    config194bdd43.createCallerFactory = createCallerFactory2;
    config194bdd43.createRouterFactory = createRouterFactory2;
    config194bdd43.defaultFormatter = defaultFormatter2;
    config194bdd43.defaultTransformer = defaultTransformer2;
    config194bdd43.getDataTransformer = getDataTransformer2;
    config194bdd43.isServerDefault = isServerDefault2;
    config194bdd43.procedureTypes = procedureTypes2;
    return config194bdd43;
  }
  var hasRequiredDist$1;
  function requireDist$1() {
    if (hasRequiredDist$1) return dist$1;
    hasRequiredDist$1 = 1;
    Object.defineProperty(dist$1, "__esModule", { value: true });
    var config = requireConfig194bdd43();
    var TRPCError2 = requireTRPCErrorCa37bf1a();
    var index = requireIndex784ff647();
    var codes = requireCodes87f6824b();
    requireGetCauseFromUnknownD535264a();
    const middlewareMarker$1 = "middlewareMarker";
    function getParseFn$1(procedureParser) {
      const parser = procedureParser;
      if (typeof parser === "function") {
        return parser;
      }
      if (typeof parser.parseAsync === "function") {
        return parser.parseAsync.bind(parser);
      }
      if (typeof parser.parse === "function") {
        return parser.parse.bind(parser);
      }
      if (typeof parser.validateSync === "function") {
        return parser.validateSync.bind(parser);
      }
      if (typeof parser.create === "function") {
        return parser.create.bind(parser);
      }
      throw new Error("Could not find a validator fn");
    }
    class Procedure {
      _def() {
        return {
          middlewares: this.middlewares,
          resolver: this.resolver,
          inputParser: this.inputParser,
          outputParser: this.outputParser,
          meta: this.meta
        };
      }
      async parseInput(rawInput) {
        try {
          return await this.parseInputFn(rawInput);
        } catch (cause) {
          throw new TRPCError2.TRPCError({
            code: "BAD_REQUEST",
            cause
          });
        }
      }
      async parseOutput(rawOutput) {
        try {
          return await this.parseOutputFn(rawOutput);
        } catch (cause) {
          throw new TRPCError2.TRPCError({
            code: "INTERNAL_SERVER_ERROR",
            cause,
            message: "Output validation failed"
          });
        }
      }
      /**
      * Trigger middlewares in order, parse raw input, call resolver & parse raw output
      * @internal
      */
      async call(opts) {
        const middlewaresWithResolver = this.middlewares.concat([
          async ({ ctx }) => {
            const input = await this.parseInput(opts.rawInput);
            const rawOutput = await this.resolver({
              ...opts,
              ctx,
              input
            });
            const data = await this.parseOutput(rawOutput);
            return {
              marker: middlewareMarker$1,
              ok: true,
              data,
              ctx
            };
          }
        ]);
        const callRecursive = async (callOpts = {
          index: 0,
          ctx: opts.ctx
        }) => {
          try {
            const result22 = await middlewaresWithResolver[callOpts.index]({
              ctx: callOpts.ctx,
              type: opts.type,
              path: opts.path,
              rawInput: opts.rawInput,
              meta: this.meta,
              next: async (nextOpts) => {
                return await callRecursive({
                  index: callOpts.index + 1,
                  ctx: nextOpts ? nextOpts.ctx : callOpts.ctx
                });
              }
            });
            return result22;
          } catch (cause) {
            return {
              ctx: callOpts.ctx,
              ok: false,
              error: TRPCError2.getTRPCErrorFromUnknown(cause),
              marker: middlewareMarker$1
            };
          }
        };
        const result2 = await callRecursive();
        if (!result2) {
          throw new TRPCError2.TRPCError({
            code: "INTERNAL_SERVER_ERROR",
            message: "No result from middlewares - did you forget to `return next()`?"
          });
        }
        if (!result2.ok) {
          throw result2.error;
        }
        return result2.data;
      }
      /**
      * Create new procedure with passed middlewares
      * @param middlewares
      */
      inheritMiddlewares(middlewares) {
        const Constructor = this.constructor;
        const instance = new Constructor({
          middlewares: [
            ...middlewares,
            ...this.middlewares
          ],
          resolver: this.resolver,
          inputParser: this.inputParser,
          outputParser: this.outputParser,
          meta: this.meta
        });
        return instance;
      }
      constructor(opts) {
        this.middlewares = opts.middlewares;
        this.resolver = opts.resolver;
        this.inputParser = opts.inputParser;
        this.parseInputFn = getParseFn$1(this.inputParser);
        this.outputParser = opts.outputParser;
        this.parseOutputFn = getParseFn$1(this.outputParser);
        this.meta = opts.meta;
      }
    }
    function createProcedure(opts) {
      const inputParser = "input" in opts ? opts.input : (input) => {
        if (input != null) {
          throw new TRPCError2.TRPCError({
            code: "BAD_REQUEST",
            message: "No input expected"
          });
        }
        return void 0;
      };
      const outputParser = "output" in opts && opts.output ? opts.output : (output) => output;
      return new Procedure({
        inputParser,
        resolver: opts.resolve,
        middlewares: [],
        outputParser,
        meta: opts.meta
      });
    }
    function getParseFn2(procedureParser) {
      const parser = procedureParser;
      if (typeof parser === "function") {
        return parser;
      }
      if (typeof parser.parseAsync === "function") {
        return parser.parseAsync.bind(parser);
      }
      if (typeof parser.parse === "function") {
        return parser.parse.bind(parser);
      }
      if (typeof parser.validateSync === "function") {
        return parser.validateSync.bind(parser);
      }
      if (typeof parser.create === "function") {
        return parser.create.bind(parser);
      }
      if (typeof parser.assert === "function") {
        return (value) => {
          parser.assert(value);
          return value;
        };
      }
      throw new Error("Could not find a validator fn");
    }
    function getParseFnOrPassThrough(procedureParser) {
      if (!procedureParser) {
        return (v) => v;
      }
      return getParseFn2(procedureParser);
    }
    function mergeWithoutOverrides2(obj1, ...objs) {
      const newObj = Object.assign(/* @__PURE__ */ Object.create(null), obj1);
      for (const overrides of objs) {
        for (const key in overrides) {
          if (key in newObj && newObj[key] !== overrides[key]) {
            throw new Error(`Duplicate key ${key}`);
          }
          newObj[key] = overrides[key];
        }
      }
      return newObj;
    }
    function createMiddlewareFactory2() {
      function createMiddlewareInner(middlewares) {
        return {
          _middlewares: middlewares,
          unstable_pipe(middlewareBuilderOrFn) {
            const pipedMiddleware = "_middlewares" in middlewareBuilderOrFn ? middlewareBuilderOrFn._middlewares : [
              middlewareBuilderOrFn
            ];
            return createMiddlewareInner([
              ...middlewares,
              ...pipedMiddleware
            ]);
          }
        };
      }
      function createMiddleware(fn) {
        return createMiddlewareInner([
          fn
        ]);
      }
      return createMiddleware;
    }
    const experimental_standaloneMiddleware = () => ({
      create: createMiddlewareFactory2()
    });
    function isPlainObject2(obj) {
      return obj && typeof obj === "object" && !Array.isArray(obj);
    }
    function createInputMiddleware2(parse) {
      const inputMiddleware = async ({ next, rawInput, input }) => {
        let parsedInput;
        try {
          parsedInput = await parse(rawInput);
        } catch (cause) {
          throw new TRPCError2.TRPCError({
            code: "BAD_REQUEST",
            cause
          });
        }
        const combinedInput = isPlainObject2(input) && isPlainObject2(parsedInput) ? {
          ...input,
          ...parsedInput
        } : parsedInput;
        return next({
          input: combinedInput
        });
      };
      inputMiddleware._type = "input";
      return inputMiddleware;
    }
    function createOutputMiddleware2(parse) {
      const outputMiddleware = async ({ next }) => {
        const result2 = await next();
        if (!result2.ok) {
          return result2;
        }
        try {
          const data = await parse(result2.data);
          return {
            ...result2,
            data
          };
        } catch (cause) {
          throw new TRPCError2.TRPCError({
            message: "Output validation failed",
            code: "INTERNAL_SERVER_ERROR",
            cause
          });
        }
      };
      outputMiddleware._type = "output";
      return outputMiddleware;
    }
    const middlewareMarker2 = "middlewareMarker";
    function createNewBuilder2(def1, def2) {
      const { middlewares = [], inputs, meta, ...rest } = def2;
      return createBuilder2({
        ...mergeWithoutOverrides2(def1, rest),
        inputs: [
          ...def1.inputs,
          ...inputs ?? []
        ],
        middlewares: [
          ...def1.middlewares,
          ...middlewares
        ],
        meta: def1.meta && meta ? {
          ...def1.meta,
          ...meta
        } : meta ?? def1.meta
      });
    }
    function createBuilder2(initDef = {}) {
      const _def = {
        inputs: [],
        middlewares: [],
        ...initDef
      };
      return {
        _def,
        input(input) {
          const parser = getParseFn2(input);
          return createNewBuilder2(_def, {
            inputs: [
              input
            ],
            middlewares: [
              createInputMiddleware2(parser)
            ]
          });
        },
        output(output) {
          const parseOutput = getParseFn2(output);
          return createNewBuilder2(_def, {
            output,
            middlewares: [
              createOutputMiddleware2(parseOutput)
            ]
          });
        },
        meta(meta) {
          return createNewBuilder2(_def, {
            meta
          });
        },
        /**
        * @deprecated
        * This functionality is deprecated and will be removed in the next major version.
        */
        unstable_concat(builder) {
          return createNewBuilder2(_def, builder._def);
        },
        use(middlewareBuilderOrFn) {
          const middlewares = "_middlewares" in middlewareBuilderOrFn ? middlewareBuilderOrFn._middlewares : [
            middlewareBuilderOrFn
          ];
          return createNewBuilder2(_def, {
            middlewares
          });
        },
        query(resolver) {
          return createResolver2({
            ..._def,
            query: true
          }, resolver);
        },
        mutation(resolver) {
          return createResolver2({
            ..._def,
            mutation: true
          }, resolver);
        },
        subscription(resolver) {
          return createResolver2({
            ..._def,
            subscription: true
          }, resolver);
        }
      };
    }
    function createResolver2(_def, resolver) {
      const finalBuilder = createNewBuilder2(_def, {
        resolver,
        middlewares: [
          async function resolveMiddleware(opts) {
            const data = await resolver(opts);
            return {
              marker: middlewareMarker2,
              ok: true,
              data,
              ctx: opts.ctx
            };
          }
        ]
      });
      return createProcedureCaller2(finalBuilder._def);
    }
    const codeblock2 = `
This is a client-only function.
If you want to call this function on the server, see https://trpc.io/docs/server/server-side-calls
`.trim();
    function createProcedureCaller2(_def) {
      const procedure = async function resolve(opts) {
        if (!opts || !("rawInput" in opts)) {
          throw new Error(codeblock2);
        }
        const callRecursive = async (callOpts = {
          index: 0,
          ctx: opts.ctx
        }) => {
          try {
            const middleware = _def.middlewares[callOpts.index];
            const result22 = await middleware({
              ctx: callOpts.ctx,
              type: opts.type,
              path: opts.path,
              rawInput: callOpts.rawInput ?? opts.rawInput,
              meta: _def.meta,
              input: callOpts.input,
              next(_nextOpts) {
                const nextOpts = _nextOpts;
                return callRecursive({
                  index: callOpts.index + 1,
                  ctx: nextOpts && "ctx" in nextOpts ? {
                    ...callOpts.ctx,
                    ...nextOpts.ctx
                  } : callOpts.ctx,
                  input: nextOpts && "input" in nextOpts ? nextOpts.input : callOpts.input,
                  rawInput: nextOpts && "rawInput" in nextOpts ? nextOpts.rawInput : callOpts.rawInput
                });
              }
            });
            return result22;
          } catch (cause) {
            return {
              ok: false,
              error: TRPCError2.getTRPCErrorFromUnknown(cause),
              marker: middlewareMarker2
            };
          }
        };
        const result2 = await callRecursive();
        if (!result2) {
          throw new TRPCError2.TRPCError({
            code: "INTERNAL_SERVER_ERROR",
            message: "No result from middlewares - did you forget to `return next()`?"
          });
        }
        if (!result2.ok) {
          throw result2.error;
        }
        return result2.data;
      };
      procedure._def = _def;
      procedure.meta = _def.meta;
      return procedure;
    }
    function migrateProcedure(oldProc, type) {
      const def = oldProc._def();
      const inputParser = getParseFnOrPassThrough(def.inputParser);
      const outputParser = getParseFnOrPassThrough(def.outputParser);
      const inputMiddleware = createInputMiddleware2(inputParser);
      const builder = createBuilder2({
        inputs: [
          def.inputParser
        ],
        middlewares: [
          ...def.middlewares,
          inputMiddleware,
          createOutputMiddleware2(outputParser)
        ],
        meta: def.meta,
        output: def.outputParser,
        mutation: type === "mutation",
        query: type === "query",
        subscription: type === "subscription"
      });
      const proc = builder[type]((opts) => def.resolver(opts));
      return proc;
    }
    function migrateRouter(oldRouter) {
      const errorFormatter = oldRouter._def.errorFormatter;
      const transformer = oldRouter._def.transformer;
      const queries = {};
      const mutations = {};
      const subscriptions = {};
      for (const [name, procedure] of Object.entries(oldRouter._def.queries)) {
        queries[name] = migrateProcedure(procedure, "query");
      }
      for (const [name1, procedure1] of Object.entries(oldRouter._def.mutations)) {
        mutations[name1] = migrateProcedure(procedure1, "mutation");
      }
      for (const [name2, procedure2] of Object.entries(oldRouter._def.subscriptions)) {
        subscriptions[name2] = migrateProcedure(procedure2, "subscription");
      }
      const procedures = mergeWithoutOverrides2(queries, mutations, subscriptions);
      const newRouter = config.createRouterFactory({
        transformer,
        errorFormatter,
        isDev: true
      })(procedures);
      return newRouter;
    }
    function getDataTransformer2(transformer) {
      if ("input" in transformer) {
        return transformer;
      }
      return {
        input: transformer,
        output: transformer
      };
    }
    const PROCEDURE_DEFINITION_MAP = {
      query: "queries",
      mutation: "mutations",
      subscription: "subscriptions"
    };
    function safeObject(...args) {
      return Object.assign(/* @__PURE__ */ Object.create(null), ...args);
    }
    class Router {
      static prefixProcedures(procedures, prefix) {
        const eps = safeObject();
        for (const [key, procedure] of Object.entries(procedures)) {
          eps[prefix + key] = procedure;
        }
        return eps;
      }
      query(path, procedure) {
        const router22 = new Router({
          queries: safeObject({
            [path]: createProcedure(procedure)
          })
        });
        return this.merge(router22);
      }
      mutation(path, procedure) {
        const router22 = new Router({
          mutations: safeObject({
            [path]: createProcedure(procedure)
          })
        });
        return this.merge(router22);
      }
      subscription(path, procedure) {
        const router22 = new Router({
          subscriptions: safeObject({
            [path]: createProcedure(procedure)
          })
        });
        return this.merge(router22);
      }
      merge(prefixOrRouter, maybeRouter) {
        let prefix = "";
        let childRouter;
        if (typeof prefixOrRouter === "string" && maybeRouter instanceof Router) {
          prefix = prefixOrRouter;
          childRouter = maybeRouter;
        } else if (prefixOrRouter instanceof Router) {
          childRouter = prefixOrRouter;
        } else {
          throw new Error("Invalid args");
        }
        const duplicateQueries = Object.keys(childRouter._def.queries).filter((key) => !!this._def.queries[prefix + key]);
        const duplicateMutations = Object.keys(childRouter._def.mutations).filter((key) => !!this._def.mutations[prefix + key]);
        const duplicateSubscriptions = Object.keys(childRouter._def.subscriptions).filter((key) => !!this._def.subscriptions[prefix + key]);
        const duplicates = [
          ...duplicateQueries,
          ...duplicateMutations,
          ...duplicateSubscriptions
        ];
        if (duplicates.length) {
          throw new Error(`Duplicate endpoint(s): ${duplicates.join(", ")}`);
        }
        const mergeProcedures = (defs) => {
          const newDefs = safeObject();
          for (const [key, procedure] of Object.entries(defs)) {
            const newProcedure = procedure.inheritMiddlewares(this._def.middlewares);
            newDefs[key] = newProcedure;
          }
          return Router.prefixProcedures(newDefs, prefix);
        };
        return new Router({
          ...this._def,
          queries: safeObject(this._def.queries, mergeProcedures(childRouter._def.queries)),
          mutations: safeObject(this._def.mutations, mergeProcedures(childRouter._def.mutations)),
          subscriptions: safeObject(this._def.subscriptions, mergeProcedures(childRouter._def.subscriptions))
        });
      }
      /**
      * Invoke procedure. Only for internal use within library.
      */
      async call(opts) {
        const { type, path } = opts;
        const defTarget = PROCEDURE_DEFINITION_MAP[type];
        const defs = this._def[defTarget];
        const procedure = defs[path];
        if (!procedure) {
          throw new TRPCError2.TRPCError({
            code: "NOT_FOUND",
            message: `No "${type}"-procedure on path "${path}"`
          });
        }
        return procedure.call(opts);
      }
      createCaller(ctx) {
        return {
          query: (path, ...args) => {
            return this.call({
              type: "query",
              ctx,
              path,
              rawInput: args[0]
            });
          },
          mutation: (path, ...args) => {
            return this.call({
              type: "mutation",
              ctx,
              path,
              rawInput: args[0]
            });
          },
          subscription: (path, ...args) => {
            return this.call({
              type: "subscription",
              ctx,
              path,
              rawInput: args[0]
            });
          }
        };
      }
      /**
      * Function to be called before any procedure is invoked
      * @link https://trpc.io/docs/middlewares
      */
      middleware(middleware) {
        return new Router({
          ...this._def,
          middlewares: [
            ...this._def.middlewares,
            middleware
          ]
        });
      }
      /**
      * Format errors
      * @link https://trpc.io/docs/error-formatting
      */
      formatError(errorFormatter) {
        if (this._def.errorFormatter !== config.defaultFormatter) {
          throw new Error("You seem to have double `formatError()`-calls in your router tree");
        }
        return new Router({
          ...this._def,
          errorFormatter
        });
      }
      getErrorShape(opts) {
        const { path, error } = opts;
        const { code } = opts.error;
        const shape = {
          message: error.message,
          code: codes.TRPC_ERROR_CODES_BY_KEY[code],
          data: {
            code,
            httpStatus: index.getHTTPStatusCodeFromError(error)
          }
        };
        if (globalThis.process?.env?.NODE_ENV !== "production" && typeof opts.error.stack === "string") {
          shape.data.stack = opts.error.stack;
        }
        if (typeof path === "string") {
          shape.data.path = path;
        }
        return this._def.errorFormatter({
          ...opts,
          shape
        });
      }
      /**
      * Add data transformer to serialize/deserialize input args + output
      * @link https://trpc.io/docs/data-transformers
      */
      transformer(_transformer) {
        const transformer = getDataTransformer2(_transformer);
        if (this._def.transformer !== config.defaultTransformer) {
          throw new Error("You seem to have double `transformer()`-calls in your router tree");
        }
        return new Router({
          ...this._def,
          transformer
        });
      }
      /**
      * Flattens the generics of TQueries/TMutations/TSubscriptions.
      * ⚠️ Experimental - might disappear. ⚠️
      *
      * @alpha
      */
      flat() {
        return this;
      }
      /**
      * Interop mode for v9.x -> v10.x
      */
      interop() {
        return migrateRouter(this);
      }
      constructor(def) {
        this._def = {
          queries: def?.queries ?? safeObject(),
          mutations: def?.mutations ?? safeObject(),
          subscriptions: def?.subscriptions ?? safeObject(),
          middlewares: def?.middlewares ?? [],
          errorFormatter: def?.errorFormatter ?? config.defaultFormatter,
          transformer: def?.transformer ?? config.defaultTransformer
        };
      }
    }
    function router2() {
      return new Router();
    }
    function mergeRouters2(...routerList) {
      const record = mergeWithoutOverrides2({}, ...routerList.map((r) => r._def.record));
      const errorFormatter = routerList.reduce((currentErrorFormatter, nextRouter) => {
        if (nextRouter._def._config.errorFormatter && nextRouter._def._config.errorFormatter !== config.defaultFormatter) {
          if (currentErrorFormatter !== config.defaultFormatter && currentErrorFormatter !== nextRouter._def._config.errorFormatter) {
            throw new Error("You seem to have several error formatters");
          }
          return nextRouter._def._config.errorFormatter;
        }
        return currentErrorFormatter;
      }, config.defaultFormatter);
      const transformer = routerList.reduce((prev, current) => {
        if (current._def._config.transformer && current._def._config.transformer !== config.defaultTransformer) {
          if (prev !== config.defaultTransformer && prev !== current._def._config.transformer) {
            throw new Error("You seem to have several transformers");
          }
          return current._def._config.transformer;
        }
        return prev;
      }, config.defaultTransformer);
      const router22 = config.createRouterFactory({
        errorFormatter,
        transformer,
        isDev: routerList.some((r) => r._def._config.isDev),
        allowOutsideOfServer: routerList.some((r) => r._def._config.allowOutsideOfServer),
        isServer: routerList.some((r) => r._def._config.isServer),
        $types: routerList[0]?._def._config.$types
      })(record);
      return router22;
    }
    class TRPCBuilder2 {
      context() {
        return new TRPCBuilder2();
      }
      meta() {
        return new TRPCBuilder2();
      }
      create(options) {
        return createTRPCInner2()(options);
      }
    }
    const initTRPC2 = new TRPCBuilder2();
    function createTRPCInner2() {
      return function initTRPCInner(runtime) {
        const errorFormatter = runtime?.errorFormatter ?? config.defaultFormatter;
        const transformer = config.getDataTransformer(runtime?.transformer ?? config.defaultTransformer);
        const config$1 = {
          transformer,
          isDev: runtime?.isDev ?? globalThis.process?.env?.NODE_ENV !== "production",
          allowOutsideOfServer: runtime?.allowOutsideOfServer ?? false,
          errorFormatter,
          isServer: runtime?.isServer ?? config.isServerDefault,
          /**
          * @internal
          */
          $types: index.createFlatProxy((key) => {
            throw new Error(`Tried to access "$types.${key}" which is not available at runtime`);
          })
        };
        {
          const isServer = runtime?.isServer ?? config.isServerDefault;
          if (!isServer && runtime?.allowOutsideOfServer !== true) {
            throw new Error(`You're trying to use @trpc/server in a non-server environment. This is not supported by default.`);
          }
        }
        return {
          /**
          * These are just types, they can't be used
          * @internal
          */
          _config: config$1,
          /**
          * Builder object for creating procedures
          * @see https://trpc.io/docs/server/procedures
          */
          procedure: createBuilder2({
            meta: runtime?.defaultMeta
          }),
          /**
          * Create reusable middlewares
          * @see https://trpc.io/docs/server/middlewares
          */
          middleware: createMiddlewareFactory2(),
          /**
          * Create a router
          * @see https://trpc.io/docs/server/routers
          */
          router: config.createRouterFactory(config$1),
          /**
          * Merge Routers
          * @see https://trpc.io/docs/server/merging-routers
          */
          mergeRouters: mergeRouters2,
          /**
          * Create a server-side caller for a router
          * @see https://trpc.io/docs/server/server-side-calls
          */
          createCallerFactory: config.createCallerFactory()
        };
      };
    }
    dist$1.callProcedure = config.callProcedure;
    dist$1.createCallerFactory = config.createCallerFactory;
    dist$1.defaultTransformer = config.defaultTransformer;
    dist$1.getDataTransformer = config.getDataTransformer;
    dist$1.procedureTypes = config.procedureTypes;
    dist$1.TRPCError = TRPCError2.TRPCError;
    dist$1.getTRPCErrorFromUnknown = TRPCError2.getTRPCErrorFromUnknown;
    dist$1.createInputMiddleware = createInputMiddleware2;
    dist$1.createOutputMiddleware = createOutputMiddleware2;
    dist$1.experimental_standaloneMiddleware = experimental_standaloneMiddleware;
    dist$1.initTRPC = initTRPC2;
    dist$1.router = router2;
    return dist$1;
  }
  var observable$1 = {};
  var observable464116ac = {};
  var hasRequiredObservable464116ac;
  function requireObservable464116ac() {
    if (hasRequiredObservable464116ac) return observable464116ac;
    hasRequiredObservable464116ac = 1;
    function identity2(x) {
      return x;
    }
    function pipeFromArray2(fns) {
      if (fns.length === 0) {
        return identity2;
      }
      if (fns.length === 1) {
        return fns[0];
      }
      return function piped(input) {
        return fns.reduce((prev, fn) => fn(prev), input);
      };
    }
    function isObservable(x) {
      return typeof x === "object" && x !== null && "subscribe" in x;
    }
    function observable2(subscribe) {
      const self2 = {
        subscribe(observer) {
          let teardownRef = null;
          let isDone = false;
          let unsubscribed = false;
          let teardownImmediately = false;
          function unsubscribe() {
            if (teardownRef === null) {
              teardownImmediately = true;
              return;
            }
            if (unsubscribed) {
              return;
            }
            unsubscribed = true;
            if (typeof teardownRef === "function") {
              teardownRef();
            } else if (teardownRef) {
              teardownRef.unsubscribe();
            }
          }
          teardownRef = subscribe({
            next(value) {
              if (isDone) {
                return;
              }
              observer.next?.(value);
            },
            error(err) {
              if (isDone) {
                return;
              }
              isDone = true;
              observer.error?.(err);
              unsubscribe();
            },
            complete() {
              if (isDone) {
                return;
              }
              isDone = true;
              observer.complete?.();
              unsubscribe();
            }
          });
          if (teardownImmediately) {
            unsubscribe();
          }
          return {
            unsubscribe
          };
        },
        pipe(...operations) {
          return pipeFromArray2(operations)(self2);
        }
      };
      return self2;
    }
    observable464116ac.isObservable = isObservable;
    observable464116ac.observable = observable2;
    return observable464116ac;
  }
  var hasRequiredObservable;
  function requireObservable() {
    if (hasRequiredObservable) return observable$1;
    hasRequiredObservable = 1;
    Object.defineProperty(observable$1, "__esModule", { value: true });
    var observable2 = requireObservable464116ac();
    function share2(_opts) {
      return (originalObserver) => {
        let refCount = 0;
        let subscription = null;
        const observers = [];
        function startIfNeeded() {
          if (subscription) {
            return;
          }
          subscription = originalObserver.subscribe({
            next(value) {
              for (const observer of observers) {
                observer.next?.(value);
              }
            },
            error(error) {
              for (const observer of observers) {
                observer.error?.(error);
              }
            },
            complete() {
              for (const observer of observers) {
                observer.complete?.();
              }
            }
          });
        }
        function resetIfNeeded() {
          if (refCount === 0 && subscription) {
            const _sub = subscription;
            subscription = null;
            _sub.unsubscribe();
          }
        }
        return {
          subscribe(observer) {
            refCount++;
            observers.push(observer);
            startIfNeeded();
            return {
              unsubscribe() {
                refCount--;
                resetIfNeeded();
                const index = observers.findIndex((v) => v === observer);
                if (index > -1) {
                  observers.splice(index, 1);
                }
              }
            };
          }
        };
      };
    }
    function map(project) {
      return (originalObserver) => {
        return {
          subscribe(observer) {
            let index = 0;
            const subscription = originalObserver.subscribe({
              next(value) {
                observer.next?.(project(value, index++));
              },
              error(error) {
                observer.error?.(error);
              },
              complete() {
                observer.complete?.();
              }
            });
            return subscription;
          }
        };
      };
    }
    function tap(observer) {
      return (originalObserver) => {
        return {
          subscribe(observer2) {
            return originalObserver.subscribe({
              next(v) {
                observer.next?.(v);
                observer2.next?.(v);
              },
              error(v) {
                observer.error?.(v);
                observer2.error?.(v);
              },
              complete() {
                observer.complete?.();
                observer2.complete?.();
              }
            });
          }
        };
      };
    }
    class ObservableAbortError2 extends Error {
      constructor(message) {
        super(message);
        this.name = "ObservableAbortError";
        Object.setPrototypeOf(this, ObservableAbortError2.prototype);
      }
    }
    function observableToPromise2(observable3) {
      let abort;
      const promise = new Promise((resolve, reject) => {
        let isDone = false;
        function onDone() {
          if (isDone) {
            return;
          }
          isDone = true;
          reject(new ObservableAbortError2("This operation was aborted."));
          obs$.unsubscribe();
        }
        const obs$ = observable3.subscribe({
          next(data) {
            isDone = true;
            resolve(data);
            onDone();
          },
          error(data) {
            isDone = true;
            reject(data);
            onDone();
          },
          complete() {
            isDone = true;
            onDone();
          }
        });
        abort = onDone;
      });
      return {
        promise,
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        abort
      };
    }
    observable$1.isObservable = observable2.isObservable;
    observable$1.observable = observable2.observable;
    observable$1.map = map;
    observable$1.observableToPromise = observableToPromise2;
    observable$1.share = share2;
    observable$1.tap = tap;
    return observable$1;
  }
  var shared = {};
  var transformTRPCResponseE65f34e9 = {};
  var hasRequiredTransformTRPCResponseE65f34e9;
  function requireTransformTRPCResponseE65f34e9() {
    if (hasRequiredTransformTRPCResponseE65f34e9) return transformTRPCResponseE65f34e9;
    hasRequiredTransformTRPCResponseE65f34e9 = 1;
    var index = requireIndex784ff647();
    var codes = requireCodes87f6824b();
    function getErrorShape(opts) {
      const { path, error, config } = opts;
      const { code } = opts.error;
      const shape = {
        message: error.message,
        code: codes.TRPC_ERROR_CODES_BY_KEY[code],
        data: {
          code,
          httpStatus: index.getHTTPStatusCodeFromError(error)
        }
      };
      if (config.isDev && typeof opts.error.stack === "string") {
        shape.data.stack = opts.error.stack;
      }
      if (typeof path === "string") {
        shape.data.path = path;
      }
      return config.errorFormatter({
        ...opts,
        shape
      });
    }
    function transformTRPCResponseItem(config, item) {
      if ("error" in item) {
        return {
          ...item,
          error: config.transformer.output.serialize(item.error)
        };
      }
      if ("data" in item.result) {
        return {
          ...item,
          result: {
            ...item.result,
            data: config.transformer.output.serialize(item.result.data)
          }
        };
      }
      return item;
    }
    function transformTRPCResponse(config, itemOrItems) {
      return Array.isArray(itemOrItems) ? itemOrItems.map((item) => transformTRPCResponseItem(config, item)) : transformTRPCResponseItem(config, itemOrItems);
    }
    transformTRPCResponseE65f34e9.getErrorShape = getErrorShape;
    transformTRPCResponseE65f34e9.transformTRPCResponse = transformTRPCResponse;
    return transformTRPCResponseE65f34e9;
  }
  var hasRequiredShared;
  function requireShared() {
    if (hasRequiredShared) return shared;
    hasRequiredShared = 1;
    Object.defineProperty(shared, "__esModule", { value: true });
    var index = requireIndex784ff647();
    var transformTRPCResponse = requireTransformTRPCResponseE65f34e9();
    var getCauseFromUnknown2 = requireGetCauseFromUnknownD535264a();
    requireCodes87f6824b();
    shared.createFlatProxy = index.createFlatProxy;
    shared.createRecursiveProxy = index.createRecursiveProxy;
    shared.getErrorShape = transformTRPCResponse.getErrorShape;
    shared.transformTRPCResponse = transformTRPCResponse.transformTRPCResponse;
    shared.getCauseFromUnknown = getCauseFromUnknown2.getCauseFromUnknown;
    return shared;
  }
  var trpcMessage = {};
  var hasRequiredTrpcMessage;
  function requireTrpcMessage() {
    if (hasRequiredTrpcMessage) return trpcMessage;
    hasRequiredTrpcMessage = 1;
    Object.defineProperty(trpcMessage, "__esModule", { value: true });
    trpcMessage.isTRPCRequestWithId = trpcMessage.isTRPCRequest = trpcMessage.isTRPCResponse = trpcMessage.isTRPCMessage = void 0;
    function isPlainObject2(obj) {
      return typeof obj === "object" && obj !== null && !Array.isArray(obj);
    }
    function isNullOrUndefined(x) {
      return x === null || x === void 0;
    }
    function isTRPCMessage(message) {
      return Boolean(isPlainObject2(message) && "trpc" in message && isPlainObject2(message.trpc));
    }
    trpcMessage.isTRPCMessage = isTRPCMessage;
    function isTRPCMessageWithId(message) {
      return isTRPCMessage(message) && "id" in message.trpc && !isNullOrUndefined(message.trpc.id);
    }
    function isTRPCResponse(message) {
      return isTRPCMessageWithId(message) && ("error" in message.trpc || "result" in message.trpc);
    }
    trpcMessage.isTRPCResponse = isTRPCResponse;
    function isTRPCRequest(message) {
      return isTRPCMessageWithId(message) && "method" in message.trpc;
    }
    trpcMessage.isTRPCRequest = isTRPCRequest;
    function isTRPCRequestWithId(message) {
      return isTRPCRequest(message) && isTRPCMessageWithId(message);
    }
    trpcMessage.isTRPCRequestWithId = isTRPCRequestWithId;
    return trpcMessage;
  }
  var errors = {};
  var hasRequiredErrors;
  function requireErrors() {
    if (hasRequiredErrors) return errors;
    hasRequiredErrors = 1;
    Object.defineProperty(errors, "__esModule", { value: true });
    errors.getErrorFromUnknown = void 0;
    const server_1 = requireDist$1();
    function getErrorFromUnknown(cause) {
      if (cause instanceof Error) {
        if (cause.name === "TRPCError") {
          return cause;
        }
        const error = new server_1.TRPCError({
          message: "Internal server error",
          code: "INTERNAL_SERVER_ERROR",
          cause
        });
        error.stack = cause.stack;
        return error;
      }
      return new server_1.TRPCError({
        message: "Internal server error",
        code: "INTERNAL_SERVER_ERROR"
      });
    }
    errors.getErrorFromUnknown = getErrorFromUnknown;
    return errors;
  }
  var hasRequiredChrome$1;
  function requireChrome$1() {
    if (hasRequiredChrome$1) return chrome$1;
    hasRequiredChrome$1 = 1;
    Object.defineProperty(chrome$1, "__esModule", { value: true });
    chrome$1.createChromeHandler = void 0;
    const server_1 = requireDist$1();
    const observable_1 = requireObservable();
    const shared_1 = requireShared();
    const trpcMessage_1 = requireTrpcMessage();
    const errors_1 = requireErrors();
    const createChromeHandler = (opts) => {
      const { router: router2, createContext, onError, chrome: chrome2 = commonjsGlobal.chrome } = opts;
      if (!chrome2) {
        console.warn("Skipping chrome handler creation: 'opts.chrome' not defined");
        return;
      }
      chrome2.runtime.onConnect.addListener((port) => {
        const { transformer } = router2._def._config;
        const subscriptions = /* @__PURE__ */ new Map();
        const listeners = [];
        const cleanup = () => listeners.forEach((unsub) => unsub());
        port.onDisconnect.addListener(cleanup);
        listeners.push(() => port.onDisconnect.removeListener(cleanup));
        const onMessage = async (message) => {
          var _a;
          if (!port || !(0, trpcMessage_1.isTRPCRequestWithId)(message))
            return;
          const { trpc } = message;
          const sendResponse = (response) => {
            port.postMessage({
              trpc: Object.assign({ id: trpc.id, jsonrpc: trpc.jsonrpc }, response)
            });
          };
          if (trpc.method === "subscription.stop") {
            (_a = subscriptions.get(trpc.id)) === null || _a === void 0 ? void 0 : _a.unsubscribe();
            subscriptions.delete(trpc.id);
            return sendResponse({ result: { type: "stopped" } });
          }
          const { method, params, id } = trpc;
          const ctx = await (createContext === null || createContext === void 0 ? void 0 : createContext({ req: port, res: void 0 }));
          const handleError = (cause) => {
            const error = (0, errors_1.getErrorFromUnknown)(cause);
            onError === null || onError === void 0 ? void 0 : onError({
              error,
              type: method,
              path: params.path,
              input: params.input,
              ctx,
              req: port
            });
            sendResponse({
              // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
              error: (0, shared_1.getErrorShape)({
                config: router2._def._config,
                error,
                type: method,
                path: params.path,
                input: params.input,
                ctx
              })
            });
          };
          try {
            const input = transformer.input.deserialize(trpc.params.input);
            const caller = router2.createCaller(ctx);
            const procedureFn = trpc.params.path.split(".").reduce((acc, segment) => acc[segment], caller);
            const result2 = await procedureFn(input);
            if (trpc.method !== "subscription") {
              return sendResponse({
                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call
                result: { type: "data", data: transformer.output.serialize(result2) }
              });
            }
            if (!(0, observable_1.isObservable)(result2)) {
              throw new server_1.TRPCError({
                message: `Subscription ${params.path} did not return an observable`,
                code: "INTERNAL_SERVER_ERROR"
              });
            }
            const subscription = result2.subscribe({
              next: (data) => {
                const serializedData = transformer.output.serialize(data);
                sendResponse({ result: { type: "data", data: serializedData } });
              },
              error: handleError,
              complete: () => sendResponse({ result: { type: "stopped" } })
            });
            if (subscriptions.has(id)) {
              subscription.unsubscribe();
              sendResponse({ result: { type: "stopped" } });
              throw new server_1.TRPCError({ message: `Duplicate id ${id}`, code: "BAD_REQUEST" });
            }
            listeners.push(() => subscription.unsubscribe());
            subscriptions.set(id, subscription);
            sendResponse({ result: { type: "started" } });
          } catch (cause) {
            handleError(cause);
          }
        };
        port.onMessage.addListener(onMessage);
        listeners.push(() => port.onMessage.removeListener(onMessage));
      });
    };
    chrome$1.createChromeHandler = createChromeHandler;
    return chrome$1;
  }
  var window$2 = {};
  var constants = {};
  var hasRequiredConstants;
  function requireConstants() {
    if (hasRequiredConstants) return constants;
    hasRequiredConstants = 1;
    Object.defineProperty(constants, "__esModule", { value: true });
    constants.TRPC_BROWSER_LOADED_EVENT = void 0;
    constants.TRPC_BROWSER_LOADED_EVENT = "TRPC_BROWSER::POPUP_LOADED";
    return constants;
  }
  var hasRequiredWindow$1;
  function requireWindow$1() {
    if (hasRequiredWindow$1) return window$2;
    hasRequiredWindow$1 = 1;
    Object.defineProperty(window$2, "__esModule", { value: true });
    window$2.createWindowHandler = void 0;
    const server_1 = requireDist$1();
    const observable_1 = requireObservable();
    const shared_1 = requireShared();
    const constants_1 = requireConstants();
    const trpcMessage_1 = requireTrpcMessage();
    const errors_1 = requireErrors();
    const createWindowHandler = (opts) => {
      var _a, _b;
      const { router: router2, createContext, onError, window: window2, postOrigin } = opts;
      if (!window2) {
        console.warn("Skipping window handler creation: 'opts.window' not defined");
        return;
      }
      const loadListener = (_b = (_a = opts.postWindow) !== null && _a !== void 0 ? _a : window2.opener) !== null && _b !== void 0 ? _b : window2;
      loadListener.postMessage(constants_1.TRPC_BROWSER_LOADED_EVENT, { targetOrigin: postOrigin });
      const { transformer } = router2._def._config;
      const subscriptions = /* @__PURE__ */ new Map();
      const listeners = [];
      const cleanup = () => listeners.forEach((unsub) => unsub());
      window2.addEventListener("beforeunload", cleanup);
      listeners.push(() => window2.removeEventListener("beforeunload", cleanup));
      const onMessage = async (event) => {
        var _a2, _b2, _c;
        const { data: message, source } = event;
        const postWindow = (_b2 = (_a2 = opts.postWindow) !== null && _a2 !== void 0 ? _a2 : source) !== null && _b2 !== void 0 ? _b2 : window2;
        if (!postWindow || !(0, trpcMessage_1.isTRPCRequestWithId)(message))
          return;
        const { trpc } = message;
        const sendResponse = (response) => {
          postWindow.postMessage({
            trpc: Object.assign({ id: trpc.id, jsonrpc: trpc.jsonrpc }, response)
          }, { targetOrigin: postOrigin });
        };
        if (trpc.method === "subscription.stop") {
          (_c = subscriptions.get(trpc.id)) === null || _c === void 0 ? void 0 : _c.unsubscribe();
          subscriptions.delete(trpc.id);
          return sendResponse({ result: { type: "stopped" } });
        }
        const { method, params, id } = trpc;
        const ctx = await (createContext === null || createContext === void 0 ? void 0 : createContext({ req: { origin: event.origin }, res: void 0 }));
        const handleError = (cause) => {
          const error = (0, errors_1.getErrorFromUnknown)(cause);
          onError === null || onError === void 0 ? void 0 : onError({
            error,
            type: method,
            path: params.path,
            input: params.input,
            ctx,
            req: { origin: event.origin }
          });
          sendResponse({
            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
            error: (0, shared_1.getErrorShape)({
              config: router2._def._config,
              error,
              type: method,
              path: params.path,
              input: params.input,
              ctx
            })
          });
        };
        try {
          const input = transformer.input.deserialize(trpc.params.input);
          const caller = router2.createCaller(ctx);
          const procedureFn = trpc.params.path.split(".").reduce((acc, segment) => acc[segment], caller);
          const result2 = await procedureFn(input);
          if (trpc.method !== "subscription") {
            return sendResponse({
              // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call
              result: { type: "data", data: transformer.output.serialize(result2) }
            });
          }
          if (!(0, observable_1.isObservable)(result2)) {
            throw new server_1.TRPCError({
              message: `Subscription ${params.path} did not return an observable`,
              code: "INTERNAL_SERVER_ERROR"
            });
          }
          const subscription = result2.subscribe({
            next: (data) => {
              const serializedData = transformer.output.serialize(data);
              sendResponse({ result: { type: "data", data: serializedData } });
            },
            error: handleError,
            complete: () => sendResponse({ result: { type: "stopped" } })
          });
          if (subscriptions.has(id)) {
            subscription.unsubscribe();
            sendResponse({ result: { type: "stopped" } });
            throw new server_1.TRPCError({ message: `Duplicate id ${id}`, code: "BAD_REQUEST" });
          }
          listeners.push(() => subscription.unsubscribe());
          subscriptions.set(id, subscription);
          sendResponse({ result: { type: "started" } });
        } catch (cause) {
          handleError(cause);
        }
      };
      window2.addEventListener("message", onMessage);
      listeners.push(() => window2.removeEventListener("message", onMessage));
    };
    window$2.createWindowHandler = createWindowHandler;
    return window$2;
  }
  var hasRequiredAdapter;
  function requireAdapter() {
    if (hasRequiredAdapter) return adapter;
    hasRequiredAdapter = 1;
    (function(exports$1) {
      var __createBinding = adapter && adapter.__createBinding || (Object.create ? (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      }) : (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      }));
      var __exportStar = adapter && adapter.__exportStar || function(m, exports$12) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$12, p)) __createBinding(exports$12, m, p);
      };
      Object.defineProperty(exports$1, "__esModule", { value: true });
      __exportStar(requireChrome$1(), exports$1);
      __exportStar(requireWindow$1(), exports$1);
    })(adapter);
    return adapter;
  }
  var adapterExports = requireAdapter();
  var link = {};
  var chrome = {};
  var base = {};
  var dist = {};
  var splitLinkF29e84be = {};
  var hasRequiredSplitLinkF29e84be;
  function requireSplitLinkF29e84be() {
    if (hasRequiredSplitLinkF29e84be) return splitLinkF29e84be;
    hasRequiredSplitLinkF29e84be = 1;
    var observable2 = requireObservable();
    function createChain2(opts) {
      return observable2.observable((observer) => {
        function execute(index = 0, op = opts.op) {
          const next = opts.links[index];
          if (!next) {
            throw new Error("No more links to execute - did you forget to add an ending link?");
          }
          const subscription = next({
            op,
            next(nextOp) {
              const nextObserver = execute(index + 1, nextOp);
              return nextObserver;
            }
          });
          return subscription;
        }
        const obs$ = execute();
        return obs$.subscribe(observer);
      });
    }
    function asArray(value) {
      return Array.isArray(value) ? value : [
        value
      ];
    }
    function splitLink(opts) {
      return (runtime) => {
        const yes = asArray(opts.true).map((link2) => link2(runtime));
        const no = asArray(opts.false).map((link2) => link2(runtime));
        return (props) => {
          return observable2.observable((observer) => {
            const links = opts.condition(props.op) ? yes : no;
            return createChain2({
              op: props.op,
              links
            }).subscribe(observer);
          });
        };
      };
    }
    splitLinkF29e84be.createChain = createChain2;
    splitLinkF29e84be.splitLink = splitLink;
    return splitLinkF29e84be;
  }
  var TRPCClientError7e0c31e7 = {};
  var transformResultDfce8f15 = {};
  var hasRequiredTransformResultDfce8f15;
  function requireTransformResultDfce8f15() {
    if (hasRequiredTransformResultDfce8f15) return transformResultDfce8f15;
    hasRequiredTransformResultDfce8f15 = 1;
    function isObject2(value) {
      return !!value && !Array.isArray(value) && typeof value === "object";
    }
    function transformResultInner(response, runtime) {
      if ("error" in response) {
        const error = runtime.transformer.deserialize(response.error);
        return {
          ok: false,
          error: {
            ...response,
            error
          }
        };
      }
      const result2 = {
        ...response.result,
        ...(!response.result.type || response.result.type === "data") && {
          type: "data",
          data: runtime.transformer.deserialize(response.result.data)
        }
      };
      return {
        ok: true,
        result: result2
      };
    }
    class TransformResultError extends Error {
      constructor() {
        super("Unable to transform response from server");
      }
    }
    function transformResult(response, runtime) {
      let result2;
      try {
        result2 = transformResultInner(response, runtime);
      } catch (err) {
        throw new TransformResultError();
      }
      if (!result2.ok && (!isObject2(result2.error.error) || typeof result2.error.error.code !== "number")) {
        throw new TransformResultError();
      }
      if (result2.ok && !isObject2(result2.result)) {
        throw new TransformResultError();
      }
      return result2;
    }
    transformResultDfce8f15.isObject = isObject2;
    transformResultDfce8f15.transformResult = transformResult;
    return transformResultDfce8f15;
  }
  var hasRequiredTRPCClientError7e0c31e7;
  function requireTRPCClientError7e0c31e7() {
    if (hasRequiredTRPCClientError7e0c31e7) return TRPCClientError7e0c31e7;
    hasRequiredTRPCClientError7e0c31e7 = 1;
    var shared2 = requireShared();
    var transformResult = requireTransformResultDfce8f15();
    function isTRPCClientError2(cause) {
      return cause instanceof TRPCClientError2 || /**
      * @deprecated
      * Delete in next major
      */
      cause instanceof Error && cause.name === "TRPCClientError";
    }
    function isTRPCErrorResponse2(obj) {
      return transformResult.isObject(obj) && transformResult.isObject(obj.error) && typeof obj.error.code === "number" && typeof obj.error.message === "string";
    }
    class TRPCClientError2 extends Error {
      static from(_cause, opts = {}) {
        const cause = _cause;
        if (isTRPCClientError2(cause)) {
          if (opts.meta) {
            cause.meta = {
              ...cause.meta,
              ...opts.meta
            };
          }
          return cause;
        }
        if (isTRPCErrorResponse2(cause)) {
          return new TRPCClientError2(cause.error.message, {
            ...opts,
            result: cause
          });
        }
        if (!(cause instanceof Error)) {
          return new TRPCClientError2("Unknown error", {
            ...opts,
            cause
          });
        }
        return new TRPCClientError2(cause.message, {
          ...opts,
          cause: shared2.getCauseFromUnknown(cause)
        });
      }
      constructor(message, opts) {
        const cause = opts?.cause;
        super(message, {
          cause
        });
        this.meta = opts?.meta;
        this.cause = cause;
        this.shape = opts?.result?.error;
        this.data = opts?.result?.error.data;
        this.name = "TRPCClientError";
        Object.setPrototypeOf(this, TRPCClientError2.prototype);
      }
    }
    TRPCClientError7e0c31e7.TRPCClientError = TRPCClientError2;
    return TRPCClientError7e0c31e7;
  }
  var httpUtils4429f36e = {};
  var hasRequiredHttpUtils4429f36e;
  function requireHttpUtils4429f36e() {
    if (hasRequiredHttpUtils4429f36e) return httpUtils4429f36e;
    hasRequiredHttpUtils4429f36e = 1;
    var TRPCClientError2 = requireTRPCClientError7e0c31e7();
    const isFunction = (fn) => typeof fn === "function";
    function getFetch(customFetchImpl) {
      if (customFetchImpl) {
        return customFetchImpl;
      }
      if (typeof window !== "undefined" && isFunction(window.fetch)) {
        return window.fetch;
      }
      if (typeof globalThis !== "undefined" && isFunction(globalThis.fetch)) {
        return globalThis.fetch;
      }
      throw new Error("No fetch implementation found");
    }
    function getAbortController(customAbortControllerImpl) {
      if (customAbortControllerImpl) {
        return customAbortControllerImpl;
      }
      if (typeof window !== "undefined" && window.AbortController) {
        return window.AbortController;
      }
      if (typeof globalThis !== "undefined" && globalThis.AbortController) {
        return globalThis.AbortController;
      }
      return null;
    }
    function resolveHTTPLinkOptions(opts) {
      return {
        url: opts.url.toString().replace(/\/$/, ""),
        fetch: opts.fetch,
        AbortController: getAbortController(opts.AbortController)
      };
    }
    function arrayToDict(array) {
      const dict = {};
      for (let index = 0; index < array.length; index++) {
        const element = array[index];
        dict[index] = element;
      }
      return dict;
    }
    const METHOD = {
      query: "GET",
      mutation: "POST"
    };
    function getInput(opts) {
      return "input" in opts ? opts.runtime.transformer.serialize(opts.input) : arrayToDict(opts.inputs.map((_input) => opts.runtime.transformer.serialize(_input)));
    }
    const getUrl = (opts) => {
      let url = opts.url + "/" + opts.path;
      const queryParts = [];
      if ("inputs" in opts) {
        queryParts.push("batch=1");
      }
      if (opts.type === "query") {
        const input = getInput(opts);
        if (input !== void 0) {
          queryParts.push(`input=${encodeURIComponent(JSON.stringify(input))}`);
        }
      }
      if (queryParts.length) {
        url += "?" + queryParts.join("&");
      }
      return url;
    };
    const getBody = (opts) => {
      if (opts.type === "query") {
        return void 0;
      }
      const input = getInput(opts);
      return input !== void 0 ? JSON.stringify(input) : void 0;
    };
    const jsonHttpRequester = (opts) => {
      return httpRequest({
        ...opts,
        contentTypeHeader: "application/json",
        getUrl,
        getBody
      });
    };
    async function fetchHTTPResponse(opts, ac) {
      const url = opts.getUrl(opts);
      const body = opts.getBody(opts);
      const { type } = opts;
      const resolvedHeaders = await opts.headers();
      if (type === "subscription") {
        throw new Error("Subscriptions should use wsLink");
      }
      const headers = {
        ...opts.contentTypeHeader ? {
          "content-type": opts.contentTypeHeader
        } : {},
        ...opts.batchModeHeader ? {
          "trpc-batch-mode": opts.batchModeHeader
        } : {},
        ...resolvedHeaders
      };
      return getFetch(opts.fetch)(url, {
        method: METHOD[type],
        signal: ac?.signal,
        body,
        headers
      });
    }
    function httpRequest(opts) {
      const ac = opts.AbortController ? new opts.AbortController() : null;
      const meta = {};
      let done = false;
      const promise = new Promise((resolve, reject) => {
        fetchHTTPResponse(opts, ac).then((_res) => {
          meta.response = _res;
          done = true;
          return _res.json();
        }).then((json) => {
          meta.responseJSON = json;
          resolve({
            json,
            meta
          });
        }).catch((err) => {
          done = true;
          reject(TRPCClientError2.TRPCClientError.from(err, {
            meta
          }));
        });
      });
      const cancel = () => {
        if (!done) {
          ac?.abort();
        }
      };
      return {
        promise,
        cancel
      };
    }
    httpUtils4429f36e.fetchHTTPResponse = fetchHTTPResponse;
    httpUtils4429f36e.getBody = getBody;
    httpUtils4429f36e.getFetch = getFetch;
    httpUtils4429f36e.getUrl = getUrl;
    httpUtils4429f36e.httpRequest = httpRequest;
    httpUtils4429f36e.jsonHttpRequester = jsonHttpRequester;
    httpUtils4429f36e.resolveHTTPLinkOptions = resolveHTTPLinkOptions;
    return httpUtils4429f36e;
  }
  var httpBatchLink6b5ba638 = {};
  var hasRequiredHttpBatchLink6b5ba638;
  function requireHttpBatchLink6b5ba638() {
    if (hasRequiredHttpBatchLink6b5ba638) return httpBatchLink6b5ba638;
    hasRequiredHttpBatchLink6b5ba638 = 1;
    var observable2 = requireObservable();
    var transformResult = requireTransformResultDfce8f15();
    var TRPCClientError2 = requireTRPCClientError7e0c31e7();
    var httpUtils = requireHttpUtils4429f36e();
    const throwFatalError = () => {
      throw new Error("Something went wrong. Please submit an issue at https://github.com/trpc/trpc/issues/new");
    };
    function dataLoader(batchLoader) {
      let pendingItems = null;
      let dispatchTimer = null;
      const destroyTimerAndPendingItems = () => {
        clearTimeout(dispatchTimer);
        dispatchTimer = null;
        pendingItems = null;
      };
      function groupItems(items) {
        const groupedItems = [
          []
        ];
        let index = 0;
        while (true) {
          const item = items[index];
          if (!item) {
            break;
          }
          const lastGroup = groupedItems[groupedItems.length - 1];
          if (item.aborted) {
            item.reject?.(new Error("Aborted"));
            index++;
            continue;
          }
          const isValid2 = batchLoader.validate(lastGroup.concat(item).map((it) => it.key));
          if (isValid2) {
            lastGroup.push(item);
            index++;
            continue;
          }
          if (lastGroup.length === 0) {
            item.reject?.(new Error("Input is too big for a single dispatch"));
            index++;
            continue;
          }
          groupedItems.push([]);
        }
        return groupedItems;
      }
      function dispatch() {
        const groupedItems = groupItems(pendingItems);
        destroyTimerAndPendingItems();
        for (const items of groupedItems) {
          if (!items.length) {
            continue;
          }
          const batch = {
            items,
            cancel: throwFatalError
          };
          for (const item of items) {
            item.batch = batch;
          }
          const unitResolver = (index, value) => {
            const item = batch.items[index];
            item.resolve?.(value);
            item.batch = null;
            item.reject = null;
            item.resolve = null;
          };
          const { promise, cancel } = batchLoader.fetch(batch.items.map((_item) => _item.key), unitResolver);
          batch.cancel = cancel;
          promise.then((result2) => {
            for (let i = 0; i < result2.length; i++) {
              const value = result2[i];
              unitResolver(i, value);
            }
            for (const item of batch.items) {
              item.reject?.(new Error("Missing result"));
              item.batch = null;
            }
          }).catch((cause) => {
            for (const item of batch.items) {
              item.reject?.(cause);
              item.batch = null;
            }
          });
        }
      }
      function load(key) {
        const item = {
          aborted: false,
          key,
          batch: null,
          resolve: throwFatalError,
          reject: throwFatalError
        };
        const promise = new Promise((resolve, reject) => {
          item.reject = reject;
          item.resolve = resolve;
          if (!pendingItems) {
            pendingItems = [];
          }
          pendingItems.push(item);
        });
        if (!dispatchTimer) {
          dispatchTimer = setTimeout(dispatch);
        }
        const cancel = () => {
          item.aborted = true;
          if (item.batch?.items.every((item2) => item2.aborted)) {
            item.batch.cancel();
            item.batch = null;
          }
        };
        return {
          promise,
          cancel
        };
      }
      return {
        load
      };
    }
    function createHTTPBatchLink(requester) {
      return function httpBatchLink2(opts) {
        const resolvedOpts = httpUtils.resolveHTTPLinkOptions(opts);
        const maxURLLength = opts.maxURLLength ?? Infinity;
        return (runtime) => {
          const batchLoader = (type) => {
            const validate = (batchOps) => {
              if (maxURLLength === Infinity) {
                return true;
              }
              const path = batchOps.map((op) => op.path).join(",");
              const inputs = batchOps.map((op) => op.input);
              const url = httpUtils.getUrl({
                ...resolvedOpts,
                runtime,
                type,
                path,
                inputs
              });
              return url.length <= maxURLLength;
            };
            const fetch2 = requester({
              ...resolvedOpts,
              runtime,
              type,
              opts
            });
            return {
              validate,
              fetch: fetch2
            };
          };
          const query = dataLoader(batchLoader("query"));
          const mutation = dataLoader(batchLoader("mutation"));
          const subscription = dataLoader(batchLoader("subscription"));
          const loaders = {
            query,
            subscription,
            mutation
          };
          return ({ op }) => {
            return observable2.observable((observer) => {
              const loader = loaders[op.type];
              const { promise, cancel } = loader.load(op);
              let _res = void 0;
              promise.then((res) => {
                _res = res;
                const transformed = transformResult.transformResult(res.json, runtime);
                if (!transformed.ok) {
                  observer.error(TRPCClientError2.TRPCClientError.from(transformed.error, {
                    meta: res.meta
                  }));
                  return;
                }
                observer.next({
                  context: res.meta,
                  result: transformed.result
                });
                observer.complete();
              }).catch((err) => {
                observer.error(TRPCClientError2.TRPCClientError.from(err, {
                  meta: _res?.meta
                }));
              });
              return () => {
                cancel();
              };
            });
          };
        };
      };
    }
    const batchRequester = (requesterOpts) => {
      return (batchOps) => {
        const path = batchOps.map((op) => op.path).join(",");
        const inputs = batchOps.map((op) => op.input);
        const { promise, cancel } = httpUtils.jsonHttpRequester({
          ...requesterOpts,
          path,
          inputs,
          headers() {
            if (!requesterOpts.opts.headers) {
              return {};
            }
            if (typeof requesterOpts.opts.headers === "function") {
              return requesterOpts.opts.headers({
                opList: batchOps
              });
            }
            return requesterOpts.opts.headers;
          }
        });
        return {
          promise: promise.then((res) => {
            const resJSON = Array.isArray(res.json) ? res.json : batchOps.map(() => res.json);
            const result2 = resJSON.map((item) => ({
              meta: res.meta,
              json: item
            }));
            return result2;
          }),
          cancel
        };
      };
    };
    const httpBatchLink = createHTTPBatchLink(batchRequester);
    httpBatchLink6b5ba638.createHTTPBatchLink = createHTTPBatchLink;
    httpBatchLink6b5ba638.httpBatchLink = httpBatchLink;
    return httpBatchLink6b5ba638;
  }
  var httpLink = {};
  var hasRequiredHttpLink;
  function requireHttpLink() {
    if (hasRequiredHttpLink) return httpLink;
    hasRequiredHttpLink = 1;
    Object.defineProperty(httpLink, "__esModule", { value: true });
    var observable2 = requireObservable();
    var transformResult = requireTransformResultDfce8f15();
    var TRPCClientError2 = requireTRPCClientError7e0c31e7();
    var httpUtils = requireHttpUtils4429f36e();
    requireShared();
    function httpLinkFactory(factoryOpts) {
      return (opts) => {
        const resolvedOpts = httpUtils.resolveHTTPLinkOptions(opts);
        return (runtime) => ({ op }) => observable2.observable((observer) => {
          const { path, input, type } = op;
          const { promise, cancel } = factoryOpts.requester({
            ...resolvedOpts,
            runtime,
            type,
            path,
            input,
            headers() {
              if (!opts.headers) {
                return {};
              }
              if (typeof opts.headers === "function") {
                return opts.headers({
                  op
                });
              }
              return opts.headers;
            }
          });
          let meta = void 0;
          promise.then((res) => {
            meta = res.meta;
            const transformed = transformResult.transformResult(res.json, runtime);
            if (!transformed.ok) {
              observer.error(TRPCClientError2.TRPCClientError.from(transformed.error, {
                meta
              }));
              return;
            }
            observer.next({
              context: res.meta,
              result: transformed.result
            });
            observer.complete();
          }).catch((cause) => {
            observer.error(TRPCClientError2.TRPCClientError.from(cause, {
              meta
            }));
          });
          return () => {
            cancel();
          };
        });
      };
    }
    const httpLink$1 = httpLinkFactory({
      requester: httpUtils.jsonHttpRequester
    });
    httpLink.httpLink = httpLink$1;
    httpLink.httpLinkFactory = httpLinkFactory;
    return httpLink;
  }
  var loggerLink = {};
  var hasRequiredLoggerLink;
  function requireLoggerLink() {
    if (hasRequiredLoggerLink) return loggerLink;
    hasRequiredLoggerLink = 1;
    Object.defineProperty(loggerLink, "__esModule", { value: true });
    var observable2 = requireObservable();
    function isFormData(value) {
      if (typeof FormData === "undefined") {
        return false;
      }
      return value instanceof FormData;
    }
    const palettes = {
      css: {
        query: [
          "72e3ff",
          "3fb0d8"
        ],
        mutation: [
          "c5a3fc",
          "904dfc"
        ],
        subscription: [
          "ff49e1",
          "d83fbe"
        ]
      },
      ansi: {
        regular: {
          // Cyan background, black and white text respectively
          query: [
            "\x1B[30;46m",
            "\x1B[97;46m"
          ],
          // Magenta background, black and white text respectively
          mutation: [
            "\x1B[30;45m",
            "\x1B[97;45m"
          ],
          // Green background, black and white text respectively
          subscription: [
            "\x1B[30;42m",
            "\x1B[97;42m"
          ]
        },
        bold: {
          query: [
            "\x1B[1;30;46m",
            "\x1B[1;97;46m"
          ],
          mutation: [
            "\x1B[1;30;45m",
            "\x1B[1;97;45m"
          ],
          subscription: [
            "\x1B[1;30;42m",
            "\x1B[1;97;42m"
          ]
        }
      }
    };
    function constructPartsAndArgs(opts) {
      const { direction, type, path, id, input } = opts;
      const parts = [];
      const args = [];
      if (opts.colorMode === "ansi") {
        const [lightRegular, darkRegular] = palettes.ansi.regular[type];
        const [lightBold, darkBold] = palettes.ansi.bold[type];
        const reset = "\x1B[0m";
        parts.push(direction === "up" ? lightRegular : darkRegular, direction === "up" ? ">>" : "<<", type, direction === "up" ? lightBold : darkBold, `#${id}`, path, reset);
        if (direction === "up") {
          args.push({
            input: opts.input
          });
        } else {
          args.push({
            input: opts.input,
            // strip context from result cause it's too noisy in terminal wihtout collapse mode
            result: "result" in opts.result ? opts.result.result : opts.result,
            elapsedMs: opts.elapsedMs
          });
        }
        return {
          parts,
          args
        };
      }
      const [light, dark] = palettes.css[type];
      const css = `
    background-color: #${direction === "up" ? light : dark}; 
    color: ${direction === "up" ? "black" : "white"};
    padding: 2px;
  `;
      parts.push("%c", direction === "up" ? ">>" : "<<", type, `#${id}`, `%c${path}%c`, "%O");
      args.push(css, `${css}; font-weight: bold;`, `${css}; font-weight: normal;`);
      if (direction === "up") {
        args.push({
          input,
          context: opts.context
        });
      } else {
        args.push({
          input,
          result: opts.result,
          elapsedMs: opts.elapsedMs,
          context: opts.context
        });
      }
      return {
        parts,
        args
      };
    }
    const defaultLogger = ({ c = console, colorMode = "css" }) => (props) => {
      const rawInput = props.input;
      const input = isFormData(rawInput) ? Object.fromEntries(rawInput) : rawInput;
      const { parts, args } = constructPartsAndArgs({
        ...props,
        colorMode,
        input
      });
      const fn = props.direction === "down" && props.result && (props.result instanceof Error || "error" in props.result.result) ? "error" : "log";
      c[fn].apply(null, [
        parts.join(" ")
      ].concat(args));
    };
    function loggerLink$1(opts = {}) {
      const { enabled = () => true } = opts;
      const colorMode = opts.colorMode ?? (typeof window === "undefined" ? "ansi" : "css");
      const { logger: logger2 = defaultLogger({
        c: opts.console,
        colorMode
      }) } = opts;
      return () => {
        return ({ op, next }) => {
          return observable2.observable((observer) => {
            enabled({
              ...op,
              direction: "up"
            }) && logger2({
              ...op,
              direction: "up"
            });
            const requestStartTime = Date.now();
            function logResult(result2) {
              const elapsedMs = Date.now() - requestStartTime;
              enabled({
                ...op,
                direction: "down",
                result: result2
              }) && logger2({
                ...op,
                direction: "down",
                elapsedMs,
                result: result2
              });
            }
            return next(op).pipe(observable2.tap({
              next(result2) {
                logResult(result2);
              },
              error(result2) {
                logResult(result2);
              }
            })).subscribe(observer);
          });
        };
      };
    }
    loggerLink.loggerLink = loggerLink$1;
    return loggerLink;
  }
  var wsLink = {};
  var hasRequiredWsLink;
  function requireWsLink() {
    if (hasRequiredWsLink) return wsLink;
    hasRequiredWsLink = 1;
    Object.defineProperty(wsLink, "__esModule", { value: true });
    var observable2 = requireObservable();
    var transformResult = requireTransformResultDfce8f15();
    var TRPCClientError2 = requireTRPCClientError7e0c31e7();
    requireShared();
    const retryDelay = (attemptIndex) => attemptIndex === 0 ? 0 : Math.min(1e3 * 2 ** attemptIndex, 3e4);
    function createWSClient(opts) {
      const { url, WebSocket: WebSocketImpl = WebSocket, retryDelayMs: retryDelayFn = retryDelay, onOpen, onClose } = opts;
      if (!WebSocketImpl) {
        throw new Error("No WebSocket implementation found - you probably don't want to use this on the server, but if you do you need to pass a `WebSocket`-ponyfill");
      }
      let outgoing = [];
      const pendingRequests = /* @__PURE__ */ Object.create(null);
      let connectAttempt = 0;
      let dispatchTimer = null;
      let connectTimer = null;
      let activeConnection = createWS();
      let state = "connecting";
      function dispatch() {
        if (state !== "open" || dispatchTimer) {
          return;
        }
        dispatchTimer = setTimeout(() => {
          dispatchTimer = null;
          if (outgoing.length === 1) {
            activeConnection.send(JSON.stringify(outgoing.pop()));
          } else {
            activeConnection.send(JSON.stringify(outgoing));
          }
          outgoing = [];
        });
      }
      function tryReconnect() {
        if (connectTimer !== null || state === "closed") {
          return;
        }
        const timeout = retryDelayFn(connectAttempt++);
        reconnectInMs(timeout);
      }
      function reconnect() {
        state = "connecting";
        const oldConnection = activeConnection;
        activeConnection = createWS();
        closeIfNoPending(oldConnection);
      }
      function reconnectInMs(ms) {
        if (connectTimer) {
          return;
        }
        state = "connecting";
        connectTimer = setTimeout(reconnect, ms);
      }
      function closeIfNoPending(conn) {
        const hasPendingRequests = Object.values(pendingRequests).some((p) => p.ws === conn);
        if (!hasPendingRequests) {
          conn.close();
        }
      }
      function closeActiveSubscriptions() {
        Object.values(pendingRequests).forEach((req) => {
          if (req.type === "subscription") {
            req.callbacks.complete();
          }
        });
      }
      function resumeSubscriptionOnReconnect(req) {
        if (outgoing.some((r) => r.id === req.op.id)) {
          return;
        }
        request(req.op, req.callbacks);
      }
      function createWS() {
        const urlString = typeof url === "function" ? url() : url;
        const conn = new WebSocketImpl(urlString);
        clearTimeout(connectTimer);
        connectTimer = null;
        conn.addEventListener("open", () => {
          if (conn !== activeConnection) {
            return;
          }
          connectAttempt = 0;
          state = "open";
          onOpen?.();
          dispatch();
        });
        conn.addEventListener("error", () => {
          if (conn === activeConnection) {
            tryReconnect();
          }
        });
        const handleIncomingRequest = (req) => {
          if (req.method === "reconnect" && conn === activeConnection) {
            if (state === "open") {
              onClose?.();
            }
            reconnect();
            for (const pendingReq of Object.values(pendingRequests)) {
              if (pendingReq.type === "subscription") {
                resumeSubscriptionOnReconnect(pendingReq);
              }
            }
          }
        };
        const handleIncomingResponse = (data) => {
          const req = data.id !== null && pendingRequests[data.id];
          if (!req) {
            return;
          }
          req.callbacks.next?.(data);
          if (req.ws !== activeConnection && conn === activeConnection) {
            const oldWs = req.ws;
            req.ws = activeConnection;
            closeIfNoPending(oldWs);
          }
          if ("result" in data && data.result.type === "stopped" && conn === activeConnection) {
            req.callbacks.complete();
          }
        };
        conn.addEventListener("message", ({ data }) => {
          const msg = JSON.parse(data);
          if ("method" in msg) {
            handleIncomingRequest(msg);
          } else {
            handleIncomingResponse(msg);
          }
          if (conn !== activeConnection || state === "closed") {
            closeIfNoPending(conn);
          }
        });
        conn.addEventListener("close", ({ code }) => {
          if (state === "open") {
            onClose?.({
              code
            });
          }
          if (activeConnection === conn) {
            tryReconnect();
          }
          for (const [key, req] of Object.entries(pendingRequests)) {
            if (req.ws !== conn) {
              continue;
            }
            if (state === "closed") {
              delete pendingRequests[key];
              req.callbacks.complete?.();
              continue;
            }
            if (req.type === "subscription") {
              resumeSubscriptionOnReconnect(req);
            } else {
              delete pendingRequests[key];
              req.callbacks.error?.(TRPCClientError2.TRPCClientError.from(new TRPCWebSocketClosedError("WebSocket closed prematurely")));
            }
          }
        });
        return conn;
      }
      function request(op, callbacks) {
        const { type, input, path, id } = op;
        const envelope = {
          id,
          method: type,
          params: {
            input,
            path
          }
        };
        pendingRequests[id] = {
          ws: activeConnection,
          type,
          callbacks,
          op
        };
        outgoing.push(envelope);
        dispatch();
        return () => {
          const callbacks2 = pendingRequests[id]?.callbacks;
          delete pendingRequests[id];
          outgoing = outgoing.filter((msg) => msg.id !== id);
          callbacks2?.complete?.();
          if (activeConnection.readyState === WebSocketImpl.OPEN && op.type === "subscription") {
            outgoing.push({
              id,
              method: "subscription.stop"
            });
            dispatch();
          }
        };
      }
      return {
        close: () => {
          state = "closed";
          onClose?.();
          closeActiveSubscriptions();
          closeIfNoPending(activeConnection);
          clearTimeout(connectTimer);
          connectTimer = null;
        },
        request,
        getConnection() {
          return activeConnection;
        }
      };
    }
    class TRPCWebSocketClosedError extends Error {
      constructor(message) {
        super(message);
        this.name = "TRPCWebSocketClosedError";
        Object.setPrototypeOf(this, TRPCWebSocketClosedError.prototype);
      }
    }
    function wsLink$1(opts) {
      return (runtime) => {
        const { client } = opts;
        return ({ op }) => {
          return observable2.observable((observer) => {
            const { type, path, id, context } = op;
            const input = runtime.transformer.serialize(op.input);
            const unsub = client.request({
              type,
              path,
              input,
              id,
              context
            }, {
              error(err) {
                observer.error(err);
                unsub();
              },
              complete() {
                observer.complete();
              },
              next(message) {
                const transformed = transformResult.transformResult(message, runtime);
                if (!transformed.ok) {
                  observer.error(TRPCClientError2.TRPCClientError.from(transformed.error));
                  return;
                }
                observer.next({
                  result: transformed.result
                });
                if (op.type !== "subscription") {
                  unsub();
                  observer.complete();
                }
              }
            });
            return () => {
              unsub();
            };
          });
        };
      };
    }
    wsLink.createWSClient = createWSClient;
    wsLink.wsLink = wsLink$1;
    return wsLink;
  }
  var hasRequiredDist;
  function requireDist() {
    if (hasRequiredDist) return dist;
    hasRequiredDist = 1;
    Object.defineProperty(dist, "__esModule", { value: true });
    var observable2 = requireObservable();
    var links_splitLink = requireSplitLinkF29e84be();
    var TRPCClientError2 = requireTRPCClientError7e0c31e7();
    var shared2 = requireShared();
    var httpUtils = requireHttpUtils4429f36e();
    var links_httpBatchLink = requireHttpBatchLink6b5ba638();
    var links_httpLink = requireHttpLink();
    var links_loggerLink = requireLoggerLink();
    var links_wsLink = requireWsLink();
    requireTransformResultDfce8f15();
    class TRPCUntypedClient2 {
      $request({ type, input, path, context = {} }) {
        const chain$ = links_splitLink.createChain({
          links: this.links,
          op: {
            id: ++this.requestId,
            type,
            path,
            input,
            context
          }
        });
        return chain$.pipe(observable2.share());
      }
      requestAsPromise(opts) {
        const req$ = this.$request(opts);
        const { promise, abort } = observable2.observableToPromise(req$);
        const abortablePromise = new Promise((resolve, reject) => {
          opts.signal?.addEventListener("abort", abort);
          promise.then((envelope) => {
            resolve(envelope.result.data);
          }).catch((err) => {
            reject(TRPCClientError2.TRPCClientError.from(err));
          });
        });
        return abortablePromise;
      }
      query(path, input, opts) {
        return this.requestAsPromise({
          type: "query",
          path,
          input,
          context: opts?.context,
          signal: opts?.signal
        });
      }
      mutation(path, input, opts) {
        return this.requestAsPromise({
          type: "mutation",
          path,
          input,
          context: opts?.context,
          signal: opts?.signal
        });
      }
      subscription(path, input, opts) {
        const observable$ = this.$request({
          type: "subscription",
          path,
          input,
          context: opts?.context
        });
        return observable$.subscribe({
          next(envelope) {
            if (envelope.result.type === "started") {
              opts.onStarted?.();
            } else if (envelope.result.type === "stopped") {
              opts.onStopped?.();
            } else {
              opts.onData?.(envelope.result.data);
            }
          },
          error(err) {
            opts.onError?.(err);
          },
          complete() {
            opts.onComplete?.();
          }
        });
      }
      constructor(opts) {
        this.requestId = 0;
        const combinedTransformer = (() => {
          const transformer = opts.transformer;
          if (!transformer) {
            return {
              input: {
                serialize: (data) => data,
                deserialize: (data) => data
              },
              output: {
                serialize: (data) => data,
                deserialize: (data) => data
              }
            };
          }
          if ("input" in transformer) {
            return opts.transformer;
          }
          return {
            input: transformer,
            output: transformer
          };
        })();
        this.runtime = {
          transformer: {
            serialize: (data) => combinedTransformer.input.serialize(data),
            deserialize: (data) => combinedTransformer.output.deserialize(data)
          },
          combinedTransformer
        };
        this.links = opts.links.map((link2) => link2(this.runtime));
      }
    }
    function createTRPCUntypedClient(opts) {
      return new TRPCUntypedClient2(opts);
    }
    function createTRPCClient(opts) {
      const client = new TRPCUntypedClient2(opts);
      return client;
    }
    const clientCallTypeMap2 = {
      query: "query",
      mutate: "mutation",
      subscribe: "subscription"
    };
    const clientCallTypeToProcedureType2 = (clientCallType) => {
      return clientCallTypeMap2[clientCallType];
    };
    function createTRPCClientProxy2(client) {
      return shared2.createFlatProxy((key) => {
        if (client.hasOwnProperty(key)) {
          return client[key];
        }
        if (key === "__untypedClient") {
          return client;
        }
        return shared2.createRecursiveProxy(({ path, args }) => {
          const pathCopy = [
            key,
            ...path
          ];
          const procedureType = clientCallTypeToProcedureType2(pathCopy.pop());
          const fullPath = pathCopy.join(".");
          return client[procedureType](fullPath, ...args);
        });
      });
    }
    function createTRPCProxyClient2(opts) {
      const client = new TRPCUntypedClient2(opts);
      const proxy = createTRPCClientProxy2(client);
      return proxy;
    }
    function getUntypedClient(client) {
      return client.__untypedClient;
    }
    function getTextDecoder(customTextDecoder) {
      if (customTextDecoder) {
        return customTextDecoder;
      }
      if (typeof window !== "undefined" && window.TextDecoder) {
        return new window.TextDecoder();
      }
      if (typeof globalThis !== "undefined" && globalThis.TextDecoder) {
        return new globalThis.TextDecoder();
      }
      throw new Error("No TextDecoder implementation found");
    }
    async function parseJSONStream(opts) {
      const parse = opts.parse ?? JSON.parse;
      const onLine = (line) => {
        if (opts.signal?.aborted) return;
        if (!line || line === "}") {
          return;
        }
        const indexOfColon = line.indexOf(":");
        const indexAsStr = line.substring(2, indexOfColon - 1);
        const text = line.substring(indexOfColon + 1);
        opts.onSingle(Number(indexAsStr), parse(text));
      };
      await readLines(opts.readableStream, onLine, opts.textDecoder);
    }
    async function readLines(readableStream, onLine, textDecoder) {
      let partOfLine = "";
      const onChunk = (chunk) => {
        const chunkText = textDecoder.decode(chunk);
        const chunkLines = chunkText.split("\n");
        if (chunkLines.length === 1) {
          partOfLine += chunkLines[0];
        } else if (chunkLines.length > 1) {
          onLine(partOfLine + chunkLines[0]);
          for (let i = 1; i < chunkLines.length - 1; i++) {
            onLine(chunkLines[i]);
          }
          partOfLine = chunkLines[chunkLines.length - 1];
        }
      };
      if ("getReader" in readableStream) {
        await readStandardChunks(readableStream, onChunk);
      } else {
        await readNodeChunks(readableStream, onChunk);
      }
      onLine(partOfLine);
    }
    function readNodeChunks(stream, onChunk) {
      return new Promise((resolve) => {
        stream.on("data", onChunk);
        stream.on("end", resolve);
      });
    }
    async function readStandardChunks(stream, onChunk) {
      const reader = stream.getReader();
      let readResult = await reader.read();
      while (!readResult.done) {
        onChunk(readResult.value);
        readResult = await reader.read();
      }
    }
    const streamingJsonHttpRequester = (opts, onSingle) => {
      const ac = opts.AbortController ? new opts.AbortController() : null;
      const responsePromise = httpUtils.fetchHTTPResponse({
        ...opts,
        contentTypeHeader: "application/json",
        batchModeHeader: "stream",
        getUrl: httpUtils.getUrl,
        getBody: httpUtils.getBody
      }, ac);
      const cancel = () => ac?.abort();
      const promise = responsePromise.then(async (res) => {
        if (!res.body) throw new Error("Received response without body");
        const meta = {
          response: res
        };
        return parseJSONStream({
          readableStream: res.body,
          onSingle,
          parse: (string) => ({
            json: JSON.parse(string),
            meta
          }),
          signal: ac?.signal,
          textDecoder: opts.textDecoder
        });
      });
      return {
        cancel,
        promise
      };
    };
    const streamRequester = (requesterOpts) => {
      const textDecoder = getTextDecoder(requesterOpts.opts.textDecoder);
      return (batchOps, unitResolver) => {
        const path = batchOps.map((op) => op.path).join(",");
        const inputs = batchOps.map((op) => op.input);
        const { cancel, promise } = streamingJsonHttpRequester({
          ...requesterOpts,
          textDecoder,
          path,
          inputs,
          headers() {
            if (!requesterOpts.opts.headers) {
              return {};
            }
            if (typeof requesterOpts.opts.headers === "function") {
              return requesterOpts.opts.headers({
                opList: batchOps
              });
            }
            return requesterOpts.opts.headers;
          }
        }, (index, res) => {
          unitResolver(index, res);
        });
        return {
          /**
          * return an empty array because the batchLoader expects an array of results
          * but we've already called the `unitResolver` for each of them, there's
          * nothing left to do here.
          */
          promise: promise.then(() => []),
          cancel
        };
      };
    };
    const unstable_httpBatchStreamLink = links_httpBatchLink.createHTTPBatchLink(streamRequester);
    const getBody = (opts) => {
      if (!("input" in opts)) {
        return void 0;
      }
      if (!(opts.input instanceof FormData)) {
        throw new Error("Input is not FormData");
      }
      return opts.input;
    };
    const formDataRequester = (opts) => {
      if (opts.type !== "mutation") {
        throw new Error("We only handle mutations with formdata");
      }
      return httpUtils.httpRequest({
        ...opts,
        getUrl() {
          return `${opts.url}/${opts.path}`;
        },
        getBody
      });
    };
    const experimental_formDataLink = links_httpLink.httpLinkFactory({
      requester: formDataRequester
    });
    dist.splitLink = links_splitLink.splitLink;
    dist.TRPCClientError = TRPCClientError2.TRPCClientError;
    dist.getFetch = httpUtils.getFetch;
    dist.httpBatchLink = links_httpBatchLink.httpBatchLink;
    dist.httpLink = links_httpLink.httpLink;
    dist.httpLinkFactory = links_httpLink.httpLinkFactory;
    dist.loggerLink = links_loggerLink.loggerLink;
    dist.createWSClient = links_wsLink.createWSClient;
    dist.wsLink = links_wsLink.wsLink;
    dist.TRPCUntypedClient = TRPCUntypedClient2;
    dist.clientCallTypeToProcedureType = clientCallTypeToProcedureType2;
    dist.createTRPCClient = createTRPCClient;
    dist.createTRPCClientProxy = createTRPCClientProxy2;
    dist.createTRPCProxyClient = createTRPCProxyClient2;
    dist.createTRPCUntypedClient = createTRPCUntypedClient;
    dist.experimental_formDataLink = experimental_formDataLink;
    dist.getUntypedClient = getUntypedClient;
    dist.unstable_httpBatchStreamLink = unstable_httpBatchStreamLink;
    return dist;
  }
  var hasRequiredBase;
  function requireBase() {
    if (hasRequiredBase) return base;
    hasRequiredBase = 1;
    Object.defineProperty(base, "__esModule", { value: true });
    base.createBaseLink = void 0;
    const client_1 = requireDist();
    const observable_1 = requireObservable();
    const trpcMessage_1 = requireTrpcMessage();
    const createBaseLink = (methods) => {
      return (runtime) => {
        return ({ op }) => {
          return (0, observable_1.observable)((observer) => {
            const listeners = [];
            const { id, type, path } = op;
            try {
              const input = runtime.transformer.serialize(op.input);
              const onDisconnect = () => {
                observer.error(new client_1.TRPCClientError("Port disconnected prematurely"));
              };
              methods.addCloseListener(onDisconnect);
              listeners.push(() => methods.removeCloseListener(onDisconnect));
              const onMessage = (message) => {
                if (!(0, trpcMessage_1.isTRPCResponse)(message))
                  return;
                const { trpc } = message;
                if (id !== trpc.id)
                  return;
                if ("error" in trpc) {
                  return observer.error(client_1.TRPCClientError.from(trpc));
                }
                observer.next({
                  result: Object.assign(Object.assign({}, trpc.result), (!trpc.result.type || trpc.result.type === "data") && {
                    type: "data",
                    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                    data: runtime.transformer.deserialize(trpc.result.data)
                  })
                });
                if (type !== "subscription" || trpc.result.type === "stopped") {
                  observer.complete();
                }
              };
              methods.addMessageListener(onMessage);
              listeners.push(() => methods.removeMessageListener(onMessage));
              methods.postMessage({
                trpc: {
                  id,
                  jsonrpc: void 0,
                  method: type,
                  // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                  params: { path, input }
                }
              });
            } catch (cause) {
              observer.error(new client_1.TRPCClientError(cause instanceof Error ? cause.message : "Unknown error"));
            }
            return () => {
              if (type === "subscription") {
                methods.postMessage({
                  trpc: {
                    id,
                    jsonrpc: void 0,
                    method: "subscription.stop"
                  }
                });
              }
              listeners.forEach((unsub) => unsub());
            };
          });
        };
      };
    };
    base.createBaseLink = createBaseLink;
    return base;
  }
  var hasRequiredChrome;
  function requireChrome() {
    if (hasRequiredChrome) return chrome;
    hasRequiredChrome = 1;
    Object.defineProperty(chrome, "__esModule", { value: true });
    chrome.chromeLink = void 0;
    const base_1 = requireBase();
    const chromeLink = (opts) => {
      return (0, base_1.createBaseLink)({
        postMessage(message) {
          opts.port.postMessage(message);
        },
        addMessageListener(listener) {
          opts.port.onMessage.addListener(listener);
        },
        removeMessageListener(listener) {
          opts.port.onMessage.removeListener(listener);
        },
        addCloseListener(listener) {
          opts.port.onDisconnect.addListener(listener);
        },
        removeCloseListener(listener) {
          opts.port.onDisconnect.removeListener(listener);
        }
      });
    };
    chrome.chromeLink = chromeLink;
    return chrome;
  }
  var window$1 = {};
  var hasRequiredWindow;
  function requireWindow() {
    if (hasRequiredWindow) return window$1;
    hasRequiredWindow = 1;
    Object.defineProperty(window$1, "__esModule", { value: true });
    window$1.windowLink = void 0;
    const base_1 = requireBase();
    const windowLink = (opts) => {
      var _a;
      const handlerMap = /* @__PURE__ */ new Map();
      const listenWindow = opts.window;
      const postWindow = (_a = opts.postWindow) !== null && _a !== void 0 ? _a : listenWindow;
      const safeEventListener = (action, event, handler) => {
        try {
          listenWindow[`${action}EventListener`](event, handler);
        } catch (err) {
          console.error(`Failed to ${action} ${event} listener:`, err);
        }
      };
      return (0, base_1.createBaseLink)({
        postMessage(message) {
          postWindow.postMessage(message, {
            targetOrigin: opts.postOrigin
          });
        },
        addMessageListener(listener) {
          const handler = (ev) => {
            listener(ev.data);
          };
          handlerMap.set(listener, handler);
          safeEventListener("add", "message", handler);
        },
        removeMessageListener(listener) {
          const handler = handlerMap.get(listener);
          if (handler) {
            safeEventListener("remove", "message", handler);
          }
        },
        addCloseListener(listener) {
          safeEventListener("add", "beforeunload", listener);
        },
        removeCloseListener(listener) {
          safeEventListener("remove", "beforeunload", listener);
        }
      });
    };
    window$1.windowLink = windowLink;
    return window$1;
  }
  var popup = {};
  var hasRequiredPopup;
  function requirePopup() {
    if (hasRequiredPopup) return popup;
    hasRequiredPopup = 1;
    Object.defineProperty(popup, "__esModule", { value: true });
    popup.popupLink = void 0;
    const constants_1 = requireConstants();
    const base_1 = requireBase();
    const popupLink = (opts) => {
      const messageHandlerMap = /* @__PURE__ */ new Map();
      const closeHandlerSet = /* @__PURE__ */ new Set();
      let popupWindow = null;
      async function getPopup(loadListenWindow) {
        if (!popupWindow || popupWindow.closed) {
          popupWindow = opts.createPopup();
          await Promise.race([
            // wait til window is loaded (same origin)
            new Promise((resolve) => {
              var _a;
              try {
                (_a = popupWindow === null || popupWindow === void 0 ? void 0 : popupWindow.addEventListener) === null || _a === void 0 ? void 0 : _a.call(popupWindow, "load", resolve);
              } catch (_b) {
              }
            }),
            // this is needed for cross-origin popups as they don't have a load event
            new Promise((resolve) => {
              loadListenWindow.addEventListener("message", (event) => {
                if (event.data === constants_1.TRPC_BROWSER_LOADED_EVENT) {
                  resolve();
                }
              });
            }),
            // expect the popup to load after 15s max, in case non of the above events fire
            new Promise((resolve) => {
              console.warn("Could not detect if popup loading succeeded after 15s timeout, continuing anyway");
              setTimeout(resolve, 15e3);
            })
          ]);
          try {
            if (!popupWindow.addEventListener) {
              throw new Error("popupWindow.addEventListener is not a function");
            }
            popupWindow.addEventListener("beforeunload", () => {
              popupWindow = null;
            });
          } catch (_a) {
            const pid = setInterval(() => {
              if (popupWindow && popupWindow.closed) {
                popupWindow = null;
                closeHandlerSet.forEach((handler) => {
                  handler();
                });
                clearInterval(pid);
              }
            }, 1e3);
          }
        }
        return popupWindow;
      }
      return (0, base_1.createBaseLink)({
        async postMessage(message) {
          const popup2 = await getPopup(opts.listenWindow);
          return popup2.postMessage(message, {
            targetOrigin: opts.postOrigin
          });
        },
        addMessageListener(listener) {
          const handler = (ev) => {
            listener(ev.data);
          };
          messageHandlerMap.set(listener, handler);
          opts.listenWindow.addEventListener("message", handler);
        },
        removeMessageListener(listener) {
          const handler = messageHandlerMap.get(listener);
          if (handler) {
            opts.listenWindow.removeEventListener("message", handler);
          }
        },
        addCloseListener(listener) {
          opts.listenWindow.addEventListener("beforeunload", listener);
          closeHandlerSet.add(listener);
        },
        removeCloseListener(listener) {
          opts.listenWindow.removeEventListener("beforeunload", listener);
          closeHandlerSet.delete(listener);
        }
      });
    };
    popup.popupLink = popupLink;
    return popup;
  }
  var hasRequiredLink;
  function requireLink() {
    if (hasRequiredLink) return link;
    hasRequiredLink = 1;
    (function(exports$1) {
      var __createBinding = link && link.__createBinding || (Object.create ? (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      }) : (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      }));
      var __exportStar = link && link.__exportStar || function(m, exports$12) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$12, p)) __createBinding(exports$12, m, p);
      };
      Object.defineProperty(exports$1, "__esModule", { value: true });
      __exportStar(requireChrome(), exports$1);
      __exportStar(requireWindow(), exports$1);
      __exportStar(requirePopup(), exports$1);
    })(link);
    return link;
  }
  var linkExports = requireLink();
  function identity(x) {
    return x;
  }
  function pipeFromArray(fns) {
    if (fns.length === 0) {
      return identity;
    }
    if (fns.length === 1) {
      return fns[0];
    }
    return function piped(input) {
      return fns.reduce((prev, fn) => fn(prev), input);
    };
  }
  function observable(subscribe) {
    const self2 = {
      subscribe(observer) {
        let teardownRef = null;
        let isDone = false;
        let unsubscribed = false;
        let teardownImmediately = false;
        function unsubscribe() {
          if (teardownRef === null) {
            teardownImmediately = true;
            return;
          }
          if (unsubscribed) {
            return;
          }
          unsubscribed = true;
          if (typeof teardownRef === "function") {
            teardownRef();
          } else if (teardownRef) {
            teardownRef.unsubscribe();
          }
        }
        teardownRef = subscribe({
          next(value) {
            if (isDone) {
              return;
            }
            observer.next?.(value);
          },
          error(err) {
            if (isDone) {
              return;
            }
            isDone = true;
            observer.error?.(err);
            unsubscribe();
          },
          complete() {
            if (isDone) {
              return;
            }
            isDone = true;
            observer.complete?.();
            unsubscribe();
          }
        });
        if (teardownImmediately) {
          unsubscribe();
        }
        return {
          unsubscribe
        };
      },
      pipe(...operations) {
        return pipeFromArray(operations)(self2);
      }
    };
    return self2;
  }
  function share(_opts) {
    return (originalObserver) => {
      let refCount = 0;
      let subscription = null;
      const observers = [];
      function startIfNeeded() {
        if (subscription) {
          return;
        }
        subscription = originalObserver.subscribe({
          next(value) {
            for (const observer of observers) {
              observer.next?.(value);
            }
          },
          error(error) {
            for (const observer of observers) {
              observer.error?.(error);
            }
          },
          complete() {
            for (const observer of observers) {
              observer.complete?.();
            }
          }
        });
      }
      function resetIfNeeded() {
        if (refCount === 0 && subscription) {
          const _sub = subscription;
          subscription = null;
          _sub.unsubscribe();
        }
      }
      return {
        subscribe(observer) {
          refCount++;
          observers.push(observer);
          startIfNeeded();
          return {
            unsubscribe() {
              refCount--;
              resetIfNeeded();
              const index = observers.findIndex((v) => v === observer);
              if (index > -1) {
                observers.splice(index, 1);
              }
            }
          };
        }
      };
    };
  }
  class ObservableAbortError extends Error {
    constructor(message) {
      super(message);
      this.name = "ObservableAbortError";
      Object.setPrototypeOf(this, ObservableAbortError.prototype);
    }
  }
  function observableToPromise(observable2) {
    let abort;
    const promise = new Promise((resolve, reject) => {
      let isDone = false;
      function onDone() {
        if (isDone) {
          return;
        }
        isDone = true;
        reject(new ObservableAbortError("This operation was aborted."));
        obs$.unsubscribe();
      }
      const obs$ = observable2.subscribe({
        next(data) {
          isDone = true;
          resolve(data);
          onDone();
        },
        error(data) {
          isDone = true;
          reject(data);
          onDone();
        },
        complete() {
          isDone = true;
          onDone();
        }
      });
      abort = onDone;
    });
    return {
      promise,
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      abort
    };
  }
  function createChain(opts) {
    return observable((observer) => {
      function execute(index = 0, op = opts.op) {
        const next = opts.links[index];
        if (!next) {
          throw new Error("No more links to execute - did you forget to add an ending link?");
        }
        const subscription = next({
          op,
          next(nextOp) {
            const nextObserver = execute(index + 1, nextOp);
            return nextObserver;
          }
        });
        return subscription;
      }
      const obs$ = execute();
      return obs$.subscribe(observer);
    });
  }
  function invert(obj) {
    const newObj = /* @__PURE__ */ Object.create(null);
    for (const key in obj) {
      const v = obj[key];
      newObj[v] = key;
    }
    return newObj;
  }
  const TRPC_ERROR_CODES_BY_KEY = {
    /**
    * Invalid JSON was received by the server.
    * An error occurred on the server while parsing the JSON text.
    */
    PARSE_ERROR: -32700,
    /**
    * The JSON sent is not a valid Request object.
    */
    BAD_REQUEST: -32600,
    // Internal JSON-RPC error
    INTERNAL_SERVER_ERROR: -32603,
    NOT_IMPLEMENTED: -32603,
    // Implementation specific errors
    UNAUTHORIZED: -32001,
    FORBIDDEN: -32003,
    NOT_FOUND: -32004,
    METHOD_NOT_SUPPORTED: -32005,
    TIMEOUT: -32008,
    CONFLICT: -32009,
    PRECONDITION_FAILED: -32012,
    PAYLOAD_TOO_LARGE: -32013,
    UNPROCESSABLE_CONTENT: -32022,
    TOO_MANY_REQUESTS: -32029,
    CLIENT_CLOSED_REQUEST: -32099
  };
  invert(TRPC_ERROR_CODES_BY_KEY);
  invert(TRPC_ERROR_CODES_BY_KEY);
  const JSONRPC2_TO_HTTP_CODE = {
    PARSE_ERROR: 400,
    BAD_REQUEST: 400,
    UNAUTHORIZED: 401,
    NOT_FOUND: 404,
    FORBIDDEN: 403,
    METHOD_NOT_SUPPORTED: 405,
    TIMEOUT: 408,
    CONFLICT: 409,
    PRECONDITION_FAILED: 412,
    PAYLOAD_TOO_LARGE: 413,
    UNPROCESSABLE_CONTENT: 422,
    TOO_MANY_REQUESTS: 429,
    CLIENT_CLOSED_REQUEST: 499,
    INTERNAL_SERVER_ERROR: 500,
    NOT_IMPLEMENTED: 501
  };
  function getStatusCodeFromKey(code) {
    return JSONRPC2_TO_HTTP_CODE[code] ?? 500;
  }
  function getHTTPStatusCodeFromError(error) {
    return getStatusCodeFromKey(error.code);
  }
  const noop = () => {
  };
  function createInnerProxy(callback, path) {
    const proxy = new Proxy(noop, {
      get(_obj, key) {
        if (typeof key !== "string" || key === "then") {
          return void 0;
        }
        return createInnerProxy(callback, [
          ...path,
          key
        ]);
      },
      apply(_1, _2, args) {
        const isApply = path[path.length - 1] === "apply";
        return callback({
          args: isApply ? args.length >= 2 ? args[1] : [] : args,
          path: isApply ? path.slice(0, -1) : path
        });
      }
    });
    return proxy;
  }
  const createRecursiveProxy = (callback) => createInnerProxy(callback, []);
  const createFlatProxy = (callback) => {
    return new Proxy(noop, {
      get(_obj, name) {
        if (typeof name !== "string" || name === "then") {
          return void 0;
        }
        return callback(name);
      }
    });
  };
  function isObject$1(value) {
    return !!value && !Array.isArray(value) && typeof value === "object";
  }
  class UnknownCauseError extends Error {
  }
  function getCauseFromUnknown(cause) {
    if (cause instanceof Error) {
      return cause;
    }
    const type = typeof cause;
    if (type === "undefined" || type === "function" || cause === null) {
      return void 0;
    }
    if (type !== "object") {
      return new Error(String(cause));
    }
    if (isObject$1(cause)) {
      const err = new UnknownCauseError();
      for (const key in cause) {
        err[key] = cause[key];
      }
      return err;
    }
    return void 0;
  }
  function isObject(value) {
    return !!value && !Array.isArray(value) && typeof value === "object";
  }
  function isTRPCClientError(cause) {
    return cause instanceof TRPCClientError || /**
    * @deprecated
    * Delete in next major
    */
    cause instanceof Error && cause.name === "TRPCClientError";
  }
  function isTRPCErrorResponse(obj) {
    return isObject(obj) && isObject(obj.error) && typeof obj.error.code === "number" && typeof obj.error.message === "string";
  }
  class TRPCClientError extends Error {
    static from(_cause, opts = {}) {
      const cause = _cause;
      if (isTRPCClientError(cause)) {
        if (opts.meta) {
          cause.meta = {
            ...cause.meta,
            ...opts.meta
          };
        }
        return cause;
      }
      if (isTRPCErrorResponse(cause)) {
        return new TRPCClientError(cause.error.message, {
          ...opts,
          result: cause
        });
      }
      if (!(cause instanceof Error)) {
        return new TRPCClientError("Unknown error", {
          ...opts,
          cause
        });
      }
      return new TRPCClientError(cause.message, {
        ...opts,
        cause: getCauseFromUnknown(cause)
      });
    }
    constructor(message, opts) {
      const cause = opts?.cause;
      super(message, {
        cause
      });
      this.meta = opts?.meta;
      this.cause = cause;
      this.shape = opts?.result?.error;
      this.data = opts?.result?.error.data;
      this.name = "TRPCClientError";
      Object.setPrototypeOf(this, TRPCClientError.prototype);
    }
  }
  class TRPCUntypedClient {
    $request({ type, input, path, context = {} }) {
      const chain$ = createChain({
        links: this.links,
        op: {
          id: ++this.requestId,
          type,
          path,
          input,
          context
        }
      });
      return chain$.pipe(share());
    }
    requestAsPromise(opts) {
      const req$ = this.$request(opts);
      const { promise, abort } = observableToPromise(req$);
      const abortablePromise = new Promise((resolve, reject) => {
        opts.signal?.addEventListener("abort", abort);
        promise.then((envelope) => {
          resolve(envelope.result.data);
        }).catch((err) => {
          reject(TRPCClientError.from(err));
        });
      });
      return abortablePromise;
    }
    query(path, input, opts) {
      return this.requestAsPromise({
        type: "query",
        path,
        input,
        context: opts?.context,
        signal: opts?.signal
      });
    }
    mutation(path, input, opts) {
      return this.requestAsPromise({
        type: "mutation",
        path,
        input,
        context: opts?.context,
        signal: opts?.signal
      });
    }
    subscription(path, input, opts) {
      const observable$ = this.$request({
        type: "subscription",
        path,
        input,
        context: opts?.context
      });
      return observable$.subscribe({
        next(envelope) {
          if (envelope.result.type === "started") {
            opts.onStarted?.();
          } else if (envelope.result.type === "stopped") {
            opts.onStopped?.();
          } else {
            opts.onData?.(envelope.result.data);
          }
        },
        error(err) {
          opts.onError?.(err);
        },
        complete() {
          opts.onComplete?.();
        }
      });
    }
    constructor(opts) {
      this.requestId = 0;
      const combinedTransformer = (() => {
        const transformer = opts.transformer;
        if (!transformer) {
          return {
            input: {
              serialize: (data) => data,
              deserialize: (data) => data
            },
            output: {
              serialize: (data) => data,
              deserialize: (data) => data
            }
          };
        }
        if ("input" in transformer) {
          return opts.transformer;
        }
        return {
          input: transformer,
          output: transformer
        };
      })();
      this.runtime = {
        transformer: {
          serialize: (data) => combinedTransformer.input.serialize(data),
          deserialize: (data) => combinedTransformer.output.deserialize(data)
        },
        combinedTransformer
      };
      this.links = opts.links.map((link2) => link2(this.runtime));
    }
  }
  const clientCallTypeMap = {
    query: "query",
    mutate: "mutation",
    subscribe: "subscription"
  };
  const clientCallTypeToProcedureType = (clientCallType) => {
    return clientCallTypeMap[clientCallType];
  };
  function createTRPCClientProxy(client) {
    return createFlatProxy((key) => {
      if (client.hasOwnProperty(key)) {
        return client[key];
      }
      if (key === "__untypedClient") {
        return client;
      }
      return createRecursiveProxy(({ path, args }) => {
        const pathCopy = [
          key,
          ...path
        ];
        const procedureType = clientCallTypeToProcedureType(pathCopy.pop());
        const fullPath = pathCopy.join(".");
        return client[procedureType](fullPath, ...args);
      });
    });
  }
  function createTRPCProxyClient(opts) {
    const client = new TRPCUntypedClient(opts);
    const proxy = createTRPCClientProxy(client);
    return proxy;
  }
  function getTRPCErrorFromUnknown(cause) {
    if (cause instanceof TRPCError) {
      return cause;
    }
    if (cause instanceof Error && cause.name === "TRPCError") {
      return cause;
    }
    const trpcError = new TRPCError({
      code: "INTERNAL_SERVER_ERROR",
      cause
    });
    if (cause instanceof Error && cause.stack) {
      trpcError.stack = cause.stack;
    }
    return trpcError;
  }
  class TRPCError extends Error {
    constructor(opts) {
      const cause = getCauseFromUnknown(opts.cause);
      const message = opts.message ?? cause?.message ?? opts.code;
      super(message, {
        cause
      });
      this.code = opts.code;
      this.name = "TRPCError";
      if (!this.cause) {
        this.cause = cause;
      }
    }
  }
  function getDataTransformer(transformer) {
    if ("input" in transformer) {
      return transformer;
    }
    return {
      input: transformer,
      output: transformer
    };
  }
  const defaultTransformer = {
    _default: true,
    input: {
      serialize: (obj) => obj,
      deserialize: (obj) => obj
    },
    output: {
      serialize: (obj) => obj,
      deserialize: (obj) => obj
    }
  };
  const defaultFormatter = ({ shape }) => {
    return shape;
  };
  function omitPrototype(obj) {
    return Object.assign(/* @__PURE__ */ Object.create(null), obj);
  }
  const procedureTypes = [
    "query",
    "mutation",
    "subscription"
  ];
  function isRouter(procedureOrRouter) {
    return "router" in procedureOrRouter._def;
  }
  const emptyRouter = {
    _ctx: null,
    _errorShape: null,
    _meta: null,
    queries: {},
    mutations: {},
    subscriptions: {},
    errorFormatter: defaultFormatter,
    transformer: defaultTransformer
  };
  const reservedWords = [
    /**
    * Then is a reserved word because otherwise we can't return a promise that returns a Proxy
    * since JS will think that `.then` is something that exists
    */
    "then"
  ];
  function createRouterFactory(config) {
    return function createRouterInner(procedures) {
      const reservedWordsUsed = new Set(Object.keys(procedures).filter((v) => reservedWords.includes(v)));
      if (reservedWordsUsed.size > 0) {
        throw new Error("Reserved words used in `router({})` call: " + Array.from(reservedWordsUsed).join(", "));
      }
      const routerProcedures = omitPrototype({});
      function recursiveGetPaths(procedures2, path = "") {
        for (const [key, procedureOrRouter] of Object.entries(procedures2 ?? {})) {
          const newPath = `${path}${key}`;
          if (isRouter(procedureOrRouter)) {
            recursiveGetPaths(procedureOrRouter._def.procedures, `${newPath}.`);
            continue;
          }
          if (routerProcedures[newPath]) {
            throw new Error(`Duplicate key: ${newPath}`);
          }
          routerProcedures[newPath] = procedureOrRouter;
        }
      }
      recursiveGetPaths(procedures);
      const _def = {
        _config: config,
        router: true,
        procedures: routerProcedures,
        ...emptyRouter,
        record: procedures,
        queries: Object.entries(routerProcedures).filter((pair) => pair[1]._def.query).reduce((acc, [key, val]) => ({
          ...acc,
          [key]: val
        }), {}),
        mutations: Object.entries(routerProcedures).filter((pair) => pair[1]._def.mutation).reduce((acc, [key, val]) => ({
          ...acc,
          [key]: val
        }), {}),
        subscriptions: Object.entries(routerProcedures).filter((pair) => pair[1]._def.subscription).reduce((acc, [key, val]) => ({
          ...acc,
          [key]: val
        }), {})
      };
      const router2 = {
        ...procedures,
        _def,
        createCaller(ctx) {
          return createCallerFactory()(router2)(ctx);
        },
        getErrorShape(opts) {
          const { path, error } = opts;
          const { code } = opts.error;
          const shape = {
            message: error.message,
            code: TRPC_ERROR_CODES_BY_KEY[code],
            data: {
              code,
              httpStatus: getHTTPStatusCodeFromError(error)
            }
          };
          if (config.isDev && typeof opts.error.stack === "string") {
            shape.data.stack = opts.error.stack;
          }
          if (typeof path === "string") {
            shape.data.path = path;
          }
          return this._def._config.errorFormatter({
            ...opts,
            shape
          });
        }
      };
      return router2;
    };
  }
  function callProcedure(opts) {
    const { type, path } = opts;
    if (!(path in opts.procedures) || !opts.procedures[path]?._def[type]) {
      throw new TRPCError({
        code: "NOT_FOUND",
        message: `No "${type}"-procedure on path "${path}"`
      });
    }
    const procedure = opts.procedures[path];
    return procedure(opts);
  }
  function createCallerFactory() {
    return function createCallerInner(router2) {
      const def = router2._def;
      return function createCaller(ctx) {
        const proxy = createRecursiveProxy(({ path, args }) => {
          if (path.length === 1 && procedureTypes.includes(path[0])) {
            return callProcedure({
              procedures: def.procedures,
              path: args[0],
              rawInput: args[1],
              ctx,
              type: path[0]
            });
          }
          const fullPath = path.join(".");
          const procedure = def.procedures[fullPath];
          let type = "query";
          if (procedure._def.mutation) {
            type = "mutation";
          } else if (procedure._def.subscription) {
            type = "subscription";
          }
          return procedure({
            path: fullPath,
            rawInput: args[0],
            ctx,
            type
          });
        });
        return proxy;
      };
    };
  }
  const isServerDefault = typeof window === "undefined" || "Deno" in window || globalThis.process?.env?.NODE_ENV === "test" || !!globalThis.process?.env?.JEST_WORKER_ID || !!globalThis.process?.env?.VITEST_WORKER_ID;
  function getParseFn(procedureParser) {
    const parser = procedureParser;
    if (typeof parser === "function") {
      return parser;
    }
    if (typeof parser.parseAsync === "function") {
      return parser.parseAsync.bind(parser);
    }
    if (typeof parser.parse === "function") {
      return parser.parse.bind(parser);
    }
    if (typeof parser.validateSync === "function") {
      return parser.validateSync.bind(parser);
    }
    if (typeof parser.create === "function") {
      return parser.create.bind(parser);
    }
    if (typeof parser.assert === "function") {
      return (value) => {
        parser.assert(value);
        return value;
      };
    }
    throw new Error("Could not find a validator fn");
  }
  function mergeWithoutOverrides(obj1, ...objs) {
    const newObj = Object.assign(/* @__PURE__ */ Object.create(null), obj1);
    for (const overrides of objs) {
      for (const key in overrides) {
        if (key in newObj && newObj[key] !== overrides[key]) {
          throw new Error(`Duplicate key ${key}`);
        }
        newObj[key] = overrides[key];
      }
    }
    return newObj;
  }
  function createMiddlewareFactory() {
    function createMiddlewareInner(middlewares) {
      return {
        _middlewares: middlewares,
        unstable_pipe(middlewareBuilderOrFn) {
          const pipedMiddleware = "_middlewares" in middlewareBuilderOrFn ? middlewareBuilderOrFn._middlewares : [
            middlewareBuilderOrFn
          ];
          return createMiddlewareInner([
            ...middlewares,
            ...pipedMiddleware
          ]);
        }
      };
    }
    function createMiddleware(fn) {
      return createMiddlewareInner([
        fn
      ]);
    }
    return createMiddleware;
  }
  function isPlainObject(obj) {
    return obj && typeof obj === "object" && !Array.isArray(obj);
  }
  function createInputMiddleware(parse) {
    const inputMiddleware = async ({ next, rawInput, input }) => {
      let parsedInput;
      try {
        parsedInput = await parse(rawInput);
      } catch (cause) {
        throw new TRPCError({
          code: "BAD_REQUEST",
          cause
        });
      }
      const combinedInput = isPlainObject(input) && isPlainObject(parsedInput) ? {
        ...input,
        ...parsedInput
      } : parsedInput;
      return next({
        input: combinedInput
      });
    };
    inputMiddleware._type = "input";
    return inputMiddleware;
  }
  function createOutputMiddleware(parse) {
    const outputMiddleware = async ({ next }) => {
      const result2 = await next();
      if (!result2.ok) {
        return result2;
      }
      try {
        const data = await parse(result2.data);
        return {
          ...result2,
          data
        };
      } catch (cause) {
        throw new TRPCError({
          message: "Output validation failed",
          code: "INTERNAL_SERVER_ERROR",
          cause
        });
      }
    };
    outputMiddleware._type = "output";
    return outputMiddleware;
  }
  const middlewareMarker = "middlewareMarker";
  function createNewBuilder(def1, def2) {
    const { middlewares = [], inputs, meta, ...rest } = def2;
    return createBuilder({
      ...mergeWithoutOverrides(def1, rest),
      inputs: [
        ...def1.inputs,
        ...inputs ?? []
      ],
      middlewares: [
        ...def1.middlewares,
        ...middlewares
      ],
      meta: def1.meta && meta ? {
        ...def1.meta,
        ...meta
      } : meta ?? def1.meta
    });
  }
  function createBuilder(initDef = {}) {
    const _def = {
      inputs: [],
      middlewares: [],
      ...initDef
    };
    return {
      _def,
      input(input) {
        const parser = getParseFn(input);
        return createNewBuilder(_def, {
          inputs: [
            input
          ],
          middlewares: [
            createInputMiddleware(parser)
          ]
        });
      },
      output(output) {
        const parseOutput = getParseFn(output);
        return createNewBuilder(_def, {
          output,
          middlewares: [
            createOutputMiddleware(parseOutput)
          ]
        });
      },
      meta(meta) {
        return createNewBuilder(_def, {
          meta
        });
      },
      /**
      * @deprecated
      * This functionality is deprecated and will be removed in the next major version.
      */
      unstable_concat(builder) {
        return createNewBuilder(_def, builder._def);
      },
      use(middlewareBuilderOrFn) {
        const middlewares = "_middlewares" in middlewareBuilderOrFn ? middlewareBuilderOrFn._middlewares : [
          middlewareBuilderOrFn
        ];
        return createNewBuilder(_def, {
          middlewares
        });
      },
      query(resolver) {
        return createResolver({
          ..._def,
          query: true
        }, resolver);
      },
      mutation(resolver) {
        return createResolver({
          ..._def,
          mutation: true
        }, resolver);
      },
      subscription(resolver) {
        return createResolver({
          ..._def,
          subscription: true
        }, resolver);
      }
    };
  }
  function createResolver(_def, resolver) {
    const finalBuilder = createNewBuilder(_def, {
      resolver,
      middlewares: [
        async function resolveMiddleware(opts) {
          const data = await resolver(opts);
          return {
            marker: middlewareMarker,
            ok: true,
            data,
            ctx: opts.ctx
          };
        }
      ]
    });
    return createProcedureCaller(finalBuilder._def);
  }
  const codeblock = `
This is a client-only function.
If you want to call this function on the server, see https://trpc.io/docs/server/server-side-calls
`.trim();
  function createProcedureCaller(_def) {
    const procedure = async function resolve(opts) {
      if (!opts || !("rawInput" in opts)) {
        throw new Error(codeblock);
      }
      const callRecursive = async (callOpts = {
        index: 0,
        ctx: opts.ctx
      }) => {
        try {
          const middleware = _def.middlewares[callOpts.index];
          const result22 = await middleware({
            ctx: callOpts.ctx,
            type: opts.type,
            path: opts.path,
            rawInput: callOpts.rawInput ?? opts.rawInput,
            meta: _def.meta,
            input: callOpts.input,
            next(_nextOpts) {
              const nextOpts = _nextOpts;
              return callRecursive({
                index: callOpts.index + 1,
                ctx: nextOpts && "ctx" in nextOpts ? {
                  ...callOpts.ctx,
                  ...nextOpts.ctx
                } : callOpts.ctx,
                input: nextOpts && "input" in nextOpts ? nextOpts.input : callOpts.input,
                rawInput: nextOpts && "rawInput" in nextOpts ? nextOpts.rawInput : callOpts.rawInput
              });
            }
          });
          return result22;
        } catch (cause) {
          return {
            ok: false,
            error: getTRPCErrorFromUnknown(cause),
            marker: middlewareMarker
          };
        }
      };
      const result2 = await callRecursive();
      if (!result2) {
        throw new TRPCError({
          code: "INTERNAL_SERVER_ERROR",
          message: "No result from middlewares - did you forget to `return next()`?"
        });
      }
      if (!result2.ok) {
        throw result2.error;
      }
      return result2.data;
    };
    procedure._def = _def;
    procedure.meta = _def.meta;
    return procedure;
  }
  function mergeRouters(...routerList) {
    const record = mergeWithoutOverrides({}, ...routerList.map((r) => r._def.record));
    const errorFormatter = routerList.reduce((currentErrorFormatter, nextRouter) => {
      if (nextRouter._def._config.errorFormatter && nextRouter._def._config.errorFormatter !== defaultFormatter) {
        if (currentErrorFormatter !== defaultFormatter && currentErrorFormatter !== nextRouter._def._config.errorFormatter) {
          throw new Error("You seem to have several error formatters");
        }
        return nextRouter._def._config.errorFormatter;
      }
      return currentErrorFormatter;
    }, defaultFormatter);
    const transformer = routerList.reduce((prev, current) => {
      if (current._def._config.transformer && current._def._config.transformer !== defaultTransformer) {
        if (prev !== defaultTransformer && prev !== current._def._config.transformer) {
          throw new Error("You seem to have several transformers");
        }
        return current._def._config.transformer;
      }
      return prev;
    }, defaultTransformer);
    const router2 = createRouterFactory({
      errorFormatter,
      transformer,
      isDev: routerList.some((r) => r._def._config.isDev),
      allowOutsideOfServer: routerList.some((r) => r._def._config.allowOutsideOfServer),
      isServer: routerList.some((r) => r._def._config.isServer),
      $types: routerList[0]?._def._config.$types
    })(record);
    return router2;
  }
  class TRPCBuilder {
    context() {
      return new TRPCBuilder();
    }
    meta() {
      return new TRPCBuilder();
    }
    create(options) {
      return createTRPCInner()(options);
    }
  }
  const initTRPC = new TRPCBuilder();
  function createTRPCInner() {
    return function initTRPCInner(runtime) {
      const errorFormatter = runtime?.errorFormatter ?? defaultFormatter;
      const transformer = getDataTransformer(runtime?.transformer ?? defaultTransformer);
      const config = {
        transformer,
        isDev: runtime?.isDev ?? globalThis.process?.env?.NODE_ENV !== "production",
        allowOutsideOfServer: runtime?.allowOutsideOfServer ?? false,
        errorFormatter,
        isServer: runtime?.isServer ?? isServerDefault,
        /**
        * @internal
        */
        $types: createFlatProxy((key) => {
          throw new Error(`Tried to access "$types.${key}" which is not available at runtime`);
        })
      };
      {
        const isServer = runtime?.isServer ?? isServerDefault;
        if (!isServer && runtime?.allowOutsideOfServer !== true) {
          throw new Error(`You're trying to use @trpc/server in a non-server environment. This is not supported by default.`);
        }
      }
      return {
        /**
        * These are just types, they can't be used
        * @internal
        */
        _config: config,
        /**
        * Builder object for creating procedures
        * @see https://trpc.io/docs/server/procedures
        */
        procedure: createBuilder({
          meta: runtime?.defaultMeta
        }),
        /**
        * Create reusable middlewares
        * @see https://trpc.io/docs/server/middlewares
        */
        middleware: createMiddlewareFactory(),
        /**
        * Create a router
        * @see https://trpc.io/docs/server/routers
        */
        router: createRouterFactory(config),
        /**
        * Merge Routers
        * @see https://trpc.io/docs/server/merging-routers
        */
        mergeRouters,
        /**
        * Create a server-side caller for a router
        * @see https://trpc.io/docs/server/server-side-calls
        */
        createCallerFactory: createCallerFactory()
      };
    };
  }
  var util;
  (function(util2) {
    util2.assertEqual = (_) => {
    };
    function assertIs(_arg) {
    }
    util2.assertIs = assertIs;
    function assertNever(_x) {
      throw new Error();
    }
    util2.assertNever = assertNever;
    util2.arrayToEnum = (items) => {
      const obj = {};
      for (const item of items) {
        obj[item] = item;
      }
      return obj;
    };
    util2.getValidEnumValues = (obj) => {
      const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
      const filtered = {};
      for (const k of validKeys) {
        filtered[k] = obj[k];
      }
      return util2.objectValues(filtered);
    };
    util2.objectValues = (obj) => {
      return util2.objectKeys(obj).map(function(e) {
        return obj[e];
      });
    };
    util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
      const keys = [];
      for (const key in object) {
        if (Object.prototype.hasOwnProperty.call(object, key)) {
          keys.push(key);
        }
      }
      return keys;
    };
    util2.find = (arr, checker) => {
      for (const item of arr) {
        if (checker(item))
          return item;
      }
      return void 0;
    };
    util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && Number.isFinite(val) && Math.floor(val) === val;
    function joinValues(array, separator = " | ") {
      return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
    }
    util2.joinValues = joinValues;
    util2.jsonStringifyReplacer = (_, value) => {
      if (typeof value === "bigint") {
        return value.toString();
      }
      return value;
    };
  })(util || (util = {}));
  var objectUtil;
  (function(objectUtil2) {
    objectUtil2.mergeShapes = (first, second) => {
      return {
        ...first,
        ...second
        // second overwrites first
      };
    };
  })(objectUtil || (objectUtil = {}));
  const ZodParsedType = util.arrayToEnum([
    "string",
    "nan",
    "number",
    "integer",
    "float",
    "boolean",
    "date",
    "bigint",
    "symbol",
    "function",
    "undefined",
    "null",
    "array",
    "object",
    "unknown",
    "promise",
    "void",
    "never",
    "map",
    "set"
  ]);
  const getParsedType = (data) => {
    const t2 = typeof data;
    switch (t2) {
      case "undefined":
        return ZodParsedType.undefined;
      case "string":
        return ZodParsedType.string;
      case "number":
        return Number.isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
      case "boolean":
        return ZodParsedType.boolean;
      case "function":
        return ZodParsedType.function;
      case "bigint":
        return ZodParsedType.bigint;
      case "symbol":
        return ZodParsedType.symbol;
      case "object":
        if (Array.isArray(data)) {
          return ZodParsedType.array;
        }
        if (data === null) {
          return ZodParsedType.null;
        }
        if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
          return ZodParsedType.promise;
        }
        if (typeof Map !== "undefined" && data instanceof Map) {
          return ZodParsedType.map;
        }
        if (typeof Set !== "undefined" && data instanceof Set) {
          return ZodParsedType.set;
        }
        if (typeof Date !== "undefined" && data instanceof Date) {
          return ZodParsedType.date;
        }
        return ZodParsedType.object;
      default:
        return ZodParsedType.unknown;
    }
  };
  const ZodIssueCode = util.arrayToEnum([
    "invalid_type",
    "invalid_literal",
    "custom",
    "invalid_union",
    "invalid_union_discriminator",
    "invalid_enum_value",
    "unrecognized_keys",
    "invalid_arguments",
    "invalid_return_type",
    "invalid_date",
    "invalid_string",
    "too_small",
    "too_big",
    "invalid_intersection_types",
    "not_multiple_of",
    "not_finite"
  ]);
  class ZodError extends Error {
    get errors() {
      return this.issues;
    }
    constructor(issues) {
      super();
      this.issues = [];
      this.addIssue = (sub) => {
        this.issues = [...this.issues, sub];
      };
      this.addIssues = (subs = []) => {
        this.issues = [...this.issues, ...subs];
      };
      const actualProto = new.target.prototype;
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(this, actualProto);
      } else {
        this.__proto__ = actualProto;
      }
      this.name = "ZodError";
      this.issues = issues;
    }
    format(_mapper) {
      const mapper = _mapper || function(issue) {
        return issue.message;
      };
      const fieldErrors = { _errors: [] };
      const processError = (error) => {
        for (const issue of error.issues) {
          if (issue.code === "invalid_union") {
            issue.unionErrors.map(processError);
          } else if (issue.code === "invalid_return_type") {
            processError(issue.returnTypeError);
          } else if (issue.code === "invalid_arguments") {
            processError(issue.argumentsError);
          } else if (issue.path.length === 0) {
            fieldErrors._errors.push(mapper(issue));
          } else {
            let curr = fieldErrors;
            let i = 0;
            while (i < issue.path.length) {
              const el = issue.path[i];
              const terminal = i === issue.path.length - 1;
              if (!terminal) {
                curr[el] = curr[el] || { _errors: [] };
              } else {
                curr[el] = curr[el] || { _errors: [] };
                curr[el]._errors.push(mapper(issue));
              }
              curr = curr[el];
              i++;
            }
          }
        }
      };
      processError(this);
      return fieldErrors;
    }
    static assert(value) {
      if (!(value instanceof ZodError)) {
        throw new Error(`Not a ZodError: ${value}`);
      }
    }
    toString() {
      return this.message;
    }
    get message() {
      return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
    }
    get isEmpty() {
      return this.issues.length === 0;
    }
    flatten(mapper = (issue) => issue.message) {
      const fieldErrors = {};
      const formErrors = [];
      for (const sub of this.issues) {
        if (sub.path.length > 0) {
          const firstEl = sub.path[0];
          fieldErrors[firstEl] = fieldErrors[firstEl] || [];
          fieldErrors[firstEl].push(mapper(sub));
        } else {
          formErrors.push(mapper(sub));
        }
      }
      return { formErrors, fieldErrors };
    }
    get formErrors() {
      return this.flatten();
    }
  }
  ZodError.create = (issues) => {
    const error = new ZodError(issues);
    return error;
  };
  const errorMap = (issue, _ctx) => {
    let message;
    switch (issue.code) {
      case ZodIssueCode.invalid_type:
        if (issue.received === ZodParsedType.undefined) {
          message = "Required";
        } else {
          message = `Expected ${issue.expected}, received ${issue.received}`;
        }
        break;
      case ZodIssueCode.invalid_literal:
        message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
        break;
      case ZodIssueCode.unrecognized_keys:
        message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
        break;
      case ZodIssueCode.invalid_union:
        message = `Invalid input`;
        break;
      case ZodIssueCode.invalid_union_discriminator:
        message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
        break;
      case ZodIssueCode.invalid_enum_value:
        message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
        break;
      case ZodIssueCode.invalid_arguments:
        message = `Invalid function arguments`;
        break;
      case ZodIssueCode.invalid_return_type:
        message = `Invalid function return type`;
        break;
      case ZodIssueCode.invalid_date:
        message = `Invalid date`;
        break;
      case ZodIssueCode.invalid_string:
        if (typeof issue.validation === "object") {
          if ("includes" in issue.validation) {
            message = `Invalid input: must include "${issue.validation.includes}"`;
            if (typeof issue.validation.position === "number") {
              message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
            }
          } else if ("startsWith" in issue.validation) {
            message = `Invalid input: must start with "${issue.validation.startsWith}"`;
          } else if ("endsWith" in issue.validation) {
            message = `Invalid input: must end with "${issue.validation.endsWith}"`;
          } else {
            util.assertNever(issue.validation);
          }
        } else if (issue.validation !== "regex") {
          message = `Invalid ${issue.validation}`;
        } else {
          message = "Invalid";
        }
        break;
      case ZodIssueCode.too_small:
        if (issue.type === "array")
          message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
        else if (issue.type === "string")
          message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
        else if (issue.type === "number")
          message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
        else if (issue.type === "bigint")
          message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
        else if (issue.type === "date")
          message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
        else
          message = "Invalid input";
        break;
      case ZodIssueCode.too_big:
        if (issue.type === "array")
          message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
        else if (issue.type === "string")
          message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
        else if (issue.type === "number")
          message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
        else if (issue.type === "bigint")
          message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
        else if (issue.type === "date")
          message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
        else
          message = "Invalid input";
        break;
      case ZodIssueCode.custom:
        message = `Invalid input`;
        break;
      case ZodIssueCode.invalid_intersection_types:
        message = `Intersection results could not be merged`;
        break;
      case ZodIssueCode.not_multiple_of:
        message = `Number must be a multiple of ${issue.multipleOf}`;
        break;
      case ZodIssueCode.not_finite:
        message = "Number must be finite";
        break;
      default:
        message = _ctx.defaultError;
        util.assertNever(issue);
    }
    return { message };
  };
  let overrideErrorMap = errorMap;
  function getErrorMap() {
    return overrideErrorMap;
  }
  const makeIssue = (params) => {
    const { data, path, errorMaps, issueData } = params;
    const fullPath = [...path, ...issueData.path || []];
    const fullIssue = {
      ...issueData,
      path: fullPath
    };
    if (issueData.message !== void 0) {
      return {
        ...issueData,
        path: fullPath,
        message: issueData.message
      };
    }
    let errorMessage = "";
    const maps = errorMaps.filter((m) => !!m).slice().reverse();
    for (const map of maps) {
      errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
    }
    return {
      ...issueData,
      path: fullPath,
      message: errorMessage
    };
  };
  function addIssueToContext(ctx, issueData) {
    const overrideMap = getErrorMap();
    const issue = makeIssue({
      issueData,
      data: ctx.data,
      path: ctx.path,
      errorMaps: [
        ctx.common.contextualErrorMap,
        // contextual error map is first priority
        ctx.schemaErrorMap,
        // then schema-bound map if available
        overrideMap,
        // then global override map
        overrideMap === errorMap ? void 0 : errorMap
        // then global default map
      ].filter((x) => !!x)
    });
    ctx.common.issues.push(issue);
  }
  class ParseStatus {
    constructor() {
      this.value = "valid";
    }
    dirty() {
      if (this.value === "valid")
        this.value = "dirty";
    }
    abort() {
      if (this.value !== "aborted")
        this.value = "aborted";
    }
    static mergeArray(status, results) {
      const arrayValue = [];
      for (const s of results) {
        if (s.status === "aborted")
          return INVALID;
        if (s.status === "dirty")
          status.dirty();
        arrayValue.push(s.value);
      }
      return { status: status.value, value: arrayValue };
    }
    static async mergeObjectAsync(status, pairs) {
      const syncPairs = [];
      for (const pair of pairs) {
        const key = await pair.key;
        const value = await pair.value;
        syncPairs.push({
          key,
          value
        });
      }
      return ParseStatus.mergeObjectSync(status, syncPairs);
    }
    static mergeObjectSync(status, pairs) {
      const finalObject = {};
      for (const pair of pairs) {
        const { key, value } = pair;
        if (key.status === "aborted")
          return INVALID;
        if (value.status === "aborted")
          return INVALID;
        if (key.status === "dirty")
          status.dirty();
        if (value.status === "dirty")
          status.dirty();
        if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
          finalObject[key.value] = value.value;
        }
      }
      return { status: status.value, value: finalObject };
    }
  }
  const INVALID = Object.freeze({
    status: "aborted"
  });
  const DIRTY = (value) => ({ status: "dirty", value });
  const OK = (value) => ({ status: "valid", value });
  const isAborted = (x) => x.status === "aborted";
  const isDirty = (x) => x.status === "dirty";
  const isValid = (x) => x.status === "valid";
  const isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;
  var errorUtil;
  (function(errorUtil2) {
    errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
    errorUtil2.toString = (message) => typeof message === "string" ? message : message?.message;
  })(errorUtil || (errorUtil = {}));
  class ParseInputLazyPath {
    constructor(parent, value, path, key) {
      this._cachedPath = [];
      this.parent = parent;
      this.data = value;
      this._path = path;
      this._key = key;
    }
    get path() {
      if (!this._cachedPath.length) {
        if (Array.isArray(this._key)) {
          this._cachedPath.push(...this._path, ...this._key);
        } else {
          this._cachedPath.push(...this._path, this._key);
        }
      }
      return this._cachedPath;
    }
  }
  const handleResult = (ctx, result2) => {
    if (isValid(result2)) {
      return { success: true, data: result2.value };
    } else {
      if (!ctx.common.issues.length) {
        throw new Error("Validation failed but no issues detected.");
      }
      return {
        success: false,
        get error() {
          if (this._error)
            return this._error;
          const error = new ZodError(ctx.common.issues);
          this._error = error;
          return this._error;
        }
      };
    }
  };
  function processCreateParams(params) {
    if (!params)
      return {};
    const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
    if (errorMap2 && (invalid_type_error || required_error)) {
      throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
    }
    if (errorMap2)
      return { errorMap: errorMap2, description };
    const customMap = (iss, ctx) => {
      const { message } = params;
      if (iss.code === "invalid_enum_value") {
        return { message: message ?? ctx.defaultError };
      }
      if (typeof ctx.data === "undefined") {
        return { message: message ?? required_error ?? ctx.defaultError };
      }
      if (iss.code !== "invalid_type")
        return { message: ctx.defaultError };
      return { message: message ?? invalid_type_error ?? ctx.defaultError };
    };
    return { errorMap: customMap, description };
  }
  class ZodType {
    get description() {
      return this._def.description;
    }
    _getType(input) {
      return getParsedType(input.data);
    }
    _getOrReturnCtx(input, ctx) {
      return ctx || {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      };
    }
    _processInputParams(input) {
      return {
        status: new ParseStatus(),
        ctx: {
          common: input.parent.common,
          data: input.data,
          parsedType: getParsedType(input.data),
          schemaErrorMap: this._def.errorMap,
          path: input.path,
          parent: input.parent
        }
      };
    }
    _parseSync(input) {
      const result2 = this._parse(input);
      if (isAsync(result2)) {
        throw new Error("Synchronous parse encountered promise.");
      }
      return result2;
    }
    _parseAsync(input) {
      const result2 = this._parse(input);
      return Promise.resolve(result2);
    }
    parse(data, params) {
      const result2 = this.safeParse(data, params);
      if (result2.success)
        return result2.data;
      throw result2.error;
    }
    safeParse(data, params) {
      const ctx = {
        common: {
          issues: [],
          async: params?.async ?? false,
          contextualErrorMap: params?.errorMap
        },
        path: params?.path || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data,
        parsedType: getParsedType(data)
      };
      const result2 = this._parseSync({ data, path: ctx.path, parent: ctx });
      return handleResult(ctx, result2);
    }
    "~validate"(data) {
      const ctx = {
        common: {
          issues: [],
          async: !!this["~standard"].async
        },
        path: [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data,
        parsedType: getParsedType(data)
      };
      if (!this["~standard"].async) {
        try {
          const result2 = this._parseSync({ data, path: [], parent: ctx });
          return isValid(result2) ? {
            value: result2.value
          } : {
            issues: ctx.common.issues
          };
        } catch (err) {
          if (err?.message?.toLowerCase()?.includes("encountered")) {
            this["~standard"].async = true;
          }
          ctx.common = {
            issues: [],
            async: true
          };
        }
      }
      return this._parseAsync({ data, path: [], parent: ctx }).then((result2) => isValid(result2) ? {
        value: result2.value
      } : {
        issues: ctx.common.issues
      });
    }
    async parseAsync(data, params) {
      const result2 = await this.safeParseAsync(data, params);
      if (result2.success)
        return result2.data;
      throw result2.error;
    }
    async safeParseAsync(data, params) {
      const ctx = {
        common: {
          issues: [],
          contextualErrorMap: params?.errorMap,
          async: true
        },
        path: params?.path || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data,
        parsedType: getParsedType(data)
      };
      const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
      const result2 = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
      return handleResult(ctx, result2);
    }
    refine(check, message) {
      const getIssueProperties = (val) => {
        if (typeof message === "string" || typeof message === "undefined") {
          return { message };
        } else if (typeof message === "function") {
          return message(val);
        } else {
          return message;
        }
      };
      return this._refinement((val, ctx) => {
        const result2 = check(val);
        const setError = () => ctx.addIssue({
          code: ZodIssueCode.custom,
          ...getIssueProperties(val)
        });
        if (typeof Promise !== "undefined" && result2 instanceof Promise) {
          return result2.then((data) => {
            if (!data) {
              setError();
              return false;
            } else {
              return true;
            }
          });
        }
        if (!result2) {
          setError();
          return false;
        } else {
          return true;
        }
      });
    }
    refinement(check, refinementData) {
      return this._refinement((val, ctx) => {
        if (!check(val)) {
          ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
          return false;
        } else {
          return true;
        }
      });
    }
    _refinement(refinement) {
      return new ZodEffects({
        schema: this,
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        effect: { type: "refinement", refinement }
      });
    }
    superRefine(refinement) {
      return this._refinement(refinement);
    }
    constructor(def) {
      this.spa = this.safeParseAsync;
      this._def = def;
      this.parse = this.parse.bind(this);
      this.safeParse = this.safeParse.bind(this);
      this.parseAsync = this.parseAsync.bind(this);
      this.safeParseAsync = this.safeParseAsync.bind(this);
      this.spa = this.spa.bind(this);
      this.refine = this.refine.bind(this);
      this.refinement = this.refinement.bind(this);
      this.superRefine = this.superRefine.bind(this);
      this.optional = this.optional.bind(this);
      this.nullable = this.nullable.bind(this);
      this.nullish = this.nullish.bind(this);
      this.array = this.array.bind(this);
      this.promise = this.promise.bind(this);
      this.or = this.or.bind(this);
      this.and = this.and.bind(this);
      this.transform = this.transform.bind(this);
      this.brand = this.brand.bind(this);
      this.default = this.default.bind(this);
      this.catch = this.catch.bind(this);
      this.describe = this.describe.bind(this);
      this.pipe = this.pipe.bind(this);
      this.readonly = this.readonly.bind(this);
      this.isNullable = this.isNullable.bind(this);
      this.isOptional = this.isOptional.bind(this);
      this["~standard"] = {
        version: 1,
        vendor: "zod",
        validate: (data) => this["~validate"](data)
      };
    }
    optional() {
      return ZodOptional.create(this, this._def);
    }
    nullable() {
      return ZodNullable.create(this, this._def);
    }
    nullish() {
      return this.nullable().optional();
    }
    array() {
      return ZodArray.create(this);
    }
    promise() {
      return ZodPromise.create(this, this._def);
    }
    or(option) {
      return ZodUnion.create([this, option], this._def);
    }
    and(incoming) {
      return ZodIntersection.create(this, incoming, this._def);
    }
    transform(transform) {
      return new ZodEffects({
        ...processCreateParams(this._def),
        schema: this,
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        effect: { type: "transform", transform }
      });
    }
    default(def) {
      const defaultValueFunc = typeof def === "function" ? def : () => def;
      return new ZodDefault({
        ...processCreateParams(this._def),
        innerType: this,
        defaultValue: defaultValueFunc,
        typeName: ZodFirstPartyTypeKind.ZodDefault
      });
    }
    brand() {
      return new ZodBranded({
        typeName: ZodFirstPartyTypeKind.ZodBranded,
        type: this,
        ...processCreateParams(this._def)
      });
    }
    catch(def) {
      const catchValueFunc = typeof def === "function" ? def : () => def;
      return new ZodCatch({
        ...processCreateParams(this._def),
        innerType: this,
        catchValue: catchValueFunc,
        typeName: ZodFirstPartyTypeKind.ZodCatch
      });
    }
    describe(description) {
      const This = this.constructor;
      return new This({
        ...this._def,
        description
      });
    }
    pipe(target) {
      return ZodPipeline.create(this, target);
    }
    readonly() {
      return ZodReadonly.create(this);
    }
    isOptional() {
      return this.safeParse(void 0).success;
    }
    isNullable() {
      return this.safeParse(null).success;
    }
  }
  const cuidRegex = /^c[^\s-]{8,}$/i;
  const cuid2Regex = /^[0-9a-z]+$/;
  const ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
  const uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
  const nanoidRegex = /^[a-z0-9_-]{21}$/i;
  const jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
  const durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
  const emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
  const _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
  let emojiRegex;
  const ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
  const ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
  const ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
  const ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
  const base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
  const base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
  const dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
  const dateRegex = new RegExp(`^${dateRegexSource}$`);
  function timeRegexSource(args) {
    let secondsRegexSource = `[0-5]\\d`;
    if (args.precision) {
      secondsRegexSource = `${secondsRegexSource}\\.\\d{${args.precision}}`;
    } else if (args.precision == null) {
      secondsRegexSource = `${secondsRegexSource}(\\.\\d+)?`;
    }
    const secondsQuantifier = args.precision ? "+" : "?";
    return `([01]\\d|2[0-3]):[0-5]\\d(:${secondsRegexSource})${secondsQuantifier}`;
  }
  function timeRegex(args) {
    return new RegExp(`^${timeRegexSource(args)}$`);
  }
  function datetimeRegex(args) {
    let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
    const opts = [];
    opts.push(args.local ? `Z?` : `Z`);
    if (args.offset)
      opts.push(`([+-]\\d{2}:?\\d{2})`);
    regex = `${regex}(${opts.join("|")})`;
    return new RegExp(`^${regex}$`);
  }
  function isValidIP(ip, version) {
    if ((version === "v4" || !version) && ipv4Regex.test(ip)) {
      return true;
    }
    if ((version === "v6" || !version) && ipv6Regex.test(ip)) {
      return true;
    }
    return false;
  }
  function isValidJWT(jwt, alg) {
    if (!jwtRegex.test(jwt))
      return false;
    try {
      const [header] = jwt.split(".");
      if (!header)
        return false;
      const base64 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
      const decoded = JSON.parse(atob(base64));
      if (typeof decoded !== "object" || decoded === null)
        return false;
      if ("typ" in decoded && decoded?.typ !== "JWT")
        return false;
      if (!decoded.alg)
        return false;
      if (alg && decoded.alg !== alg)
        return false;
      return true;
    } catch {
      return false;
    }
  }
  function isValidCidr(ip, version) {
    if ((version === "v4" || !version) && ipv4CidrRegex.test(ip)) {
      return true;
    }
    if ((version === "v6" || !version) && ipv6CidrRegex.test(ip)) {
      return true;
    }
    return false;
  }
  class ZodString extends ZodType {
    _parse(input) {
      if (this._def.coerce) {
        input.data = String(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.string) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.string,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      const status = new ParseStatus();
      let ctx = void 0;
      for (const check of this._def.checks) {
        if (check.kind === "min") {
          if (input.data.length < check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          if (input.data.length > check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "length") {
          const tooBig = input.data.length > check.value;
          const tooSmall = input.data.length < check.value;
          if (tooBig || tooSmall) {
            ctx = this._getOrReturnCtx(input, ctx);
            if (tooBig) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                maximum: check.value,
                type: "string",
                inclusive: true,
                exact: true,
                message: check.message
              });
            } else if (tooSmall) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                minimum: check.value,
                type: "string",
                inclusive: true,
                exact: true,
                message: check.message
              });
            }
            status.dirty();
          }
        } else if (check.kind === "email") {
          if (!emailRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "email",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "emoji") {
          if (!emojiRegex) {
            emojiRegex = new RegExp(_emojiRegex, "u");
          }
          if (!emojiRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "emoji",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "uuid") {
          if (!uuidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "uuid",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "nanoid") {
          if (!nanoidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "nanoid",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "cuid") {
          if (!cuidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "cuid",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "cuid2") {
          if (!cuid2Regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "cuid2",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "ulid") {
          if (!ulidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "ulid",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "url") {
          try {
            new URL(input.data);
          } catch {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "url",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "regex") {
          check.regex.lastIndex = 0;
          const testResult = check.regex.test(input.data);
          if (!testResult) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "regex",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "trim") {
          input.data = input.data.trim();
        } else if (check.kind === "includes") {
          if (!input.data.includes(check.value, check.position)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: { includes: check.value, position: check.position },
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "toLowerCase") {
          input.data = input.data.toLowerCase();
        } else if (check.kind === "toUpperCase") {
          input.data = input.data.toUpperCase();
        } else if (check.kind === "startsWith") {
          if (!input.data.startsWith(check.value)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: { startsWith: check.value },
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "endsWith") {
          if (!input.data.endsWith(check.value)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: { endsWith: check.value },
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "datetime") {
          const regex = datetimeRegex(check);
          if (!regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: "datetime",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "date") {
          const regex = dateRegex;
          if (!regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: "date",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "time") {
          const regex = timeRegex(check);
          if (!regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: "time",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "duration") {
          if (!durationRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "duration",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "ip") {
          if (!isValidIP(input.data, check.version)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "ip",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "jwt") {
          if (!isValidJWT(input.data, check.alg)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "jwt",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "cidr") {
          if (!isValidCidr(input.data, check.version)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "cidr",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "base64") {
          if (!base64Regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "base64",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "base64url") {
          if (!base64urlRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "base64url",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return { status: status.value, value: input.data };
    }
    _regex(regex, validation, message) {
      return this.refinement((data) => regex.test(data), {
        validation,
        code: ZodIssueCode.invalid_string,
        ...errorUtil.errToObj(message)
      });
    }
    _addCheck(check) {
      return new ZodString({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    email(message) {
      return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
    }
    url(message) {
      return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
    }
    emoji(message) {
      return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
    }
    uuid(message) {
      return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
    }
    nanoid(message) {
      return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message) });
    }
    cuid(message) {
      return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
    }
    cuid2(message) {
      return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
    }
    ulid(message) {
      return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
    }
    base64(message) {
      return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message) });
    }
    base64url(message) {
      return this._addCheck({
        kind: "base64url",
        ...errorUtil.errToObj(message)
      });
    }
    jwt(options) {
      return this._addCheck({ kind: "jwt", ...errorUtil.errToObj(options) });
    }
    ip(options) {
      return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
    }
    cidr(options) {
      return this._addCheck({ kind: "cidr", ...errorUtil.errToObj(options) });
    }
    datetime(options) {
      if (typeof options === "string") {
        return this._addCheck({
          kind: "datetime",
          precision: null,
          offset: false,
          local: false,
          message: options
        });
      }
      return this._addCheck({
        kind: "datetime",
        precision: typeof options?.precision === "undefined" ? null : options?.precision,
        offset: options?.offset ?? false,
        local: options?.local ?? false,
        ...errorUtil.errToObj(options?.message)
      });
    }
    date(message) {
      return this._addCheck({ kind: "date", message });
    }
    time(options) {
      if (typeof options === "string") {
        return this._addCheck({
          kind: "time",
          precision: null,
          message: options
        });
      }
      return this._addCheck({
        kind: "time",
        precision: typeof options?.precision === "undefined" ? null : options?.precision,
        ...errorUtil.errToObj(options?.message)
      });
    }
    duration(message) {
      return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message) });
    }
    regex(regex, message) {
      return this._addCheck({
        kind: "regex",
        regex,
        ...errorUtil.errToObj(message)
      });
    }
    includes(value, options) {
      return this._addCheck({
        kind: "includes",
        value,
        position: options?.position,
        ...errorUtil.errToObj(options?.message)
      });
    }
    startsWith(value, message) {
      return this._addCheck({
        kind: "startsWith",
        value,
        ...errorUtil.errToObj(message)
      });
    }
    endsWith(value, message) {
      return this._addCheck({
        kind: "endsWith",
        value,
        ...errorUtil.errToObj(message)
      });
    }
    min(minLength, message) {
      return this._addCheck({
        kind: "min",
        value: minLength,
        ...errorUtil.errToObj(message)
      });
    }
    max(maxLength, message) {
      return this._addCheck({
        kind: "max",
        value: maxLength,
        ...errorUtil.errToObj(message)
      });
    }
    length(len, message) {
      return this._addCheck({
        kind: "length",
        value: len,
        ...errorUtil.errToObj(message)
      });
    }
    /**
     * Equivalent to `.min(1)`
     */
    nonempty(message) {
      return this.min(1, errorUtil.errToObj(message));
    }
    trim() {
      return new ZodString({
        ...this._def,
        checks: [...this._def.checks, { kind: "trim" }]
      });
    }
    toLowerCase() {
      return new ZodString({
        ...this._def,
        checks: [...this._def.checks, { kind: "toLowerCase" }]
      });
    }
    toUpperCase() {
      return new ZodString({
        ...this._def,
        checks: [...this._def.checks, { kind: "toUpperCase" }]
      });
    }
    get isDatetime() {
      return !!this._def.checks.find((ch) => ch.kind === "datetime");
    }
    get isDate() {
      return !!this._def.checks.find((ch) => ch.kind === "date");
    }
    get isTime() {
      return !!this._def.checks.find((ch) => ch.kind === "time");
    }
    get isDuration() {
      return !!this._def.checks.find((ch) => ch.kind === "duration");
    }
    get isEmail() {
      return !!this._def.checks.find((ch) => ch.kind === "email");
    }
    get isURL() {
      return !!this._def.checks.find((ch) => ch.kind === "url");
    }
    get isEmoji() {
      return !!this._def.checks.find((ch) => ch.kind === "emoji");
    }
    get isUUID() {
      return !!this._def.checks.find((ch) => ch.kind === "uuid");
    }
    get isNANOID() {
      return !!this._def.checks.find((ch) => ch.kind === "nanoid");
    }
    get isCUID() {
      return !!this._def.checks.find((ch) => ch.kind === "cuid");
    }
    get isCUID2() {
      return !!this._def.checks.find((ch) => ch.kind === "cuid2");
    }
    get isULID() {
      return !!this._def.checks.find((ch) => ch.kind === "ulid");
    }
    get isIP() {
      return !!this._def.checks.find((ch) => ch.kind === "ip");
    }
    get isCIDR() {
      return !!this._def.checks.find((ch) => ch.kind === "cidr");
    }
    get isBase64() {
      return !!this._def.checks.find((ch) => ch.kind === "base64");
    }
    get isBase64url() {
      return !!this._def.checks.find((ch) => ch.kind === "base64url");
    }
    get minLength() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        }
      }
      return min;
    }
    get maxLength() {
      let max = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return max;
    }
  }
  ZodString.create = (params) => {
    return new ZodString({
      checks: [],
      typeName: ZodFirstPartyTypeKind.ZodString,
      coerce: params?.coerce ?? false,
      ...processCreateParams(params)
    });
  };
  function floatSafeRemainder(val, step) {
    const valDecCount = (val.toString().split(".")[1] || "").length;
    const stepDecCount = (step.toString().split(".")[1] || "").length;
    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
    const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
    const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
    return valInt % stepInt / 10 ** decCount;
  }
  class ZodNumber extends ZodType {
    constructor() {
      super(...arguments);
      this.min = this.gte;
      this.max = this.lte;
      this.step = this.multipleOf;
    }
    _parse(input) {
      if (this._def.coerce) {
        input.data = Number(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.number) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.number,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      let ctx = void 0;
      const status = new ParseStatus();
      for (const check of this._def.checks) {
        if (check.kind === "int") {
          if (!util.isInteger(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: "integer",
              received: "float",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "min") {
          const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
          if (tooSmall) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "number",
              inclusive: check.inclusive,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
          if (tooBig) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "number",
              inclusive: check.inclusive,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "multipleOf") {
          if (floatSafeRemainder(input.data, check.value) !== 0) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.not_multiple_of,
              multipleOf: check.value,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "finite") {
          if (!Number.isFinite(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.not_finite,
              message: check.message
            });
            status.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return { status: status.value, value: input.data };
    }
    gte(value, message) {
      return this.setLimit("min", value, true, errorUtil.toString(message));
    }
    gt(value, message) {
      return this.setLimit("min", value, false, errorUtil.toString(message));
    }
    lte(value, message) {
      return this.setLimit("max", value, true, errorUtil.toString(message));
    }
    lt(value, message) {
      return this.setLimit("max", value, false, errorUtil.toString(message));
    }
    setLimit(kind, value, inclusive, message) {
      return new ZodNumber({
        ...this._def,
        checks: [
          ...this._def.checks,
          {
            kind,
            value,
            inclusive,
            message: errorUtil.toString(message)
          }
        ]
      });
    }
    _addCheck(check) {
      return new ZodNumber({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    int(message) {
      return this._addCheck({
        kind: "int",
        message: errorUtil.toString(message)
      });
    }
    positive(message) {
      return this._addCheck({
        kind: "min",
        value: 0,
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    negative(message) {
      return this._addCheck({
        kind: "max",
        value: 0,
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    nonpositive(message) {
      return this._addCheck({
        kind: "max",
        value: 0,
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    nonnegative(message) {
      return this._addCheck({
        kind: "min",
        value: 0,
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    multipleOf(value, message) {
      return this._addCheck({
        kind: "multipleOf",
        value,
        message: errorUtil.toString(message)
      });
    }
    finite(message) {
      return this._addCheck({
        kind: "finite",
        message: errorUtil.toString(message)
      });
    }
    safe(message) {
      return this._addCheck({
        kind: "min",
        inclusive: true,
        value: Number.MIN_SAFE_INTEGER,
        message: errorUtil.toString(message)
      })._addCheck({
        kind: "max",
        inclusive: true,
        value: Number.MAX_SAFE_INTEGER,
        message: errorUtil.toString(message)
      });
    }
    get minValue() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        }
      }
      return min;
    }
    get maxValue() {
      let max = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return max;
    }
    get isInt() {
      return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
    }
    get isFinite() {
      let max = null;
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
          return true;
        } else if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        } else if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return Number.isFinite(min) && Number.isFinite(max);
    }
  }
  ZodNumber.create = (params) => {
    return new ZodNumber({
      checks: [],
      typeName: ZodFirstPartyTypeKind.ZodNumber,
      coerce: params?.coerce || false,
      ...processCreateParams(params)
    });
  };
  class ZodBigInt extends ZodType {
    constructor() {
      super(...arguments);
      this.min = this.gte;
      this.max = this.lte;
    }
    _parse(input) {
      if (this._def.coerce) {
        try {
          input.data = BigInt(input.data);
        } catch {
          return this._getInvalidInput(input);
        }
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.bigint) {
        return this._getInvalidInput(input);
      }
      let ctx = void 0;
      const status = new ParseStatus();
      for (const check of this._def.checks) {
        if (check.kind === "min") {
          const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
          if (tooSmall) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              type: "bigint",
              minimum: check.value,
              inclusive: check.inclusive,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
          if (tooBig) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              type: "bigint",
              maximum: check.value,
              inclusive: check.inclusive,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "multipleOf") {
          if (input.data % check.value !== BigInt(0)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.not_multiple_of,
              multipleOf: check.value,
              message: check.message
            });
            status.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return { status: status.value, value: input.data };
    }
    _getInvalidInput(input) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.bigint,
        received: ctx.parsedType
      });
      return INVALID;
    }
    gte(value, message) {
      return this.setLimit("min", value, true, errorUtil.toString(message));
    }
    gt(value, message) {
      return this.setLimit("min", value, false, errorUtil.toString(message));
    }
    lte(value, message) {
      return this.setLimit("max", value, true, errorUtil.toString(message));
    }
    lt(value, message) {
      return this.setLimit("max", value, false, errorUtil.toString(message));
    }
    setLimit(kind, value, inclusive, message) {
      return new ZodBigInt({
        ...this._def,
        checks: [
          ...this._def.checks,
          {
            kind,
            value,
            inclusive,
            message: errorUtil.toString(message)
          }
        ]
      });
    }
    _addCheck(check) {
      return new ZodBigInt({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    positive(message) {
      return this._addCheck({
        kind: "min",
        value: BigInt(0),
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    negative(message) {
      return this._addCheck({
        kind: "max",
        value: BigInt(0),
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    nonpositive(message) {
      return this._addCheck({
        kind: "max",
        value: BigInt(0),
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    nonnegative(message) {
      return this._addCheck({
        kind: "min",
        value: BigInt(0),
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    multipleOf(value, message) {
      return this._addCheck({
        kind: "multipleOf",
        value,
        message: errorUtil.toString(message)
      });
    }
    get minValue() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        }
      }
      return min;
    }
    get maxValue() {
      let max = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return max;
    }
  }
  ZodBigInt.create = (params) => {
    return new ZodBigInt({
      checks: [],
      typeName: ZodFirstPartyTypeKind.ZodBigInt,
      coerce: params?.coerce ?? false,
      ...processCreateParams(params)
    });
  };
  class ZodBoolean extends ZodType {
    _parse(input) {
      if (this._def.coerce) {
        input.data = Boolean(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.boolean) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.boolean,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  }
  ZodBoolean.create = (params) => {
    return new ZodBoolean({
      typeName: ZodFirstPartyTypeKind.ZodBoolean,
      coerce: params?.coerce || false,
      ...processCreateParams(params)
    });
  };
  class ZodDate extends ZodType {
    _parse(input) {
      if (this._def.coerce) {
        input.data = new Date(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.date) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.date,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      if (Number.isNaN(input.data.getTime())) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_date
        });
        return INVALID;
      }
      const status = new ParseStatus();
      let ctx = void 0;
      for (const check of this._def.checks) {
        if (check.kind === "min") {
          if (input.data.getTime() < check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              message: check.message,
              inclusive: true,
              exact: false,
              minimum: check.value,
              type: "date"
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          if (input.data.getTime() > check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              message: check.message,
              inclusive: true,
              exact: false,
              maximum: check.value,
              type: "date"
            });
            status.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return {
        status: status.value,
        value: new Date(input.data.getTime())
      };
    }
    _addCheck(check) {
      return new ZodDate({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    min(minDate, message) {
      return this._addCheck({
        kind: "min",
        value: minDate.getTime(),
        message: errorUtil.toString(message)
      });
    }
    max(maxDate, message) {
      return this._addCheck({
        kind: "max",
        value: maxDate.getTime(),
        message: errorUtil.toString(message)
      });
    }
    get minDate() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        }
      }
      return min != null ? new Date(min) : null;
    }
    get maxDate() {
      let max = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return max != null ? new Date(max) : null;
    }
  }
  ZodDate.create = (params) => {
    return new ZodDate({
      checks: [],
      coerce: params?.coerce || false,
      typeName: ZodFirstPartyTypeKind.ZodDate,
      ...processCreateParams(params)
    });
  };
  class ZodSymbol extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.symbol) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.symbol,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  }
  ZodSymbol.create = (params) => {
    return new ZodSymbol({
      typeName: ZodFirstPartyTypeKind.ZodSymbol,
      ...processCreateParams(params)
    });
  };
  class ZodUndefined extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.undefined) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.undefined,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  }
  ZodUndefined.create = (params) => {
    return new ZodUndefined({
      typeName: ZodFirstPartyTypeKind.ZodUndefined,
      ...processCreateParams(params)
    });
  };
  class ZodNull extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.null) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.null,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  }
  ZodNull.create = (params) => {
    return new ZodNull({
      typeName: ZodFirstPartyTypeKind.ZodNull,
      ...processCreateParams(params)
    });
  };
  class ZodAny extends ZodType {
    constructor() {
      super(...arguments);
      this._any = true;
    }
    _parse(input) {
      return OK(input.data);
    }
  }
  ZodAny.create = (params) => {
    return new ZodAny({
      typeName: ZodFirstPartyTypeKind.ZodAny,
      ...processCreateParams(params)
    });
  };
  class ZodUnknown extends ZodType {
    constructor() {
      super(...arguments);
      this._unknown = true;
    }
    _parse(input) {
      return OK(input.data);
    }
  }
  ZodUnknown.create = (params) => {
    return new ZodUnknown({
      typeName: ZodFirstPartyTypeKind.ZodUnknown,
      ...processCreateParams(params)
    });
  };
  class ZodNever extends ZodType {
    _parse(input) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.never,
        received: ctx.parsedType
      });
      return INVALID;
    }
  }
  ZodNever.create = (params) => {
    return new ZodNever({
      typeName: ZodFirstPartyTypeKind.ZodNever,
      ...processCreateParams(params)
    });
  };
  class ZodVoid extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.undefined) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.void,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  }
  ZodVoid.create = (params) => {
    return new ZodVoid({
      typeName: ZodFirstPartyTypeKind.ZodVoid,
      ...processCreateParams(params)
    });
  };
  class ZodArray extends ZodType {
    _parse(input) {
      const { ctx, status } = this._processInputParams(input);
      const def = this._def;
      if (ctx.parsedType !== ZodParsedType.array) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.array,
          received: ctx.parsedType
        });
        return INVALID;
      }
      if (def.exactLength !== null) {
        const tooBig = ctx.data.length > def.exactLength.value;
        const tooSmall = ctx.data.length < def.exactLength.value;
        if (tooBig || tooSmall) {
          addIssueToContext(ctx, {
            code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
            minimum: tooSmall ? def.exactLength.value : void 0,
            maximum: tooBig ? def.exactLength.value : void 0,
            type: "array",
            inclusive: true,
            exact: true,
            message: def.exactLength.message
          });
          status.dirty();
        }
      }
      if (def.minLength !== null) {
        if (ctx.data.length < def.minLength.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: def.minLength.value,
            type: "array",
            inclusive: true,
            exact: false,
            message: def.minLength.message
          });
          status.dirty();
        }
      }
      if (def.maxLength !== null) {
        if (ctx.data.length > def.maxLength.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: def.maxLength.value,
            type: "array",
            inclusive: true,
            exact: false,
            message: def.maxLength.message
          });
          status.dirty();
        }
      }
      if (ctx.common.async) {
        return Promise.all([...ctx.data].map((item, i) => {
          return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
        })).then((result3) => {
          return ParseStatus.mergeArray(status, result3);
        });
      }
      const result2 = [...ctx.data].map((item, i) => {
        return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
      });
      return ParseStatus.mergeArray(status, result2);
    }
    get element() {
      return this._def.type;
    }
    min(minLength, message) {
      return new ZodArray({
        ...this._def,
        minLength: { value: minLength, message: errorUtil.toString(message) }
      });
    }
    max(maxLength, message) {
      return new ZodArray({
        ...this._def,
        maxLength: { value: maxLength, message: errorUtil.toString(message) }
      });
    }
    length(len, message) {
      return new ZodArray({
        ...this._def,
        exactLength: { value: len, message: errorUtil.toString(message) }
      });
    }
    nonempty(message) {
      return this.min(1, message);
    }
  }
  ZodArray.create = (schema, params) => {
    return new ZodArray({
      type: schema,
      minLength: null,
      maxLength: null,
      exactLength: null,
      typeName: ZodFirstPartyTypeKind.ZodArray,
      ...processCreateParams(params)
    });
  };
  function deepPartialify(schema) {
    if (schema instanceof ZodObject) {
      const newShape = {};
      for (const key in schema.shape) {
        const fieldSchema = schema.shape[key];
        newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
      }
      return new ZodObject({
        ...schema._def,
        shape: () => newShape
      });
    } else if (schema instanceof ZodArray) {
      return new ZodArray({
        ...schema._def,
        type: deepPartialify(schema.element)
      });
    } else if (schema instanceof ZodOptional) {
      return ZodOptional.create(deepPartialify(schema.unwrap()));
    } else if (schema instanceof ZodNullable) {
      return ZodNullable.create(deepPartialify(schema.unwrap()));
    } else if (schema instanceof ZodTuple) {
      return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
    } else {
      return schema;
    }
  }
  class ZodObject extends ZodType {
    constructor() {
      super(...arguments);
      this._cached = null;
      this.nonstrict = this.passthrough;
      this.augment = this.extend;
    }
    _getCached() {
      if (this._cached !== null)
        return this._cached;
      const shape = this._def.shape();
      const keys = util.objectKeys(shape);
      this._cached = { shape, keys };
      return this._cached;
    }
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.object) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.object,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      const { status, ctx } = this._processInputParams(input);
      const { shape, keys: shapeKeys } = this._getCached();
      const extraKeys = [];
      if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
        for (const key in ctx.data) {
          if (!shapeKeys.includes(key)) {
            extraKeys.push(key);
          }
        }
      }
      const pairs = [];
      for (const key of shapeKeys) {
        const keyValidator = shape[key];
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
          alwaysSet: key in ctx.data
        });
      }
      if (this._def.catchall instanceof ZodNever) {
        const unknownKeys = this._def.unknownKeys;
        if (unknownKeys === "passthrough") {
          for (const key of extraKeys) {
            pairs.push({
              key: { status: "valid", value: key },
              value: { status: "valid", value: ctx.data[key] }
            });
          }
        } else if (unknownKeys === "strict") {
          if (extraKeys.length > 0) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.unrecognized_keys,
              keys: extraKeys
            });
            status.dirty();
          }
        } else if (unknownKeys === "strip") ;
        else {
          throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
        }
      } else {
        const catchall = this._def.catchall;
        for (const key of extraKeys) {
          const value = ctx.data[key];
          pairs.push({
            key: { status: "valid", value: key },
            value: catchall._parse(
              new ParseInputLazyPath(ctx, value, ctx.path, key)
              //, ctx.child(key), value, getParsedType(value)
            ),
            alwaysSet: key in ctx.data
          });
        }
      }
      if (ctx.common.async) {
        return Promise.resolve().then(async () => {
          const syncPairs = [];
          for (const pair of pairs) {
            const key = await pair.key;
            const value = await pair.value;
            syncPairs.push({
              key,
              value,
              alwaysSet: pair.alwaysSet
            });
          }
          return syncPairs;
        }).then((syncPairs) => {
          return ParseStatus.mergeObjectSync(status, syncPairs);
        });
      } else {
        return ParseStatus.mergeObjectSync(status, pairs);
      }
    }
    get shape() {
      return this._def.shape();
    }
    strict(message) {
      errorUtil.errToObj;
      return new ZodObject({
        ...this._def,
        unknownKeys: "strict",
        ...message !== void 0 ? {
          errorMap: (issue, ctx) => {
            const defaultError = this._def.errorMap?.(issue, ctx).message ?? ctx.defaultError;
            if (issue.code === "unrecognized_keys")
              return {
                message: errorUtil.errToObj(message).message ?? defaultError
              };
            return {
              message: defaultError
            };
          }
        } : {}
      });
    }
    strip() {
      return new ZodObject({
        ...this._def,
        unknownKeys: "strip"
      });
    }
    passthrough() {
      return new ZodObject({
        ...this._def,
        unknownKeys: "passthrough"
      });
    }
    // const AugmentFactory =
    //   <Def extends ZodObjectDef>(def: Def) =>
    //   <Augmentation extends ZodRawShape>(
    //     augmentation: Augmentation
    //   ): ZodObject<
    //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
    //     Def["unknownKeys"],
    //     Def["catchall"]
    //   > => {
    //     return new ZodObject({
    //       ...def,
    //       shape: () => ({
    //         ...def.shape(),
    //         ...augmentation,
    //       }),
    //     }) as any;
    //   };
    extend(augmentation) {
      return new ZodObject({
        ...this._def,
        shape: () => ({
          ...this._def.shape(),
          ...augmentation
        })
      });
    }
    /**
     * Prior to zod@1.0.12 there was a bug in the
     * inferred type of merged objects. Please
     * upgrade if you are experiencing issues.
     */
    merge(merging) {
      const merged = new ZodObject({
        unknownKeys: merging._def.unknownKeys,
        catchall: merging._def.catchall,
        shape: () => ({
          ...this._def.shape(),
          ...merging._def.shape()
        }),
        typeName: ZodFirstPartyTypeKind.ZodObject
      });
      return merged;
    }
    // merge<
    //   Incoming extends AnyZodObject,
    //   Augmentation extends Incoming["shape"],
    //   NewOutput extends {
    //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
    //       ? Augmentation[k]["_output"]
    //       : k extends keyof Output
    //       ? Output[k]
    //       : never;
    //   },
    //   NewInput extends {
    //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
    //       ? Augmentation[k]["_input"]
    //       : k extends keyof Input
    //       ? Input[k]
    //       : never;
    //   }
    // >(
    //   merging: Incoming
    // ): ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"],
    //   NewOutput,
    //   NewInput
    // > {
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    setKey(key, schema) {
      return this.augment({ [key]: schema });
    }
    // merge<Incoming extends AnyZodObject>(
    //   merging: Incoming
    // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
    // ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"]
    // > {
    //   // const mergedShape = objectUtil.mergeShapes(
    //   //   this._def.shape(),
    //   //   merging._def.shape()
    //   // );
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    catchall(index) {
      return new ZodObject({
        ...this._def,
        catchall: index
      });
    }
    pick(mask) {
      const shape = {};
      for (const key of util.objectKeys(mask)) {
        if (mask[key] && this.shape[key]) {
          shape[key] = this.shape[key];
        }
      }
      return new ZodObject({
        ...this._def,
        shape: () => shape
      });
    }
    omit(mask) {
      const shape = {};
      for (const key of util.objectKeys(this.shape)) {
        if (!mask[key]) {
          shape[key] = this.shape[key];
        }
      }
      return new ZodObject({
        ...this._def,
        shape: () => shape
      });
    }
    /**
     * @deprecated
     */
    deepPartial() {
      return deepPartialify(this);
    }
    partial(mask) {
      const newShape = {};
      for (const key of util.objectKeys(this.shape)) {
        const fieldSchema = this.shape[key];
        if (mask && !mask[key]) {
          newShape[key] = fieldSchema;
        } else {
          newShape[key] = fieldSchema.optional();
        }
      }
      return new ZodObject({
        ...this._def,
        shape: () => newShape
      });
    }
    required(mask) {
      const newShape = {};
      for (const key of util.objectKeys(this.shape)) {
        if (mask && !mask[key]) {
          newShape[key] = this.shape[key];
        } else {
          const fieldSchema = this.shape[key];
          let newField = fieldSchema;
          while (newField instanceof ZodOptional) {
            newField = newField._def.innerType;
          }
          newShape[key] = newField;
        }
      }
      return new ZodObject({
        ...this._def,
        shape: () => newShape
      });
    }
    keyof() {
      return createZodEnum(util.objectKeys(this.shape));
    }
  }
  ZodObject.create = (shape, params) => {
    return new ZodObject({
      shape: () => shape,
      unknownKeys: "strip",
      catchall: ZodNever.create(),
      typeName: ZodFirstPartyTypeKind.ZodObject,
      ...processCreateParams(params)
    });
  };
  ZodObject.strictCreate = (shape, params) => {
    return new ZodObject({
      shape: () => shape,
      unknownKeys: "strict",
      catchall: ZodNever.create(),
      typeName: ZodFirstPartyTypeKind.ZodObject,
      ...processCreateParams(params)
    });
  };
  ZodObject.lazycreate = (shape, params) => {
    return new ZodObject({
      shape,
      unknownKeys: "strip",
      catchall: ZodNever.create(),
      typeName: ZodFirstPartyTypeKind.ZodObject,
      ...processCreateParams(params)
    });
  };
  class ZodUnion extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const options = this._def.options;
      function handleResults(results) {
        for (const result2 of results) {
          if (result2.result.status === "valid") {
            return result2.result;
          }
        }
        for (const result2 of results) {
          if (result2.result.status === "dirty") {
            ctx.common.issues.push(...result2.ctx.common.issues);
            return result2.result;
          }
        }
        const unionErrors = results.map((result2) => new ZodError(result2.ctx.common.issues));
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_union,
          unionErrors
        });
        return INVALID;
      }
      if (ctx.common.async) {
        return Promise.all(options.map(async (option) => {
          const childCtx = {
            ...ctx,
            common: {
              ...ctx.common,
              issues: []
            },
            parent: null
          };
          return {
            result: await option._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: childCtx
            }),
            ctx: childCtx
          };
        })).then(handleResults);
      } else {
        let dirty = void 0;
        const issues = [];
        for (const option of options) {
          const childCtx = {
            ...ctx,
            common: {
              ...ctx.common,
              issues: []
            },
            parent: null
          };
          const result2 = option._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          });
          if (result2.status === "valid") {
            return result2;
          } else if (result2.status === "dirty" && !dirty) {
            dirty = { result: result2, ctx: childCtx };
          }
          if (childCtx.common.issues.length) {
            issues.push(childCtx.common.issues);
          }
        }
        if (dirty) {
          ctx.common.issues.push(...dirty.ctx.common.issues);
          return dirty.result;
        }
        const unionErrors = issues.map((issues2) => new ZodError(issues2));
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_union,
          unionErrors
        });
        return INVALID;
      }
    }
    get options() {
      return this._def.options;
    }
  }
  ZodUnion.create = (types, params) => {
    return new ZodUnion({
      options: types,
      typeName: ZodFirstPartyTypeKind.ZodUnion,
      ...processCreateParams(params)
    });
  };
  function mergeValues(a, b) {
    const aType = getParsedType(a);
    const bType = getParsedType(b);
    if (a === b) {
      return { valid: true, data: a };
    } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
      const bKeys = util.objectKeys(b);
      const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
      const newObj = { ...a, ...b };
      for (const key of sharedKeys) {
        const sharedValue = mergeValues(a[key], b[key]);
        if (!sharedValue.valid) {
          return { valid: false };
        }
        newObj[key] = sharedValue.data;
      }
      return { valid: true, data: newObj };
    } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
      if (a.length !== b.length) {
        return { valid: false };
      }
      const newArray = [];
      for (let index = 0; index < a.length; index++) {
        const itemA = a[index];
        const itemB = b[index];
        const sharedValue = mergeValues(itemA, itemB);
        if (!sharedValue.valid) {
          return { valid: false };
        }
        newArray.push(sharedValue.data);
      }
      return { valid: true, data: newArray };
    } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
      return { valid: true, data: a };
    } else {
      return { valid: false };
    }
  }
  class ZodIntersection extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      const handleParsed = (parsedLeft, parsedRight) => {
        if (isAborted(parsedLeft) || isAborted(parsedRight)) {
          return INVALID;
        }
        const merged = mergeValues(parsedLeft.value, parsedRight.value);
        if (!merged.valid) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_intersection_types
          });
          return INVALID;
        }
        if (isDirty(parsedLeft) || isDirty(parsedRight)) {
          status.dirty();
        }
        return { status: status.value, value: merged.data };
      };
      if (ctx.common.async) {
        return Promise.all([
          this._def.left._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          }),
          this._def.right._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          })
        ]).then(([left, right]) => handleParsed(left, right));
      } else {
        return handleParsed(this._def.left._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }), this._def.right._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }));
      }
    }
  }
  ZodIntersection.create = (left, right, params) => {
    return new ZodIntersection({
      left,
      right,
      typeName: ZodFirstPartyTypeKind.ZodIntersection,
      ...processCreateParams(params)
    });
  };
  class ZodTuple extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.array) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.array,
          received: ctx.parsedType
        });
        return INVALID;
      }
      if (ctx.data.length < this._def.items.length) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: this._def.items.length,
          inclusive: true,
          exact: false,
          type: "array"
        });
        return INVALID;
      }
      const rest = this._def.rest;
      if (!rest && ctx.data.length > this._def.items.length) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: this._def.items.length,
          inclusive: true,
          exact: false,
          type: "array"
        });
        status.dirty();
      }
      const items = [...ctx.data].map((item, itemIndex) => {
        const schema = this._def.items[itemIndex] || this._def.rest;
        if (!schema)
          return null;
        return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
      }).filter((x) => !!x);
      if (ctx.common.async) {
        return Promise.all(items).then((results) => {
          return ParseStatus.mergeArray(status, results);
        });
      } else {
        return ParseStatus.mergeArray(status, items);
      }
    }
    get items() {
      return this._def.items;
    }
    rest(rest) {
      return new ZodTuple({
        ...this._def,
        rest
      });
    }
  }
  ZodTuple.create = (schemas, params) => {
    if (!Array.isArray(schemas)) {
      throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
    }
    return new ZodTuple({
      items: schemas,
      typeName: ZodFirstPartyTypeKind.ZodTuple,
      rest: null,
      ...processCreateParams(params)
    });
  };
  class ZodMap extends ZodType {
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.map) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.map,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const keyType = this._def.keyType;
      const valueType = this._def.valueType;
      const pairs = [...ctx.data.entries()].map(([key, value], index) => {
        return {
          key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
          value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
        };
      });
      if (ctx.common.async) {
        const finalMap = /* @__PURE__ */ new Map();
        return Promise.resolve().then(async () => {
          for (const pair of pairs) {
            const key = await pair.key;
            const value = await pair.value;
            if (key.status === "aborted" || value.status === "aborted") {
              return INVALID;
            }
            if (key.status === "dirty" || value.status === "dirty") {
              status.dirty();
            }
            finalMap.set(key.value, value.value);
          }
          return { status: status.value, value: finalMap };
        });
      } else {
        const finalMap = /* @__PURE__ */ new Map();
        for (const pair of pairs) {
          const key = pair.key;
          const value = pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      }
    }
  }
  ZodMap.create = (keyType, valueType, params) => {
    return new ZodMap({
      valueType,
      keyType,
      typeName: ZodFirstPartyTypeKind.ZodMap,
      ...processCreateParams(params)
    });
  };
  class ZodSet extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.set) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.set,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const def = this._def;
      if (def.minSize !== null) {
        if (ctx.data.size < def.minSize.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: def.minSize.value,
            type: "set",
            inclusive: true,
            exact: false,
            message: def.minSize.message
          });
          status.dirty();
        }
      }
      if (def.maxSize !== null) {
        if (ctx.data.size > def.maxSize.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: def.maxSize.value,
            type: "set",
            inclusive: true,
            exact: false,
            message: def.maxSize.message
          });
          status.dirty();
        }
      }
      const valueType = this._def.valueType;
      function finalizeSet(elements2) {
        const parsedSet = /* @__PURE__ */ new Set();
        for (const element of elements2) {
          if (element.status === "aborted")
            return INVALID;
          if (element.status === "dirty")
            status.dirty();
          parsedSet.add(element.value);
        }
        return { status: status.value, value: parsedSet };
      }
      const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
      if (ctx.common.async) {
        return Promise.all(elements).then((elements2) => finalizeSet(elements2));
      } else {
        return finalizeSet(elements);
      }
    }
    min(minSize, message) {
      return new ZodSet({
        ...this._def,
        minSize: { value: minSize, message: errorUtil.toString(message) }
      });
    }
    max(maxSize, message) {
      return new ZodSet({
        ...this._def,
        maxSize: { value: maxSize, message: errorUtil.toString(message) }
      });
    }
    size(size, message) {
      return this.min(size, message).max(size, message);
    }
    nonempty(message) {
      return this.min(1, message);
    }
  }
  ZodSet.create = (valueType, params) => {
    return new ZodSet({
      valueType,
      minSize: null,
      maxSize: null,
      typeName: ZodFirstPartyTypeKind.ZodSet,
      ...processCreateParams(params)
    });
  };
  class ZodLazy extends ZodType {
    get schema() {
      return this._def.getter();
    }
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const lazySchema = this._def.getter();
      return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
    }
  }
  ZodLazy.create = (getter, params) => {
    return new ZodLazy({
      getter,
      typeName: ZodFirstPartyTypeKind.ZodLazy,
      ...processCreateParams(params)
    });
  };
  class ZodLiteral extends ZodType {
    _parse(input) {
      if (input.data !== this._def.value) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          received: ctx.data,
          code: ZodIssueCode.invalid_literal,
          expected: this._def.value
        });
        return INVALID;
      }
      return { status: "valid", value: input.data };
    }
    get value() {
      return this._def.value;
    }
  }
  ZodLiteral.create = (value, params) => {
    return new ZodLiteral({
      value,
      typeName: ZodFirstPartyTypeKind.ZodLiteral,
      ...processCreateParams(params)
    });
  };
  function createZodEnum(values, params) {
    return new ZodEnum({
      values,
      typeName: ZodFirstPartyTypeKind.ZodEnum,
      ...processCreateParams(params)
    });
  }
  class ZodEnum extends ZodType {
    _parse(input) {
      if (typeof input.data !== "string") {
        const ctx = this._getOrReturnCtx(input);
        const expectedValues = this._def.values;
        addIssueToContext(ctx, {
          expected: util.joinValues(expectedValues),
          received: ctx.parsedType,
          code: ZodIssueCode.invalid_type
        });
        return INVALID;
      }
      if (!this._cache) {
        this._cache = new Set(this._def.values);
      }
      if (!this._cache.has(input.data)) {
        const ctx = this._getOrReturnCtx(input);
        const expectedValues = this._def.values;
        addIssueToContext(ctx, {
          received: ctx.data,
          code: ZodIssueCode.invalid_enum_value,
          options: expectedValues
        });
        return INVALID;
      }
      return OK(input.data);
    }
    get options() {
      return this._def.values;
    }
    get enum() {
      const enumValues = {};
      for (const val of this._def.values) {
        enumValues[val] = val;
      }
      return enumValues;
    }
    get Values() {
      const enumValues = {};
      for (const val of this._def.values) {
        enumValues[val] = val;
      }
      return enumValues;
    }
    get Enum() {
      const enumValues = {};
      for (const val of this._def.values) {
        enumValues[val] = val;
      }
      return enumValues;
    }
    extract(values, newDef = this._def) {
      return ZodEnum.create(values, {
        ...this._def,
        ...newDef
      });
    }
    exclude(values, newDef = this._def) {
      return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
        ...this._def,
        ...newDef
      });
    }
  }
  ZodEnum.create = createZodEnum;
  class ZodNativeEnum extends ZodType {
    _parse(input) {
      const nativeEnumValues = util.getValidEnumValues(this._def.values);
      const ctx = this._getOrReturnCtx(input);
      if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
        const expectedValues = util.objectValues(nativeEnumValues);
        addIssueToContext(ctx, {
          expected: util.joinValues(expectedValues),
          received: ctx.parsedType,
          code: ZodIssueCode.invalid_type
        });
        return INVALID;
      }
      if (!this._cache) {
        this._cache = new Set(util.getValidEnumValues(this._def.values));
      }
      if (!this._cache.has(input.data)) {
        const expectedValues = util.objectValues(nativeEnumValues);
        addIssueToContext(ctx, {
          received: ctx.data,
          code: ZodIssueCode.invalid_enum_value,
          options: expectedValues
        });
        return INVALID;
      }
      return OK(input.data);
    }
    get enum() {
      return this._def.values;
    }
  }
  ZodNativeEnum.create = (values, params) => {
    return new ZodNativeEnum({
      values,
      typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
      ...processCreateParams(params)
    });
  };
  class ZodPromise extends ZodType {
    unwrap() {
      return this._def.type;
    }
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.promise,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
      return OK(promisified.then((data) => {
        return this._def.type.parseAsync(data, {
          path: ctx.path,
          errorMap: ctx.common.contextualErrorMap
        });
      }));
    }
  }
  ZodPromise.create = (schema, params) => {
    return new ZodPromise({
      type: schema,
      typeName: ZodFirstPartyTypeKind.ZodPromise,
      ...processCreateParams(params)
    });
  };
  class ZodEffects extends ZodType {
    innerType() {
      return this._def.schema;
    }
    sourceType() {
      return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
    }
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      const effect = this._def.effect || null;
      const checkCtx = {
        addIssue: (arg) => {
          addIssueToContext(ctx, arg);
          if (arg.fatal) {
            status.abort();
          } else {
            status.dirty();
          }
        },
        get path() {
          return ctx.path;
        }
      };
      checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
      if (effect.type === "preprocess") {
        const processed = effect.transform(ctx.data, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(processed).then(async (processed2) => {
            if (status.value === "aborted")
              return INVALID;
            const result2 = await this._def.schema._parseAsync({
              data: processed2,
              path: ctx.path,
              parent: ctx
            });
            if (result2.status === "aborted")
              return INVALID;
            if (result2.status === "dirty")
              return DIRTY(result2.value);
            if (status.value === "dirty")
              return DIRTY(result2.value);
            return result2;
          });
        } else {
          if (status.value === "aborted")
            return INVALID;
          const result2 = this._def.schema._parseSync({
            data: processed,
            path: ctx.path,
            parent: ctx
          });
          if (result2.status === "aborted")
            return INVALID;
          if (result2.status === "dirty")
            return DIRTY(result2.value);
          if (status.value === "dirty")
            return DIRTY(result2.value);
          return result2;
        }
      }
      if (effect.type === "refinement") {
        const executeRefinement = (acc) => {
          const result2 = effect.refinement(acc, checkCtx);
          if (ctx.common.async) {
            return Promise.resolve(result2);
          }
          if (result2 instanceof Promise) {
            throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
          }
          return acc;
        };
        if (ctx.common.async === false) {
          const inner = this._def.schema._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          executeRefinement(inner.value);
          return { status: status.value, value: inner.value };
        } else {
          return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
            if (inner.status === "aborted")
              return INVALID;
            if (inner.status === "dirty")
              status.dirty();
            return executeRefinement(inner.value).then(() => {
              return { status: status.value, value: inner.value };
            });
          });
        }
      }
      if (effect.type === "transform") {
        if (ctx.common.async === false) {
          const base2 = this._def.schema._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (!isValid(base2))
            return INVALID;
          const result2 = effect.transform(base2.value, checkCtx);
          if (result2 instanceof Promise) {
            throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
          }
          return { status: status.value, value: result2 };
        } else {
          return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base2) => {
            if (!isValid(base2))
              return INVALID;
            return Promise.resolve(effect.transform(base2.value, checkCtx)).then((result2) => ({
              status: status.value,
              value: result2
            }));
          });
        }
      }
      util.assertNever(effect);
    }
  }
  ZodEffects.create = (schema, effect, params) => {
    return new ZodEffects({
      schema,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect,
      ...processCreateParams(params)
    });
  };
  ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
    return new ZodEffects({
      schema,
      effect: { type: "preprocess", transform: preprocess },
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      ...processCreateParams(params)
    });
  };
  class ZodOptional extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType === ZodParsedType.undefined) {
        return OK(void 0);
      }
      return this._def.innerType._parse(input);
    }
    unwrap() {
      return this._def.innerType;
    }
  }
  ZodOptional.create = (type, params) => {
    return new ZodOptional({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodOptional,
      ...processCreateParams(params)
    });
  };
  class ZodNullable extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType === ZodParsedType.null) {
        return OK(null);
      }
      return this._def.innerType._parse(input);
    }
    unwrap() {
      return this._def.innerType;
    }
  }
  ZodNullable.create = (type, params) => {
    return new ZodNullable({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodNullable,
      ...processCreateParams(params)
    });
  };
  class ZodDefault extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      let data = ctx.data;
      if (ctx.parsedType === ZodParsedType.undefined) {
        data = this._def.defaultValue();
      }
      return this._def.innerType._parse({
        data,
        path: ctx.path,
        parent: ctx
      });
    }
    removeDefault() {
      return this._def.innerType;
    }
  }
  ZodDefault.create = (type, params) => {
    return new ZodDefault({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodDefault,
      defaultValue: typeof params.default === "function" ? params.default : () => params.default,
      ...processCreateParams(params)
    });
  };
  class ZodCatch extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const newCtx = {
        ...ctx,
        common: {
          ...ctx.common,
          issues: []
        }
      };
      const result2 = this._def.innerType._parse({
        data: newCtx.data,
        path: newCtx.path,
        parent: {
          ...newCtx
        }
      });
      if (isAsync(result2)) {
        return result2.then((result3) => {
          return {
            status: "valid",
            value: result3.status === "valid" ? result3.value : this._def.catchValue({
              get error() {
                return new ZodError(newCtx.common.issues);
              },
              input: newCtx.data
            })
          };
        });
      } else {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      }
    }
    removeCatch() {
      return this._def.innerType;
    }
  }
  ZodCatch.create = (type, params) => {
    return new ZodCatch({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodCatch,
      catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
      ...processCreateParams(params)
    });
  };
  class ZodNaN extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.nan) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.nan,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return { status: "valid", value: input.data };
    }
  }
  ZodNaN.create = (params) => {
    return new ZodNaN({
      typeName: ZodFirstPartyTypeKind.ZodNaN,
      ...processCreateParams(params)
    });
  };
  class ZodBranded extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const data = ctx.data;
      return this._def.type._parse({
        data,
        path: ctx.path,
        parent: ctx
      });
    }
    unwrap() {
      return this._def.type;
    }
  }
  class ZodPipeline extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.common.async) {
        const handleAsync = async () => {
          const inResult = await this._def.in._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (inResult.status === "aborted")
            return INVALID;
          if (inResult.status === "dirty") {
            status.dirty();
            return DIRTY(inResult.value);
          } else {
            return this._def.out._parseAsync({
              data: inResult.value,
              path: ctx.path,
              parent: ctx
            });
          }
        };
        return handleAsync();
      } else {
        const inResult = this._def.in._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return {
            status: "dirty",
            value: inResult.value
          };
        } else {
          return this._def.out._parseSync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      }
    }
    static create(a, b) {
      return new ZodPipeline({
        in: a,
        out: b,
        typeName: ZodFirstPartyTypeKind.ZodPipeline
      });
    }
  }
  class ZodReadonly extends ZodType {
    _parse(input) {
      const result2 = this._def.innerType._parse(input);
      const freeze = (data) => {
        if (isValid(data)) {
          data.value = Object.freeze(data.value);
        }
        return data;
      };
      return isAsync(result2) ? result2.then((data) => freeze(data)) : freeze(result2);
    }
    unwrap() {
      return this._def.innerType;
    }
  }
  ZodReadonly.create = (type, params) => {
    return new ZodReadonly({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodReadonly,
      ...processCreateParams(params)
    });
  };
  var ZodFirstPartyTypeKind;
  (function(ZodFirstPartyTypeKind2) {
    ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
    ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
    ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
    ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
    ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
    ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
    ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
    ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
    ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
    ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
    ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
    ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
    ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
    ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
    ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
    ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
    ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
    ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
    ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
    ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
    ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
    ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
    ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
    ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
    ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
    ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
    ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
    ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
    ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
    ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
    ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
    ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
    ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
    ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
    ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
    ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
  })(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
  const stringType = ZodString.create;
  const numberType = ZodNumber.create;
  const booleanType = ZodBoolean.create;
  ZodNever.create;
  ZodArray.create;
  const objectType = ZodObject.create;
  ZodUnion.create;
  ZodIntersection.create;
  ZodTuple.create;
  ZodEnum.create;
  ZodPromise.create;
  ZodOptional.create;
  ZodNullable.create;
  const t = initTRPC.create({
    isServer: false,
    allowOutsideOfServer: true
  });
  function createBackgroundRouter(handlers) {
    return t.router({
      getState: t.procedure.query(() => handlers.getState()),
      listTabs: t.procedure.query(() => handlers.listTabs()),
      listOwnedTabs: t.procedure.query(() => handlers.listOwnedTabs()),
      startRecording: t.procedure.mutation(async () => {
        await handlers.startRecording();
        return { ok: true };
      }),
      stopRecording: t.procedure.mutation(async () => {
        await handlers.stopRecording();
        return { ok: true };
      }),
      clearRecording: t.procedure.mutation(() => {
        handlers.clearRecording();
        return { ok: true };
      }),
      getRecording: t.procedure.query(() => handlers.getRecording()),
      setTargetTab: t.procedure.input(objectType({ tabId: numberType().int().nullable() })).mutation(({ input }) => {
        handlers.setTargetTab(input.tabId);
        return { ok: true };
      }),
      connect: t.procedure.input(objectType({ url: stringType().min(1) })).mutation(({ input }) => {
        handlers.connect(input.url);
        return { ok: true };
      }),
      disconnect: t.procedure.mutation(() => {
        handlers.disconnect();
        return { ok: true };
      }),
      sendClick: t.procedure.input(objectType({ selector: stringType().min(1) })).mutation(({ input }) => {
        return handlers.sendClick(input.selector);
      }),
      sendSnapshot: t.procedure.input(objectType({
        includeHidden: booleanType().optional(),
        maxElements: numberType().optional(),
        maxText: numberType().optional()
      })).mutation(({ input }) => handlers.sendSnapshot(input))
    });
  }
  let ws$1 = null;
  let wsUrl = "ws://localhost:9099/ws";
  let wsConnected = false;
  let lastError = null;
  let lastCommand = null;
  let lastSnapshot = null;
  let targetTabId = null;
  let recording = false;
  let recordedActions = [];
  const tabOwners = /* @__PURE__ */ new Map();
  const sessionTabs = /* @__PURE__ */ new Map();
  const chromeApi = globalThis.chrome ?? browser;
  const handleRuntimeMessage = (message) => {
    if (message?.type === "record_event" && recording) {
      const payload = message.payload;
      if (payload?.type && payload?.timestamp) {
        recordedActions.push(payload);
      }
    }
  };
  async function getActiveTabId(preferredTabId) {
    if (preferredTabId != null) return preferredTabId;
    if (targetTabId != null) return targetTabId;
    const tabs = await chromeApi.tabs.query({ active: true, lastFocusedWindow: true });
    const tab = tabs.find((t2) => t2.id != null && !t2.url?.startsWith("chrome://") && !t2.url?.startsWith("chrome-extension://"));
    return tab?.id ?? null;
  }
  async function listTabs() {
    const tabs = await chromeApi.tabs.query({});
    return tabs.filter((t2) => t2.id != null && t2.url && !t2.url.startsWith("chrome://") && !t2.url.startsWith("chrome-extension://")).map((t2) => ({ id: t2.id, title: t2.title || "Untitled", url: t2.url || "" }));
  }
  async function listOwnedTabs() {
    const tabs = await listTabs();
    const tabMap = /* @__PURE__ */ new Map();
    for (const tab of tabs) tabMap.set(tab.id, tab);
    const entries = [];
    for (const [sessionId, set] of sessionTabs) {
      const owned = [];
      for (const tabId of set) {
        const info = tabMap.get(tabId);
        if (info && allowTabAccess(tabId, sessionId)) {
          owned.push(info);
        }
      }
      entries.push({ sessionId, tabs: owned });
    }
    return entries;
  }
  function getOwner(tabId) {
    return tabOwners.get(tabId);
  }
  function ensureOwner(tabId, sessionId, mode) {
    const ownership = tabOwners.get(tabId);
    if (!ownership) {
      tabOwners.set(tabId, { mode, owners: /* @__PURE__ */ new Set([sessionId]), allowShared: false });
      addSessionTab(sessionId, tabId);
      return;
    }
    if (mode === "shared") {
      ownership.mode = "shared";
      ownership.owners.add(sessionId);
    } else {
      ownership.mode = "exclusive";
      ownership.owners = /* @__PURE__ */ new Set([sessionId]);
    }
    addSessionTab(sessionId, tabId);
  }
  function releaseOwner(tabId, sessionId) {
    const ownership = tabOwners.get(tabId);
    if (!ownership) return;
    ownership.owners.delete(sessionId);
    removeSessionTab(sessionId, tabId);
    if (ownership.owners.size === 0) {
      tabOwners.delete(tabId);
    } else if (ownership.mode === "exclusive") {
      const next = ownership.owners.values().next().value;
      ownership.owners = /* @__PURE__ */ new Set([next]);
    }
  }
  function allowTabAccess(tabId, sessionId) {
    const ownership = tabOwners.get(tabId);
    if (!ownership) return false;
    return ownership.owners.has(sessionId);
  }
  function addSessionTab(sessionId, tabId) {
    const set = sessionTabs.get(sessionId) ?? /* @__PURE__ */ new Set();
    set.add(tabId);
    sessionTabs.set(sessionId, set);
  }
  function removeSessionTab(sessionId, tabId) {
    const set = sessionTabs.get(sessionId);
    if (!set) return;
    set.delete(tabId);
    if (set.size === 0) {
      sessionTabs.delete(sessionId);
    }
  }
  function releaseSession(sessionId) {
    const set = sessionTabs.get(sessionId);
    if (!set) return;
    for (const tabId of set) {
      releaseOwner(tabId, sessionId);
    }
    sessionTabs.delete(sessionId);
  }
  function requireSession(cmd) {
    const sessionId = cmd.sessionId;
    if (!sessionId || !sessionId.trim()) {
      return null;
    }
    return sessionId;
  }
  function makeContentClient(tabId) {
    const port = chromeApi.tabs.connect(tabId, { name: "mcp-content" });
    const client = createTRPCProxyClient({
      links: [linkExports.chromeLink({ port })]
    });
    return { client, port };
  }
  async function handleClick(payload, tabIdOverride, sessionId) {
    const tabId = await getActiveTabId(tabIdOverride);
    if (!tabId) {
      return { id: "", ok: false, error: "No active tab available", errorCode: "NO_ACTIVE_TAB" };
    }
    if (!sessionId || !allowTabAccess(tabId, sessionId)) {
      return { id: "", ok: false, error: "Tab not owned by session", errorCode: "TAB_NOT_OWNED" };
    }
    const { client, port } = makeContentClient(tabId);
    try {
      const res = await client.click.mutate({ selector: payload.selector });
      return { id: "", ok: res.ok !== false, error: res.error, errorCode: res.errorCode, data: res.data };
    } finally {
      port.disconnect();
    }
  }
  async function handleSnapshot(payload, tabIdOverride, sessionId) {
    const tabId = await getActiveTabId(tabIdOverride);
    if (!tabId) {
      return { id: "", ok: false, error: "No active tab available", errorCode: "NO_ACTIVE_TAB" };
    }
    if (!sessionId || !allowTabAccess(tabId, sessionId)) {
      return { id: "", ok: false, error: "Tab not owned by session", errorCode: "TAB_NOT_OWNED" };
    }
    const { client, port } = makeContentClient(tabId);
    try {
      const data = await client.snapshot.query({
        includeHidden: payload.includeHidden,
        maxElements: payload.maxElements,
        maxText: payload.maxText,
        includeHTML: payload.includeHTML,
        maxHTML: payload.maxHTML,
        maxHTMLTokens: payload.maxHTMLTokens
      });
      lastSnapshot = data;
      return { id: "", ok: true, data };
    } finally {
      port.disconnect();
    }
  }
  async function handleScroll(payload, tabIdOverride, sessionId) {
    const tabId = await getActiveTabId(tabIdOverride);
    if (!tabId) {
      return { id: "", ok: false, error: "No active tab available", errorCode: "NO_ACTIVE_TAB" };
    }
    if (!sessionId || !allowTabAccess(tabId, sessionId)) {
      return { id: "", ok: false, error: "Tab not owned by session", errorCode: "TAB_NOT_OWNED" };
    }
    const { client, port } = makeContentClient(tabId);
    try {
      const res = await client.scroll.mutate({
        deltaX: payload.deltaX,
        deltaY: payload.deltaY,
        selector: payload.selector,
        behavior: payload.behavior,
        block: payload.block
      });
      return { id: "", ok: res.ok !== false, error: res.error, errorCode: res.errorCode, data: res.data };
    } finally {
      port.disconnect();
    }
  }
  async function handleWaitForSelector(payload, tabIdOverride, sessionId) {
    const tabId = await getActiveTabId(tabIdOverride);
    if (!tabId) {
      return { id: "", ok: false, error: "No active tab available", errorCode: "NO_ACTIVE_TAB" };
    }
    if (!sessionId || !allowTabAccess(tabId, sessionId)) {
      return { id: "", ok: false, error: "Tab not owned by session", errorCode: "TAB_NOT_OWNED" };
    }
    const { client, port } = makeContentClient(tabId);
    try {
      const res = await client.waitForSelector.mutate({
        selector: payload.selector,
        timeoutMs: payload.timeoutMs
      });
      return { id: "", ok: res.ok !== false, error: res.error, errorCode: res.errorCode, data: res.data };
    } finally {
      port.disconnect();
    }
  }
  async function handleNavigate(payload, tabIdOverride, sessionId) {
    const tabId = await getActiveTabId(tabIdOverride);
    if (!tabId) {
      return { id: "", ok: false, error: "No active tab available", errorCode: "NO_ACTIVE_TAB" };
    }
    if (!sessionId || !allowTabAccess(tabId, sessionId)) {
      return { id: "", ok: false, error: "Tab not owned by session", errorCode: "TAB_NOT_OWNED" };
    }
    const { client, port } = makeContentClient(tabId);
    try {
      const res = await client.navigate.mutate({ url: payload.url });
      return { id: "", ok: res.ok !== false, error: res.error, errorCode: res.errorCode, data: res.data };
    } finally {
      port.disconnect();
    }
  }
  async function handleType(payload, tabIdOverride, sessionId) {
    const tabId = await getActiveTabId(tabIdOverride);
    if (!tabId) {
      return { id: "", ok: false, error: "No active tab available", errorCode: "NO_ACTIVE_TAB" };
    }
    if (!sessionId || !allowTabAccess(tabId, sessionId)) {
      return { id: "", ok: false, error: "Tab not owned by session", errorCode: "TAB_NOT_OWNED" };
    }
    const { client, port } = makeContentClient(tabId);
    try {
      const res = await client.type.mutate({
        selector: payload.selector,
        text: payload.text,
        pressEnter: payload.pressEnter
      });
      return { id: "", ok: res.ok !== false, error: res.error, errorCode: res.errorCode, data: res.data };
    } finally {
      port.disconnect();
    }
  }
  async function handleEnter(payload, tabIdOverride, sessionId) {
    const tabId = await getActiveTabId(tabIdOverride);
    if (!tabId) {
      return { id: "", ok: false, error: "No active tab available", errorCode: "NO_ACTIVE_TAB" };
    }
    if (!sessionId || !allowTabAccess(tabId, sessionId)) {
      return { id: "", ok: false, error: "Tab not owned by session", errorCode: "TAB_NOT_OWNED" };
    }
    const { client, port } = makeContentClient(tabId);
    try {
      const res = await client.enter.mutate({ selector: payload.selector, key: payload.key });
      return { id: "", ok: res.ok !== false, error: res.error, errorCode: res.errorCode, data: res.data };
    } finally {
      port.disconnect();
    }
  }
  async function handleSelect(payload, tabIdOverride, sessionId) {
    const tabId = await getActiveTabId(tabIdOverride);
    if (!tabId) {
      return { id: "", ok: false, error: "No active tab available", errorCode: "NO_ACTIVE_TAB" };
    }
    if (!sessionId || !allowTabAccess(tabId, sessionId)) {
      return { id: "", ok: false, error: "Tab not owned by session", errorCode: "TAB_NOT_OWNED" };
    }
    const { client, port } = makeContentClient(tabId);
    try {
      const res = await client.select.mutate({
        selector: payload.selector,
        value: payload.value,
        label: payload.label,
        index: payload.index,
        values: payload.values,
        labels: payload.labels,
        indices: payload.indices,
        matchMode: payload.matchMode,
        toggle: payload.toggle
      });
      return { id: "", ok: res.ok !== false, error: res.error, errorCode: res.errorCode, data: res.data };
    } finally {
      port.disconnect();
    }
  }
  async function handleScreenshot(payload, tabIdOverride, sessionId) {
    const tabId = await getActiveTabId(tabIdOverride);
    if (!tabId) {
      return { id: "", ok: false, error: "No active tab available", errorCode: "NO_ACTIVE_TAB" };
    }
    if (!sessionId || !allowTabAccess(tabId, sessionId)) {
      return { id: "", ok: false, error: "Tab not owned by session", errorCode: "TAB_NOT_OWNED" };
    }
    const { client, port } = makeContentClient(tabId);
    try {
      const prep = await client.screenshotPrep.mutate({
        selector: payload.selector,
        padding: payload.padding,
        format: payload.format,
        quality: payload.quality,
        maxWidth: payload.maxWidth,
        maxHeight: payload.maxHeight
      });
      if (!prep.ok) {
        return { id: "", ok: false, error: prep.error || "Screenshot prep failed", errorCode: prep.errorCode };
      }
      const rectData = prep.data;
      const tab = await chromeApi.tabs.get(tabId);
      const format = payload.format ?? "png";
      const quality = payload.quality ?? 0.92;
      const dataUrl = await chromeApi.tabs.captureVisibleTab(tab.windowId, {
        format,
        quality: format === "jpeg" ? Math.round(quality * 100) : void 0
      });
      const cropped = await cropDataUrl(
        dataUrl,
        rectData.rect,
        rectData.dpr,
        format,
        quality,
        payload.maxWidth,
        payload.maxHeight
      );
      const response = {
        selector: payload.selector || "viewport",
        dataUrl: cropped.dataUrl,
        width: cropped.width,
        height: cropped.height,
        format
      };
      return { id: "", ok: true, data: response };
    } catch (err) {
      return { id: "", ok: false, error: err?.message || "Screenshot failed", errorCode: "SCREENSHOT_FAILED" };
    } finally {
      port.disconnect();
    }
  }
  async function handleBack(tabIdOverride, sessionId) {
    const tabId = await getActiveTabId(tabIdOverride);
    if (!tabId) {
      return { id: "", ok: false, error: "No active tab available", errorCode: "NO_ACTIVE_TAB" };
    }
    if (!sessionId || !allowTabAccess(tabId, sessionId)) {
      return { id: "", ok: false, error: "Tab not owned by session", errorCode: "TAB_NOT_OWNED" };
    }
    const { client, port } = makeContentClient(tabId);
    try {
      const res = await client.back.mutate();
      return { id: "", ok: res.ok !== false, error: res.error, errorCode: res.errorCode, data: res.data };
    } finally {
      port.disconnect();
    }
  }
  async function handleForward(tabIdOverride, sessionId) {
    const tabId = await getActiveTabId(tabIdOverride);
    if (!tabId) {
      return { id: "", ok: false, error: "No active tab available", errorCode: "NO_ACTIVE_TAB" };
    }
    if (!sessionId || !allowTabAccess(tabId, sessionId)) {
      return { id: "", ok: false, error: "Tab not owned by session", errorCode: "TAB_NOT_OWNED" };
    }
    const { client, port } = makeContentClient(tabId);
    try {
      const res = await client.forward.mutate();
      return { id: "", ok: res.ok !== false, error: res.error, errorCode: res.errorCode, data: res.data };
    } finally {
      port.disconnect();
    }
  }
  async function handleHover(payload, tabIdOverride, sessionId) {
    const tabId = await getActiveTabId(tabIdOverride);
    if (!tabId) {
      return { id: "", ok: false, error: "No active tab available", errorCode: "NO_ACTIVE_TAB" };
    }
    if (!sessionId || !allowTabAccess(tabId, sessionId)) {
      return { id: "", ok: false, error: "Tab not owned by session", errorCode: "TAB_NOT_OWNED" };
    }
    const { client, port } = makeContentClient(tabId);
    try {
      const res = await client.hover.mutate({ selector: payload.selector });
      return { id: "", ok: res.ok !== false, error: res.error, errorCode: res.errorCode, data: res.data };
    } finally {
      port.disconnect();
    }
  }
  async function handleFind(payload, tabIdOverride, sessionId) {
    const tabId = await getActiveTabId(tabIdOverride);
    if (!tabId) {
      return { id: "", ok: false, error: "No active tab available", errorCode: "NO_ACTIVE_TAB" };
    }
    if (!sessionId || !allowTabAccess(tabId, sessionId)) {
      return { id: "", ok: false, error: "Tab not owned by session", errorCode: "TAB_NOT_OWNED" };
    }
    const { client, port } = makeContentClient(tabId);
    try {
      const res = await client.find.mutate({
        text: payload.text,
        limit: payload.limit,
        radius: payload.radius,
        caseSensitive: payload.caseSensitive
      });
      if (!res.ok) {
        return { id: "", ok: false, error: res.error || "Find failed", errorCode: res.errorCode };
      }
      return { id: "", ok: true, data: res.data };
    } finally {
      port.disconnect();
    }
  }
  async function handleCommand(cmd) {
    lastCommand = cmd;
    let resp = { id: cmd.id, ok: false, error: "Unknown command" };
    try {
      const handler = commandHandlers[cmd.type];
      if (!handler) {
        resp = { id: cmd.id, ok: false, error: `Unsupported command: ${cmd.type}`, errorCode: "UNSUPPORTED_COMMAND" };
      } else {
        const sessionId = requireSession(cmd);
        const res = await handler(cmd.payload, cmd.tabId ?? null, sessionId);
        resp = { ...res, id: cmd.id };
      }
    } catch (err) {
      resp = { id: cmd.id, ok: false, error: err?.message || "Command failed", errorCode: "COMMAND_FAILED" };
    }
    sendWS(resp);
  }
  const commandHandlers = {
    click: (payload, tabId, sessionId) => handleClick(payload, tabId, sessionId),
    snapshot: (payload, tabId, sessionId) => handleSnapshot(payload, tabId, sessionId),
    scroll: (payload, tabId, sessionId) => handleScroll(payload, tabId, sessionId),
    hover: (payload, tabId, sessionId) => handleHover(payload, tabId, sessionId),
    type: (payload, tabId, sessionId) => handleType(payload, tabId, sessionId),
    enter: (payload, tabId, sessionId) => handleEnter(payload, tabId, sessionId),
    select: (payload, tabId, sessionId) => handleSelect(payload, tabId, sessionId),
    back: (_payload, tabId, sessionId) => handleBack(tabId, sessionId),
    forward: (_payload, tabId, sessionId) => handleForward(tabId, sessionId),
    waitForSelector: (payload, tabId, sessionId) => handleWaitForSelector(payload, tabId, sessionId),
    find: (payload, tabId, sessionId) => handleFind(payload, tabId, sessionId),
    navigate: (payload, tabId, sessionId) => handleNavigate(payload, tabId, sessionId),
    screenshot: (payload, tabId, sessionId) => handleScreenshot(payload, tabId, sessionId),
    start_recording: (_payload, tabId, sessionId) => handleStartRecording(),
    stop_recording: (_payload, tabId, sessionId) => handleStopRecording(),
    get_recording: (_payload, tabId, sessionId) => handleGetRecording(),
    list_tabs: (_payload, tabId, sessionId) => handleListTabs(sessionId),
    open_tab: (payload, _tabId, sessionId) => handleOpenTab(payload, sessionId),
    close_tab: (payload, _tabId, sessionId) => handleCloseTab(payload, sessionId),
    claim_tab: (payload, _tabId, sessionId) => handleClaimTab(payload, sessionId),
    release_tab: (payload, _tabId, sessionId) => handleReleaseTab(payload, sessionId),
    set_tab_sharing: (payload, _tabId, sessionId) => handleSetTabSharing(payload, sessionId)
  };
  async function handleStartRecording() {
    await routerStartRecording();
    const data = { recording: true, count: recordedActions.length };
    return { id: "", ok: true, data };
  }
  async function handleStopRecording() {
    await routerStopRecording();
    const data = { recording: false, count: recordedActions.length };
    return { id: "", ok: true, data };
  }
  async function handleGetRecording() {
    return { id: "", ok: true, data: recordedActions };
  }
  async function handleListTabs(sessionId) {
    if (!sessionId) {
      return { id: "", ok: false, error: "Session id is required", errorCode: "SESSION_REQUIRED" };
    }
    const tabs = await listTabs();
    const scoped = tabs.filter((tab) => allowTabAccess(tab.id, sessionId));
    return { id: "", ok: true, data: scoped };
  }
  async function handleOpenTab(payload, sessionId) {
    if (!sessionId) {
      return { id: "", ok: false, error: "Session id is required", errorCode: "SESSION_REQUIRED" };
    }
    const tab = await chromeApi.tabs.create({
      url: payload.url || "about:blank",
      active: payload.active ?? true,
      pinned: payload.pinned ?? false
    });
    if (!tab?.id) {
      return { id: "", ok: false, error: "Failed to open tab", errorCode: "TAB_CREATE_FAILED" };
    }
    ensureOwner(tab.id, sessionId, "exclusive");
    const info = { id: tab.id, title: tab.title || "Untitled", url: tab.url || payload.url || "" };
    return { id: "", ok: true, data: info };
  }
  async function handleCloseTab(payload, sessionId) {
    if (!sessionId) {
      return { id: "", ok: false, error: "Session id is required", errorCode: "SESSION_REQUIRED" };
    }
    if (!payload?.tabId) {
      return { id: "", ok: false, error: "tabId is required", errorCode: "TAB_ID_REQUIRED" };
    }
    if (!allowTabAccess(payload.tabId, sessionId)) {
      return { id: "", ok: false, error: "Tab not owned by session", errorCode: "TAB_NOT_OWNED" };
    }
    await chromeApi.tabs.remove(payload.tabId);
    tabOwners.delete(payload.tabId);
    return { id: "", ok: true };
  }
  async function handleClaimTab(payload, sessionId) {
    if (!sessionId) {
      return { id: "", ok: false, error: "Session id is required", errorCode: "SESSION_REQUIRED" };
    }
    let tabId = payload?.tabId ?? 0;
    if (tabId === 0 && payload?.requireActive) {
      const activeTabs = await chromeApi.tabs.query({ active: true, lastFocusedWindow: true });
      tabId = activeTabs.find((t2) => t2.id != null)?.id ?? 0;
    }
    if (!tabId) {
      return { id: "", ok: false, error: "tabId is required", errorCode: "TAB_ID_REQUIRED" };
    }
    const tab = await chromeApi.tabs.get(tabId).catch(() => null);
    if (!tab?.id) {
      return { id: "", ok: false, error: "Tab not found", errorCode: "TAB_NOT_FOUND" };
    }
    if (payload.requireActive) {
      const activeTabs = await chromeApi.tabs.query({ active: true, lastFocusedWindow: true });
      const activeId = activeTabs.find((t2) => t2.id != null)?.id;
      if (activeId !== tab.id) {
        return { id: "", ok: false, error: "Tab is not active", errorCode: "TAB_NOT_ACTIVE" };
      }
    }
    const mode = payload.mode === "shared" ? "shared" : "exclusive";
    const ownership = getOwner(tab.id);
    if (!ownership && mode === "shared") {
      return { id: "", ok: false, error: "Tab must be owned before sharing", errorCode: "TAB_NOT_OWNED" };
    }
    if (ownership && !ownership.owners.has(sessionId)) {
      if (mode === "exclusive") {
        return { id: "", ok: false, error: "Tab owned by another session", errorCode: "TAB_NOT_OWNED" };
      }
      if (!ownership.allowShared) {
        return { id: "", ok: false, error: "Tab not shareable", errorCode: "TAB_NOT_SHAREABLE" };
      }
    }
    if (mode === "shared" && ownership) {
      ownership.allowShared = true;
      ownership.mode = "shared";
      for (const owner of ownership.owners) {
        ensureOwner(tab.id, owner, "shared");
      }
    }
    ensureOwner(tab.id, sessionId, mode);
    const info = { id: tab.id, title: tab.title || "Untitled", url: tab.url || "" };
    return { id: "", ok: true, data: info };
  }
  async function handleReleaseTab(payload, sessionId) {
    if (!sessionId) {
      return { id: "", ok: false, error: "Session id is required", errorCode: "SESSION_REQUIRED" };
    }
    if (!payload?.tabId) {
      return { id: "", ok: false, error: "tabId is required", errorCode: "TAB_ID_REQUIRED" };
    }
    releaseOwner(payload.tabId, sessionId);
    return { id: "", ok: true };
  }
  async function handleSetTabSharing(payload, sessionId) {
    if (!sessionId) {
      return { id: "", ok: false, error: "Session id is required", errorCode: "SESSION_REQUIRED" };
    }
    if (!payload?.tabId) {
      return { id: "", ok: false, error: "tabId is required", errorCode: "TAB_ID_REQUIRED" };
    }
    const ownership = getOwner(payload.tabId);
    if (!ownership || !ownership.owners.has(sessionId)) {
      return { id: "", ok: false, error: "Tab not owned by session", errorCode: "TAB_NOT_OWNED" };
    }
    if (!payload.allowShared && ownership.owners.size > 1) {
      return { id: "", ok: false, error: "Multiple owners exist", errorCode: "TAB_SHARED_ACTIVE" };
    }
    ownership.allowShared = payload.allowShared;
    if (!payload.allowShared) {
      ownership.mode = "exclusive";
    }
    return { id: "", ok: true };
  }
  async function routerStartRecording() {
    recording = true;
    const tabs = await chromeApi.tabs.query({});
    for (const tab of tabs) {
      if (tab.id) {
        chromeApi.tabs.sendMessage(tab.id, { type: "recording:set", enabled: true }).catch(() => {
        });
      }
    }
  }
  async function routerStopRecording() {
    recording = false;
    const tabs = await chromeApi.tabs.query({});
    for (const tab of tabs) {
      if (tab.id) {
        chromeApi.tabs.sendMessage(tab.id, { type: "recording:set", enabled: false }).catch(() => {
        });
      }
    }
  }
  async function cropDataUrl(dataUrl, rect, dpr, format, quality, maxWidth, maxHeight) {
    if (typeof OffscreenCanvas === "undefined") {
      throw new Error("OffscreenCanvas is not available");
    }
    const blob = await (await fetch(dataUrl)).blob();
    const bitmap = await createImageBitmap(blob);
    let sx = Math.max(0, rect.x * dpr);
    let sy = Math.max(0, rect.y * dpr);
    let sw = Math.max(1, rect.width * dpr);
    let sh = Math.max(1, rect.height * dpr);
    if (sx + sw > bitmap.width) sw = bitmap.width - sx;
    if (sy + sh > bitmap.height) sh = bitmap.height - sy;
    if (sw <= 0 || sh <= 0) {
      throw new Error("Crop bounds invalid");
    }
    let outW = sw;
    let outH = sh;
    const scale = computeScale(outW, outH, maxWidth, maxHeight);
    outW = Math.max(1, Math.round(outW * scale));
    outH = Math.max(1, Math.round(outH * scale));
    const canvas = new OffscreenCanvas(outW, outH);
    const ctx = canvas.getContext("2d");
    if (!ctx) throw new Error("Canvas not available");
    ctx.drawImage(bitmap, sx, sy, sw, sh, 0, 0, outW, outH);
    const mime = format === "jpeg" ? "image/jpeg" : "image/png";
    const blobOut = await canvas.convertToBlob({ type: mime, quality: format === "jpeg" ? quality : void 0 });
    const outUrl = await blobToDataUrl(blobOut);
    return { dataUrl: outUrl, width: outW, height: outH };
  }
  function computeScale(w, h, maxW, maxH) {
    let scale = 1;
    if (maxW && w > maxW) {
      scale = Math.min(scale, maxW / w);
    }
    if (maxH && h > maxH) {
      scale = Math.min(scale, maxH / h);
    }
    return scale;
  }
  async function blobToDataUrl(blob) {
    return await new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onerror = () => reject(new Error("Failed to read blob"));
      reader.onload = () => resolve(reader.result);
      reader.readAsDataURL(blob);
    });
  }
  function sendWS(resp) {
    if (!ws$1 || ws$1.readyState !== WebSocket.OPEN) return;
    ws$1.send(JSON.stringify(resp));
  }
  function connect(url) {
    if (ws$1) ws$1.close();
    wsUrl = url;
    ws$1 = new WebSocket(url);
    const sessionIds = /* @__PURE__ */ new Set();
    ws$1.onopen = () => {
      wsConnected = true;
      lastError = null;
    };
    ws$1.onclose = () => {
      wsConnected = false;
      for (const sessionId of sessionIds) {
        releaseSession(sessionId);
      }
    };
    ws$1.onerror = () => {
      lastError = "WebSocket error";
    };
    ws$1.onmessage = (event) => {
      try {
        const cmd = JSON.parse(event.data);
        if (cmd?.id && cmd?.type) {
          if (cmd.sessionId) sessionIds.add(cmd.sessionId);
          void handleCommand(cmd);
        }
      } catch (err) {
        lastError = err?.message || "Invalid message";
      }
    };
  }
  function disconnect() {
    if (ws$1) {
      ws$1.close();
      ws$1 = null;
    }
    wsConnected = false;
  }
  const router = createBackgroundRouter({
    getState: () => ({
      wsUrl,
      wsConnected,
      lastError,
      lastCommand,
      lastSnapshot,
      targetTabId,
      recording,
      recordingCount: recordedActions.length
    }),
    connect,
    disconnect,
    sendClick: (selector) => handleClick({ selector }),
    sendSnapshot: (payload) => handleSnapshot(payload),
    listTabs: () => listTabs(),
    listOwnedTabs: () => listOwnedTabs(),
    setTargetTab: (tabId) => {
      targetTabId = tabId;
    },
    startRecording: async () => {
      await routerStartRecording();
    },
    stopRecording: async () => {
      await routerStopRecording();
    },
    clearRecording: () => {
      recordedActions = [];
    },
    getRecording: () => recordedActions
  });
  const safeCreateChromeHandler = () => {
    try {
      adapterExports.createChromeHandler({
        router,
        onError: ({ error }) => {
          lastError = error.message;
        },
        chrome: chromeApi
      });
    } catch (err) {
      const message = err instanceof Error ? err.message : String(err);
      if (message.includes("not implemented")) {
        console.warn("Skipping chrome handler creation: runtime onConnect not implemented");
        return;
      }
      throw err;
    }
  };
  const definition = defineBackground(() => {
    chromeApi.sidePanel?.setPanelBehavior?.({ openPanelOnActionClick: true }).catch(() => {
    });
    chromeApi.runtime.onMessage.addListener(handleRuntimeMessage);
    chromeApi.tabs.onRemoved.addListener((tabId) => {
      tabOwners.delete(tabId);
      for (const [sessionId, set] of sessionTabs) {
        if (set.has(tabId)) {
          removeSessionTab(sessionId, tabId);
        }
      }
    });
    safeCreateChromeHandler();
  });
  function initPlugins() {
  }
  var _MatchPattern = class {
    constructor(matchPattern) {
      if (matchPattern === "<all_urls>") {
        this.isAllUrls = true;
        this.protocolMatches = [..._MatchPattern.PROTOCOLS];
        this.hostnameMatch = "*";
        this.pathnameMatch = "*";
      } else {
        const groups = /(.*):\/\/(.*?)(\/.*)/.exec(matchPattern);
        if (groups == null)
          throw new InvalidMatchPattern(matchPattern, "Incorrect format");
        const [_, protocol, hostname, pathname] = groups;
        validateProtocol(matchPattern, protocol);
        validateHostname(matchPattern, hostname);
        this.protocolMatches = protocol === "*" ? ["http", "https"] : [protocol];
        this.hostnameMatch = hostname;
        this.pathnameMatch = pathname;
      }
    }
    includes(url) {
      if (this.isAllUrls)
        return true;
      const u = typeof url === "string" ? new URL(url) : url instanceof Location ? new URL(url.href) : url;
      return !!this.protocolMatches.find((protocol) => {
        if (protocol === "http")
          return this.isHttpMatch(u);
        if (protocol === "https")
          return this.isHttpsMatch(u);
        if (protocol === "file")
          return this.isFileMatch(u);
        if (protocol === "ftp")
          return this.isFtpMatch(u);
        if (protocol === "urn")
          return this.isUrnMatch(u);
      });
    }
    isHttpMatch(url) {
      return url.protocol === "http:" && this.isHostPathMatch(url);
    }
    isHttpsMatch(url) {
      return url.protocol === "https:" && this.isHostPathMatch(url);
    }
    isHostPathMatch(url) {
      if (!this.hostnameMatch || !this.pathnameMatch)
        return false;
      const hostnameMatchRegexs = [
        this.convertPatternToRegex(this.hostnameMatch),
        this.convertPatternToRegex(this.hostnameMatch.replace(/^\*\./, ""))
      ];
      const pathnameMatchRegex = this.convertPatternToRegex(this.pathnameMatch);
      return !!hostnameMatchRegexs.find((regex) => regex.test(url.hostname)) && pathnameMatchRegex.test(url.pathname);
    }
    isFileMatch(url) {
      throw Error("Not implemented: file:// pattern matching. Open a PR to add support");
    }
    isFtpMatch(url) {
      throw Error("Not implemented: ftp:// pattern matching. Open a PR to add support");
    }
    isUrnMatch(url) {
      throw Error("Not implemented: urn:// pattern matching. Open a PR to add support");
    }
    convertPatternToRegex(pattern) {
      const escaped = this.escapeForRegex(pattern);
      const starsReplaced = escaped.replace(/\\\*/g, ".*");
      return RegExp(`^${starsReplaced}$`);
    }
    escapeForRegex(string) {
      return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }
  };
  var MatchPattern = _MatchPattern;
  MatchPattern.PROTOCOLS = ["http", "https", "file", "ftp", "urn"];
  var InvalidMatchPattern = class extends Error {
    constructor(matchPattern, reason) {
      super(`Invalid match pattern "${matchPattern}": ${reason}`);
    }
  };
  function validateProtocol(matchPattern, protocol) {
    if (!MatchPattern.PROTOCOLS.includes(protocol) && protocol !== "*")
      throw new InvalidMatchPattern(
        matchPattern,
        `${protocol} not a valid protocol (${MatchPattern.PROTOCOLS.join(", ")})`
      );
  }
  function validateHostname(matchPattern, hostname) {
    if (hostname.includes(":"))
      throw new InvalidMatchPattern(matchPattern, `Hostname cannot include a port`);
    if (hostname.includes("*") && hostname.length > 1 && !hostname.startsWith("*."))
      throw new InvalidMatchPattern(
        matchPattern,
        `If using a wildcard (*), it must go at the start of the hostname`
      );
  }
  function print(method, ...args) {
    if (typeof args[0] === "string") {
      const message = args.shift();
      method(`[wxt] ${message}`, ...args);
    } else {
      method("[wxt]", ...args);
    }
  }
  const logger = {
    debug: (...args) => print(console.debug, ...args),
    log: (...args) => print(console.log, ...args),
    warn: (...args) => print(console.warn, ...args),
    error: (...args) => print(console.error, ...args)
  };
  let ws;
  function getDevServerWebSocket() {
    if (ws == null) {
      const serverUrl = "ws://localhost:3000";
      logger.debug("Connecting to dev server @", serverUrl);
      ws = new WebSocket(serverUrl, "vite-hmr");
      ws.addWxtEventListener = ws.addEventListener.bind(ws);
      ws.sendCustom = (event, payload) => ws?.send(JSON.stringify({ type: "custom", event, payload }));
      ws.addEventListener("open", () => {
        logger.debug("Connected to dev server");
      });
      ws.addEventListener("close", () => {
        logger.debug("Disconnected from dev server");
      });
      ws.addEventListener("error", (event) => {
        logger.error("Failed to connect to dev server", event);
      });
      ws.addEventListener("message", (e) => {
        try {
          const message = JSON.parse(e.data);
          if (message.type === "custom") {
            ws?.dispatchEvent(
              new CustomEvent(message.event, { detail: message.data })
            );
          }
        } catch (err) {
          logger.error("Failed to handle message", err);
        }
      });
    }
    return ws;
  }
  function keepServiceWorkerAlive() {
    setInterval(async () => {
      await browser.runtime.getPlatformInfo();
    }, 5e3);
  }
  function reloadContentScript(payload) {
    const manifest = browser.runtime.getManifest();
    if (manifest.manifest_version == 2) {
      void reloadContentScriptMv2();
    } else {
      void reloadContentScriptMv3(payload);
    }
  }
  async function reloadContentScriptMv3({
    registration,
    contentScript
  }) {
    if (registration === "runtime") {
      await reloadRuntimeContentScriptMv3(contentScript);
    } else {
      await reloadManifestContentScriptMv3(contentScript);
    }
  }
  async function reloadManifestContentScriptMv3(contentScript) {
    const id = `wxt:${contentScript.js[0]}`;
    logger.log("Reloading content script:", contentScript);
    const registered = await browser.scripting.getRegisteredContentScripts();
    logger.debug("Existing scripts:", registered);
    const existing = registered.find((cs) => cs.id === id);
    if (existing) {
      logger.debug("Updating content script", existing);
      await browser.scripting.updateContentScripts([
        {
          ...contentScript,
          id,
          css: contentScript.css ?? []
        }
      ]);
    } else {
      logger.debug("Registering new content script...");
      await browser.scripting.registerContentScripts([
        {
          ...contentScript,
          id,
          css: contentScript.css ?? []
        }
      ]);
    }
    await reloadTabsForContentScript(contentScript);
  }
  async function reloadRuntimeContentScriptMv3(contentScript) {
    logger.log("Reloading content script:", contentScript);
    const registered = await browser.scripting.getRegisteredContentScripts();
    logger.debug("Existing scripts:", registered);
    const matches = registered.filter((cs) => {
      const hasJs = contentScript.js?.find((js) => cs.js?.includes(js));
      const hasCss = contentScript.css?.find((css) => cs.css?.includes(css));
      return hasJs || hasCss;
    });
    if (matches.length === 0) {
      logger.log(
        "Content script is not registered yet, nothing to reload",
        contentScript
      );
      return;
    }
    await browser.scripting.updateContentScripts(matches);
    await reloadTabsForContentScript(contentScript);
  }
  async function reloadTabsForContentScript(contentScript) {
    const allTabs = await browser.tabs.query({});
    const matchPatterns = contentScript.matches.map(
      (match) => new MatchPattern(match)
    );
    const matchingTabs = allTabs.filter((tab) => {
      const url = tab.url;
      if (!url) return false;
      return !!matchPatterns.find((pattern) => pattern.includes(url));
    });
    await Promise.all(
      matchingTabs.map(async (tab) => {
        try {
          await browser.tabs.reload(tab.id);
        } catch (err) {
          logger.warn("Failed to reload tab:", err);
        }
      })
    );
  }
  async function reloadContentScriptMv2(_payload) {
    throw Error("TODO: reloadContentScriptMv2");
  }
  {
    try {
      const ws2 = getDevServerWebSocket();
      ws2.addWxtEventListener("wxt:reload-extension", () => {
        browser.runtime.reload();
      });
      ws2.addWxtEventListener("wxt:reload-content-script", (event) => {
        reloadContentScript(event.detail);
      });
      if (true) {
        ws2.addEventListener(
          "open",
          () => ws2.sendCustom("wxt:background-initialized")
        );
        keepServiceWorkerAlive();
      }
    } catch (err) {
      logger.error("Failed to setup web socket connection with dev server", err);
    }
    browser.commands.onCommand.addListener((command) => {
      if (command === "wxt:reload-extension") {
        browser.runtime.reload();
      }
    });
  }
  let result;
  try {
    initPlugins();
    result = definition.main();
    if (result instanceof Promise) {
      console.warn(
        "The background's main() function return a promise, but it must be synchronous"
      );
    }
  } catch (err) {
    logger.error("The background crashed on startup!");
    throw err;
  }
  const result$1 = result;
  return result$1;
})();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFja2dyb3VuZC5qcyIsInNvdXJjZXMiOlsiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0B3eHQtZGV2K2Jyb3dzZXJAMC4xLjMyL25vZGVfbW9kdWxlcy9Ad3h0LWRldi9icm93c2VyL3NyYy9pbmRleC5tanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vd3h0QDAuMjAuMTNfQHR5cGVzK25vZGVAMjUuMC4xMF9qaXRpQDEuMjEuN19yb2xsdXBANC41Ni4wL25vZGVfbW9kdWxlcy93eHQvZGlzdC9icm93c2VyLm1qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS93eHRAMC4yMC4xM19AdHlwZXMrbm9kZUAyNS4wLjEwX2ppdGlAMS4yMS43X3JvbGx1cEA0LjU2LjAvbm9kZV9tb2R1bGVzL3d4dC9kaXN0L3V0aWxzL2RlZmluZS1iYWNrZ3JvdW5kLm1qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AdHJwYytzZXJ2ZXJAMTAuNDUuNC9ub2RlX21vZHVsZXMvQHRycGMvc2VydmVyL2Rpc3QvZ2V0Q2F1c2VGcm9tVW5rbm93bi1kNTM1MjY0YS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AdHJwYytzZXJ2ZXJAMTAuNDUuNC9ub2RlX21vZHVsZXMvQHRycGMvc2VydmVyL2Rpc3QvVFJQQ0Vycm9yLWNhMzdiZjFhLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0B0cnBjK3NlcnZlckAxMC40NS40L25vZGVfbW9kdWxlcy9AdHJwYy9zZXJ2ZXIvZGlzdC9jb2Rlcy04N2Y2ODI0Yi5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AdHJwYytzZXJ2ZXJAMTAuNDUuNC9ub2RlX21vZHVsZXMvQHRycGMvc2VydmVyL2Rpc3QvaW5kZXgtNzg0ZmY2NDcuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHRycGMrc2VydmVyQDEwLjQ1LjQvbm9kZV9tb2R1bGVzL0B0cnBjL3NlcnZlci9kaXN0L2NvbmZpZy0xOTRiZGQ0My5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AdHJwYytzZXJ2ZXJAMTAuNDUuNC9ub2RlX21vZHVsZXMvQHRycGMvc2VydmVyL2Rpc3QvaW5kZXguanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHRycGMrc2VydmVyQDEwLjQ1LjQvbm9kZV9tb2R1bGVzL0B0cnBjL3NlcnZlci9kaXN0L29ic2VydmFibGUtNDY0MTE2YWMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHRycGMrc2VydmVyQDEwLjQ1LjQvbm9kZV9tb2R1bGVzL0B0cnBjL3NlcnZlci9kaXN0L29ic2VydmFibGUvaW5kZXguanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHRycGMrc2VydmVyQDEwLjQ1LjQvbm9kZV9tb2R1bGVzL0B0cnBjL3NlcnZlci9kaXN0L3RyYW5zZm9ybVRSUENSZXNwb25zZS1lNjVmMzRlOS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AdHJwYytzZXJ2ZXJAMTAuNDUuNC9ub2RlX21vZHVsZXMvQHRycGMvc2VydmVyL2Rpc3Qvc2hhcmVkL2luZGV4LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3RycGMtYnJvd3NlckAxLjQuNF9AdHJwYytjbGllbnRAMTAuNDUuNF9AdHJwYytzZXJ2ZXJAMTAuNDUuNF9fQHRycGMrc2VydmVyQDEwLjQ1LjQvbm9kZV9tb2R1bGVzL3RycGMtYnJvd3Nlci9zaGFyZWQvdHJwY01lc3NhZ2UuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vdHJwYy1icm93c2VyQDEuNC40X0B0cnBjK2NsaWVudEAxMC40NS40X0B0cnBjK3NlcnZlckAxMC40NS40X19AdHJwYytzZXJ2ZXJAMTAuNDUuNC9ub2RlX21vZHVsZXMvdHJwYy1icm93c2VyL2FkYXB0ZXIvZXJyb3JzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3RycGMtYnJvd3NlckAxLjQuNF9AdHJwYytjbGllbnRAMTAuNDUuNF9AdHJwYytzZXJ2ZXJAMTAuNDUuNF9fQHRycGMrc2VydmVyQDEwLjQ1LjQvbm9kZV9tb2R1bGVzL3RycGMtYnJvd3Nlci9hZGFwdGVyL2Nocm9tZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS90cnBjLWJyb3dzZXJAMS40LjRfQHRycGMrY2xpZW50QDEwLjQ1LjRfQHRycGMrc2VydmVyQDEwLjQ1LjRfX0B0cnBjK3NlcnZlckAxMC40NS40L25vZGVfbW9kdWxlcy90cnBjLWJyb3dzZXIvc2hhcmVkL2NvbnN0YW50cy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS90cnBjLWJyb3dzZXJAMS40LjRfQHRycGMrY2xpZW50QDEwLjQ1LjRfQHRycGMrc2VydmVyQDEwLjQ1LjRfX0B0cnBjK3NlcnZlckAxMC40NS40L25vZGVfbW9kdWxlcy90cnBjLWJyb3dzZXIvYWRhcHRlci93aW5kb3cuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vdHJwYy1icm93c2VyQDEuNC40X0B0cnBjK2NsaWVudEAxMC40NS40X0B0cnBjK3NlcnZlckAxMC40NS40X19AdHJwYytzZXJ2ZXJAMTAuNDUuNC9ub2RlX21vZHVsZXMvdHJwYy1icm93c2VyL2FkYXB0ZXIvaW5kZXguanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHRycGMrY2xpZW50QDEwLjQ1LjRfQHRycGMrc2VydmVyQDEwLjQ1LjQvbm9kZV9tb2R1bGVzL0B0cnBjL2NsaWVudC9kaXN0L3NwbGl0TGluay1mMjllODRiZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AdHJwYytjbGllbnRAMTAuNDUuNF9AdHJwYytzZXJ2ZXJAMTAuNDUuNC9ub2RlX21vZHVsZXMvQHRycGMvY2xpZW50L2Rpc3QvdHJhbnNmb3JtUmVzdWx0LWRmY2U4ZjE1LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0B0cnBjK2NsaWVudEAxMC40NS40X0B0cnBjK3NlcnZlckAxMC40NS40L25vZGVfbW9kdWxlcy9AdHJwYy9jbGllbnQvZGlzdC9UUlBDQ2xpZW50RXJyb3ItN2UwYzMxZTcuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHRycGMrY2xpZW50QDEwLjQ1LjRfQHRycGMrc2VydmVyQDEwLjQ1LjQvbm9kZV9tb2R1bGVzL0B0cnBjL2NsaWVudC9kaXN0L2h0dHBVdGlscy00NDI5ZjM2ZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AdHJwYytjbGllbnRAMTAuNDUuNF9AdHJwYytzZXJ2ZXJAMTAuNDUuNC9ub2RlX21vZHVsZXMvQHRycGMvY2xpZW50L2Rpc3QvaHR0cEJhdGNoTGluay02YjViYTYzOC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AdHJwYytjbGllbnRAMTAuNDUuNF9AdHJwYytzZXJ2ZXJAMTAuNDUuNC9ub2RlX21vZHVsZXMvQHRycGMvY2xpZW50L2Rpc3QvbGlua3MvaHR0cExpbmsuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHRycGMrY2xpZW50QDEwLjQ1LjRfQHRycGMrc2VydmVyQDEwLjQ1LjQvbm9kZV9tb2R1bGVzL0B0cnBjL2NsaWVudC9kaXN0L2xpbmtzL2xvZ2dlckxpbmsuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHRycGMrY2xpZW50QDEwLjQ1LjRfQHRycGMrc2VydmVyQDEwLjQ1LjQvbm9kZV9tb2R1bGVzL0B0cnBjL2NsaWVudC9kaXN0L2xpbmtzL3dzTGluay5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AdHJwYytjbGllbnRAMTAuNDUuNF9AdHJwYytzZXJ2ZXJAMTAuNDUuNC9ub2RlX21vZHVsZXMvQHRycGMvY2xpZW50L2Rpc3QvaW5kZXguanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vdHJwYy1icm93c2VyQDEuNC40X0B0cnBjK2NsaWVudEAxMC40NS40X0B0cnBjK3NlcnZlckAxMC40NS40X19AdHJwYytzZXJ2ZXJAMTAuNDUuNC9ub2RlX21vZHVsZXMvdHJwYy1icm93c2VyL2xpbmsvaW50ZXJuYWwvYmFzZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS90cnBjLWJyb3dzZXJAMS40LjRfQHRycGMrY2xpZW50QDEwLjQ1LjRfQHRycGMrc2VydmVyQDEwLjQ1LjRfX0B0cnBjK3NlcnZlckAxMC40NS40L25vZGVfbW9kdWxlcy90cnBjLWJyb3dzZXIvbGluay9jaHJvbWUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vdHJwYy1icm93c2VyQDEuNC40X0B0cnBjK2NsaWVudEAxMC40NS40X0B0cnBjK3NlcnZlckAxMC40NS40X19AdHJwYytzZXJ2ZXJAMTAuNDUuNC9ub2RlX21vZHVsZXMvdHJwYy1icm93c2VyL2xpbmsvd2luZG93LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3RycGMtYnJvd3NlckAxLjQuNF9AdHJwYytjbGllbnRAMTAuNDUuNF9AdHJwYytzZXJ2ZXJAMTAuNDUuNF9fQHRycGMrc2VydmVyQDEwLjQ1LjQvbm9kZV9tb2R1bGVzL3RycGMtYnJvd3Nlci9saW5rL3BvcHVwLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3RycGMtYnJvd3NlckAxLjQuNF9AdHJwYytjbGllbnRAMTAuNDUuNF9AdHJwYytzZXJ2ZXJAMTAuNDUuNF9fQHRycGMrc2VydmVyQDEwLjQ1LjQvbm9kZV9tb2R1bGVzL3RycGMtYnJvd3Nlci9saW5rL2luZGV4LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0B0cnBjK3NlcnZlckAxMC40NS40L25vZGVfbW9kdWxlcy9AdHJwYy9zZXJ2ZXIvZGlzdC9vYnNlcnZhYmxlLWFkZTFiYWQ4Lm1qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AdHJwYytzZXJ2ZXJAMTAuNDUuNC9ub2RlX21vZHVsZXMvQHRycGMvc2VydmVyL2Rpc3Qvb2JzZXJ2YWJsZS9pbmRleC5tanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHRycGMrY2xpZW50QDEwLjQ1LjRfQHRycGMrc2VydmVyQDEwLjQ1LjQvbm9kZV9tb2R1bGVzL0B0cnBjL2NsaWVudC9kaXN0L3NwbGl0TGluay00Yzc1ZjdiZS5tanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHRycGMrc2VydmVyQDEwLjQ1LjQvbm9kZV9tb2R1bGVzL0B0cnBjL3NlcnZlci9kaXN0L2NvZGVzLWM5MjRjM2RiLm1qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AdHJwYytzZXJ2ZXJAMTAuNDUuNC9ub2RlX21vZHVsZXMvQHRycGMvc2VydmVyL2Rpc3QvaW5kZXgtZjkxZDcyMGMubWpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0B0cnBjK3NlcnZlckAxMC40NS40L25vZGVfbW9kdWxlcy9AdHJwYy9zZXJ2ZXIvZGlzdC9nZXRDYXVzZUZyb21Vbmtub3duLTJkNjY0MTRhLm1qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AdHJwYytjbGllbnRAMTAuNDUuNF9AdHJwYytzZXJ2ZXJAMTAuNDUuNC9ub2RlX21vZHVsZXMvQHRycGMvY2xpZW50L2Rpc3QvdHJhbnNmb3JtUmVzdWx0LWFjZTg2NGI4Lm1qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AdHJwYytjbGllbnRAMTAuNDUuNF9AdHJwYytzZXJ2ZXJAMTAuNDUuNC9ub2RlX21vZHVsZXMvQHRycGMvY2xpZW50L2Rpc3QvVFJQQ0NsaWVudEVycm9yLTM4ZjlhMzJhLm1qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AdHJwYytjbGllbnRAMTAuNDUuNF9AdHJwYytzZXJ2ZXJAMTAuNDUuNC9ub2RlX21vZHVsZXMvQHRycGMvY2xpZW50L2Rpc3QvaW5kZXgubWpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0B0cnBjK3NlcnZlckAxMC40NS40L25vZGVfbW9kdWxlcy9AdHJwYy9zZXJ2ZXIvZGlzdC9UUlBDRXJyb3ItOThkNDQ3NTgubWpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0B0cnBjK3NlcnZlckAxMC40NS40L25vZGVfbW9kdWxlcy9AdHJwYy9zZXJ2ZXIvZGlzdC9jb25maWctZDVmZGJkMzkubWpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0B0cnBjK3NlcnZlckAxMC40NS40L25vZGVfbW9kdWxlcy9AdHJwYy9zZXJ2ZXIvZGlzdC9pbmRleC5tanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vem9kQDMuMjUuNzYvbm9kZV9tb2R1bGVzL3pvZC92My9oZWxwZXJzL3V0aWwuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vem9kQDMuMjUuNzYvbm9kZV9tb2R1bGVzL3pvZC92My9ab2RFcnJvci5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS96b2RAMy4yNS43Ni9ub2RlX21vZHVsZXMvem9kL3YzL2xvY2FsZXMvZW4uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vem9kQDMuMjUuNzYvbm9kZV9tb2R1bGVzL3pvZC92My9lcnJvcnMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vem9kQDMuMjUuNzYvbm9kZV9tb2R1bGVzL3pvZC92My9oZWxwZXJzL3BhcnNlVXRpbC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS96b2RAMy4yNS43Ni9ub2RlX21vZHVsZXMvem9kL3YzL2hlbHBlcnMvZXJyb3JVdGlsLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3pvZEAzLjI1Ljc2L25vZGVfbW9kdWxlcy96b2QvdjMvdHlwZXMuanMiLCIuLi8uLi9lbnRyeXBvaW50cy9zaGFyZWQvYmFja2dyb3VuZFJvdXRlci50cyIsIi4uLy4uL2VudHJ5cG9pbnRzL2JhY2tncm91bmQudHMiLCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHdlYmV4dC1jb3JlK21hdGNoLXBhdHRlcm5zQDEuMC4zL25vZGVfbW9kdWxlcy9Ad2ViZXh0LWNvcmUvbWF0Y2gtcGF0dGVybnMvbGliL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vICNyZWdpb24gc25pcHBldFxuZXhwb3J0IGNvbnN0IGJyb3dzZXIgPSBnbG9iYWxUaGlzLmJyb3dzZXI/LnJ1bnRpbWU/LmlkXG4gID8gZ2xvYmFsVGhpcy5icm93c2VyXG4gIDogZ2xvYmFsVGhpcy5jaHJvbWU7XG4vLyAjZW5kcmVnaW9uIHNuaXBwZXRcbiIsImltcG9ydCB7IGJyb3dzZXIgYXMgX2Jyb3dzZXIgfSBmcm9tIFwiQHd4dC1kZXYvYnJvd3NlclwiO1xuZXhwb3J0IGNvbnN0IGJyb3dzZXIgPSBfYnJvd3NlcjtcbmV4cG9ydCB7fTtcbiIsImV4cG9ydCBmdW5jdGlvbiBkZWZpbmVCYWNrZ3JvdW5kKGFyZykge1xuICBpZiAoYXJnID09IG51bGwgfHwgdHlwZW9mIGFyZyA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4geyBtYWluOiBhcmcgfTtcbiAgcmV0dXJuIGFyZztcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqLyBmdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICAgIC8vIGNoZWNrIHRoYXQgdmFsdWUgaXMgb2JqZWN0XG4gICAgcmV0dXJuICEhdmFsdWUgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCc7XG59XG5cbmNsYXNzIFVua25vd25DYXVzZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xufVxuZnVuY3Rpb24gZ2V0Q2F1c2VGcm9tVW5rbm93bihjYXVzZSkge1xuICAgIGlmIChjYXVzZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHJldHVybiBjYXVzZTtcbiAgICB9XG4gICAgY29uc3QgdHlwZSA9IHR5cGVvZiBjYXVzZTtcbiAgICBpZiAodHlwZSA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCBjYXVzZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvLyBQcmltaXRpdmUgdHlwZXMganVzdCBnZXQgd3JhcHBlZCBpbiBhbiBlcnJvclxuICAgIGlmICh0eXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gbmV3IEVycm9yKFN0cmluZyhjYXVzZSkpO1xuICAgIH1cbiAgICAvLyBJZiBpdCdzIGFuIG9iamVjdCwgd2UnbGwgY3JlYXRlIGEgc3ludGhldGljIGVycm9yXG4gICAgaWYgKGlzT2JqZWN0KGNhdXNlKSkge1xuICAgICAgICBjb25zdCBlcnIgPSBuZXcgVW5rbm93bkNhdXNlRXJyb3IoKTtcbiAgICAgICAgZm9yKGNvbnN0IGtleSBpbiBjYXVzZSl7XG4gICAgICAgICAgICBlcnJba2V5XSA9IGNhdXNlW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVycjtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0cy5nZXRDYXVzZUZyb21Vbmtub3duID0gZ2V0Q2F1c2VGcm9tVW5rbm93bjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGdldENhdXNlRnJvbVVua25vd24gPSByZXF1aXJlKCcuL2dldENhdXNlRnJvbVVua25vd24tZDUzNTI2NGEuanMnKTtcblxuZnVuY3Rpb24gZ2V0VFJQQ0Vycm9yRnJvbVVua25vd24oY2F1c2UpIHtcbiAgICBpZiAoY2F1c2UgaW5zdGFuY2VvZiBUUlBDRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGNhdXNlO1xuICAgIH1cbiAgICBpZiAoY2F1c2UgaW5zdGFuY2VvZiBFcnJvciAmJiBjYXVzZS5uYW1lID09PSAnVFJQQ0Vycm9yJykge1xuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdHJwYy90cnBjL3B1bGwvNDg0OFxuICAgICAgICByZXR1cm4gY2F1c2U7XG4gICAgfVxuICAgIGNvbnN0IHRycGNFcnJvciA9IG5ldyBUUlBDRXJyb3Ioe1xuICAgICAgICBjb2RlOiAnSU5URVJOQUxfU0VSVkVSX0VSUk9SJyxcbiAgICAgICAgY2F1c2VcbiAgICB9KTtcbiAgICAvLyBJbmhlcml0IHN0YWNrIGZyb20gZXJyb3JcbiAgICBpZiAoY2F1c2UgaW5zdGFuY2VvZiBFcnJvciAmJiBjYXVzZS5zdGFjaykge1xuICAgICAgICB0cnBjRXJyb3Iuc3RhY2sgPSBjYXVzZS5zdGFjaztcbiAgICB9XG4gICAgcmV0dXJuIHRycGNFcnJvcjtcbn1cbmNsYXNzIFRSUENFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRzKXtcbiAgICAgICAgY29uc3QgY2F1c2UgPSBnZXRDYXVzZUZyb21Vbmtub3duLmdldENhdXNlRnJvbVVua25vd24ob3B0cy5jYXVzZSk7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBvcHRzLm1lc3NhZ2UgPz8gY2F1c2U/Lm1lc3NhZ2UgPz8gb3B0cy5jb2RlO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG4gICAgICAgIC8vIEB0cy1pZ25vcmUgaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtZXJyb3ItY2F1c2VcbiAgICAgICAgc3VwZXIobWVzc2FnZSwge1xuICAgICAgICAgICAgY2F1c2VcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY29kZSA9IG9wdHMuY29kZTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ1RSUENFcnJvcic7XG4gICAgICAgIGlmICghdGhpcy5jYXVzZSkge1xuICAgICAgICAgICAgLy8gPCBFUzIwMjIgLyA8IE5vZGUgMTYuOS4wIGNvbXBhdGFiaWxpdHlcbiAgICAgICAgICAgIHRoaXMuY2F1c2UgPSBjYXVzZTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0cy5UUlBDRXJyb3IgPSBUUlBDRXJyb3I7XG5leHBvcnRzLmdldFRSUENFcnJvckZyb21Vbmtub3duID0gZ2V0VFJQQ0Vycm9yRnJvbVVua25vd247XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQGludGVybmFsXG4gKi8gZnVuY3Rpb24gaW52ZXJ0KG9iaikge1xuICAgIGNvbnN0IG5ld09iaiA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgZm9yKGNvbnN0IGtleSBpbiBvYmope1xuICAgICAgICBjb25zdCB2ID0gb2JqW2tleV07XG4gICAgICAgIG5ld09ialt2XSA9IGtleTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld09iajtcbn1cblxuLy8gcmVmZXJlbmNlOiBodHRwczovL3d3dy5qc29ucnBjLm9yZy9zcGVjaWZpY2F0aW9uXG4vKipcbiAqIEpTT04tUlBDIDIuMCBFcnJvciBjb2Rlc1xuICpcbiAqIGAtMzIwMDBgIHRvIGAtMzIwOTlgIGFyZSByZXNlcnZlZCBmb3IgaW1wbGVtZW50YXRpb24tZGVmaW5lZCBzZXJ2ZXItZXJyb3JzLlxuICogRm9yIHRSUEMgd2UncmUgY29weWluZyB0aGUgbGFzdCBkaWdpdHMgb2YgSFRUUCA0WFggZXJyb3JzLlxuICovIGNvbnN0IFRSUENfRVJST1JfQ09ERVNfQllfS0VZID0ge1xuICAgIC8qKlxuICAgKiBJbnZhbGlkIEpTT04gd2FzIHJlY2VpdmVkIGJ5IHRoZSBzZXJ2ZXIuXG4gICAqIEFuIGVycm9yIG9jY3VycmVkIG9uIHRoZSBzZXJ2ZXIgd2hpbGUgcGFyc2luZyB0aGUgSlNPTiB0ZXh0LlxuICAgKi8gUEFSU0VfRVJST1I6IC0zMjcwMCxcbiAgICAvKipcbiAgICogVGhlIEpTT04gc2VudCBpcyBub3QgYSB2YWxpZCBSZXF1ZXN0IG9iamVjdC5cbiAgICovIEJBRF9SRVFVRVNUOiAtMzI2MDAsXG4gICAgLy8gSW50ZXJuYWwgSlNPTi1SUEMgZXJyb3JcbiAgICBJTlRFUk5BTF9TRVJWRVJfRVJST1I6IC0zMjYwMyxcbiAgICBOT1RfSU1QTEVNRU5URUQ6IC0zMjYwMyxcbiAgICAvLyBJbXBsZW1lbnRhdGlvbiBzcGVjaWZpYyBlcnJvcnNcbiAgICBVTkFVVEhPUklaRUQ6IC0zMjAwMSxcbiAgICBGT1JCSURERU46IC0zMjAwMyxcbiAgICBOT1RfRk9VTkQ6IC0zMjAwNCxcbiAgICBNRVRIT0RfTk9UX1NVUFBPUlRFRDogLTMyMDA1LFxuICAgIFRJTUVPVVQ6IC0zMjAwOCxcbiAgICBDT05GTElDVDogLTMyMDA5LFxuICAgIFBSRUNPTkRJVElPTl9GQUlMRUQ6IC0zMjAxMixcbiAgICBQQVlMT0FEX1RPT19MQVJHRTogLTMyMDEzLFxuICAgIFVOUFJPQ0VTU0FCTEVfQ09OVEVOVDogLTMyMDIyLFxuICAgIFRPT19NQU5ZX1JFUVVFU1RTOiAtMzIwMjksXG4gICAgQ0xJRU5UX0NMT1NFRF9SRVFVRVNUOiAtMzIwOTlcbn07XG5jb25zdCBUUlBDX0VSUk9SX0NPREVTX0JZX05VTUJFUiA9IGludmVydChUUlBDX0VSUk9SX0NPREVTX0JZX0tFWSk7XG5cbmV4cG9ydHMuVFJQQ19FUlJPUl9DT0RFU19CWV9LRVkgPSBUUlBDX0VSUk9SX0NPREVTX0JZX0tFWTtcbmV4cG9ydHMuVFJQQ19FUlJPUl9DT0RFU19CWV9OVU1CRVIgPSBUUlBDX0VSUk9SX0NPREVTX0JZX05VTUJFUjtcbmV4cG9ydHMuaW52ZXJ0ID0gaW52ZXJ0O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY29kZXMgPSByZXF1aXJlKCcuL2NvZGVzLTg3ZjY4MjRiLmpzJyk7XG5cbmNvbnN0IFRSUENfRVJST1JfQ09ERVNfQllfTlVNQkVSID0gY29kZXMuaW52ZXJ0KGNvZGVzLlRSUENfRVJST1JfQ09ERVNfQllfS0VZKTtcbmNvbnN0IEpTT05SUEMyX1RPX0hUVFBfQ09ERSA9IHtcbiAgICBQQVJTRV9FUlJPUjogNDAwLFxuICAgIEJBRF9SRVFVRVNUOiA0MDAsXG4gICAgVU5BVVRIT1JJWkVEOiA0MDEsXG4gICAgTk9UX0ZPVU5EOiA0MDQsXG4gICAgRk9SQklEREVOOiA0MDMsXG4gICAgTUVUSE9EX05PVF9TVVBQT1JURUQ6IDQwNSxcbiAgICBUSU1FT1VUOiA0MDgsXG4gICAgQ09ORkxJQ1Q6IDQwOSxcbiAgICBQUkVDT05ESVRJT05fRkFJTEVEOiA0MTIsXG4gICAgUEFZTE9BRF9UT09fTEFSR0U6IDQxMyxcbiAgICBVTlBST0NFU1NBQkxFX0NPTlRFTlQ6IDQyMixcbiAgICBUT09fTUFOWV9SRVFVRVNUUzogNDI5LFxuICAgIENMSUVOVF9DTE9TRURfUkVRVUVTVDogNDk5LFxuICAgIElOVEVSTkFMX1NFUlZFUl9FUlJPUjogNTAwLFxuICAgIE5PVF9JTVBMRU1FTlRFRDogNTAxXG59O1xuZnVuY3Rpb24gZ2V0U3RhdHVzQ29kZUZyb21LZXkoY29kZSkge1xuICAgIHJldHVybiBKU09OUlBDMl9UT19IVFRQX0NPREVbY29kZV0gPz8gNTAwO1xufVxuZnVuY3Rpb24gZ2V0SFRUUFN0YXR1c0NvZGUoanNvbikge1xuICAgIGNvbnN0IGFyciA9IEFycmF5LmlzQXJyYXkoanNvbikgPyBqc29uIDogW1xuICAgICAgICBqc29uXG4gICAgXTtcbiAgICBjb25zdCBodHRwU3RhdHVzZXMgPSBuZXcgU2V0KGFyci5tYXAoKHJlcyk9PntcbiAgICAgICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gcmVzLmVycm9yLmRhdGE7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGRhdGEuaHR0cFN0YXR1cyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YS5odHRwU3RhdHVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY29kZSA9IFRSUENfRVJST1JfQ09ERVNfQllfTlVNQkVSW3Jlcy5lcnJvci5jb2RlXTtcbiAgICAgICAgICAgIHJldHVybiBnZXRTdGF0dXNDb2RlRnJvbUtleShjb2RlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMjAwO1xuICAgIH0pKTtcbiAgICBpZiAoaHR0cFN0YXR1c2VzLnNpemUgIT09IDEpIHtcbiAgICAgICAgcmV0dXJuIDIwNztcbiAgICB9XG4gICAgY29uc3QgaHR0cFN0YXR1cyA9IGh0dHBTdGF0dXNlcy52YWx1ZXMoKS5uZXh0KCkudmFsdWU7XG4gICAgcmV0dXJuIGh0dHBTdGF0dXM7XG59XG5mdW5jdGlvbiBnZXRIVFRQU3RhdHVzQ29kZUZyb21FcnJvcihlcnJvcikge1xuICAgIHJldHVybiBnZXRTdGF0dXNDb2RlRnJvbUtleShlcnJvci5jb2RlKTtcbn1cblxuY29uc3Qgbm9vcCA9ICgpPT57XG4vLyBub29wXG59O1xuZnVuY3Rpb24gY3JlYXRlSW5uZXJQcm94eShjYWxsYmFjaywgcGF0aCkge1xuICAgIGNvbnN0IHByb3h5ID0gbmV3IFByb3h5KG5vb3AsIHtcbiAgICAgICAgZ2V0IChfb2JqLCBrZXkpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJyB8fCBrZXkgPT09ICd0aGVuJykge1xuICAgICAgICAgICAgICAgIC8vIHNwZWNpYWwgY2FzZSBmb3IgaWYgdGhlIHByb3h5IGlzIGFjY2lkZW50YWxseSB0cmVhdGVkXG4gICAgICAgICAgICAgICAgLy8gbGlrZSBhIFByb21pc2VMaWtlIChsaWtlIGluIGBQcm9taXNlLnJlc29sdmUocHJveHkpYClcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUlubmVyUHJveHkoY2FsbGJhY2ssIFtcbiAgICAgICAgICAgICAgICAuLi5wYXRoLFxuICAgICAgICAgICAgICAgIGtleVxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH0sXG4gICAgICAgIGFwcGx5IChfMSwgXzIsIGFyZ3MpIHtcbiAgICAgICAgICAgIGNvbnN0IGlzQXBwbHkgPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV0gPT09ICdhcHBseSc7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soe1xuICAgICAgICAgICAgICAgIGFyZ3M6IGlzQXBwbHkgPyBhcmdzLmxlbmd0aCA+PSAyID8gYXJnc1sxXSA6IFtdIDogYXJncyxcbiAgICAgICAgICAgICAgICBwYXRoOiBpc0FwcGx5ID8gcGF0aC5zbGljZSgwLCAtMSkgOiBwYXRoXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBwcm94eTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIHByb3h5IHRoYXQgY2FsbHMgdGhlIGNhbGxiYWNrIHdpdGggdGhlIHBhdGggYW5kIGFyZ3VtZW50c1xuICpcbiAqIEBpbnRlcm5hbFxuICovIGNvbnN0IGNyZWF0ZVJlY3Vyc2l2ZVByb3h5ID0gKGNhbGxiYWNrKT0+Y3JlYXRlSW5uZXJQcm94eShjYWxsYmFjaywgW10pO1xuLyoqXG4gKiBVc2VkIGluIHBsYWNlIG9mIGBuZXcgUHJveHlgIHdoZXJlIGVhY2ggaGFuZGxlciB3aWxsIG1hcCAxIGxldmVsIGRlZXAgdG8gYW5vdGhlciB2YWx1ZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqLyBjb25zdCBjcmVhdGVGbGF0UHJveHkgPSAoY2FsbGJhY2spPT57XG4gICAgcmV0dXJuIG5ldyBQcm94eShub29wLCB7XG4gICAgICAgIGdldCAoX29iaiwgbmFtZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJyB8fCBuYW1lID09PSAndGhlbicpIHtcbiAgICAgICAgICAgICAgICAvLyBzcGVjaWFsIGNhc2UgZm9yIGlmIHRoZSBwcm94eSBpcyBhY2NpZGVudGFsbHkgdHJlYXRlZFxuICAgICAgICAgICAgICAgIC8vIGxpa2UgYSBQcm9taXNlTGlrZSAobGlrZSBpbiBgUHJvbWlzZS5yZXNvbHZlKHByb3h5KWApXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhuYW1lKTtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcblxuZXhwb3J0cy5UUlBDX0VSUk9SX0NPREVTX0JZX05VTUJFUiA9IFRSUENfRVJST1JfQ09ERVNfQllfTlVNQkVSO1xuZXhwb3J0cy5jcmVhdGVGbGF0UHJveHkgPSBjcmVhdGVGbGF0UHJveHk7XG5leHBvcnRzLmNyZWF0ZVJlY3Vyc2l2ZVByb3h5ID0gY3JlYXRlUmVjdXJzaXZlUHJveHk7XG5leHBvcnRzLmdldEhUVFBTdGF0dXNDb2RlID0gZ2V0SFRUUFN0YXR1c0NvZGU7XG5leHBvcnRzLmdldEhUVFBTdGF0dXNDb2RlRnJvbUVycm9yID0gZ2V0SFRUUFN0YXR1c0NvZGVGcm9tRXJyb3I7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBUUlBDRXJyb3IgPSByZXF1aXJlKCcuL1RSUENFcnJvci1jYTM3YmYxYS5qcycpO1xudmFyIGluZGV4ID0gcmVxdWlyZSgnLi9pbmRleC03ODRmZjY0Ny5qcycpO1xudmFyIGNvZGVzID0gcmVxdWlyZSgnLi9jb2Rlcy04N2Y2ODI0Yi5qcycpO1xuXG4vKipcbiAqIEBwdWJsaWNcbiAqLyAvKipcbiAqIEBpbnRlcm5hbFxuICovIGZ1bmN0aW9uIGdldERhdGFUcmFuc2Zvcm1lcih0cmFuc2Zvcm1lcikge1xuICAgIGlmICgnaW5wdXQnIGluIHRyYW5zZm9ybWVyKSB7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1lcjtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaW5wdXQ6IHRyYW5zZm9ybWVyLFxuICAgICAgICBvdXRwdXQ6IHRyYW5zZm9ybWVyXG4gICAgfTtcbn1cbi8qKlxuICogQGludGVybmFsXG4gKi8gY29uc3QgZGVmYXVsdFRyYW5zZm9ybWVyID0ge1xuICAgIF9kZWZhdWx0OiB0cnVlLFxuICAgIGlucHV0OiB7XG4gICAgICAgIHNlcmlhbGl6ZTogKG9iaik9Pm9iaixcbiAgICAgICAgZGVzZXJpYWxpemU6IChvYmopPT5vYmpcbiAgICB9LFxuICAgIG91dHB1dDoge1xuICAgICAgICBzZXJpYWxpemU6IChvYmopPT5vYmosXG4gICAgICAgIGRlc2VyaWFsaXplOiAob2JqKT0+b2JqXG4gICAgfVxufTtcblxuY29uc3QgZGVmYXVsdEZvcm1hdHRlciA9ICh7IHNoYXBlICB9KT0+e1xuICAgIHJldHVybiBzaGFwZTtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGFuIG9iamVjdCB3aXRob3V0IGluaGVyaXRpbmcgYW55dGhpbmcgZnJvbSBgT2JqZWN0LnByb3RvdHlwZWBcbiAqIEBpbnRlcm5hbFxuICovIGZ1bmN0aW9uIG9taXRQcm90b3R5cGUob2JqKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShudWxsKSwgb2JqKTtcbn1cblxuY29uc3QgcHJvY2VkdXJlVHlwZXMgPSBbXG4gICAgJ3F1ZXJ5JyxcbiAgICAnbXV0YXRpb24nLFxuICAgICdzdWJzY3JpcHRpb24nXG5dO1xuXG5mdW5jdGlvbiBpc1JvdXRlcihwcm9jZWR1cmVPclJvdXRlcikge1xuICAgIHJldHVybiAncm91dGVyJyBpbiBwcm9jZWR1cmVPclJvdXRlci5fZGVmO1xufVxuY29uc3QgZW1wdHlSb3V0ZXIgPSB7XG4gICAgX2N0eDogbnVsbCxcbiAgICBfZXJyb3JTaGFwZTogbnVsbCxcbiAgICBfbWV0YTogbnVsbCxcbiAgICBxdWVyaWVzOiB7fSxcbiAgICBtdXRhdGlvbnM6IHt9LFxuICAgIHN1YnNjcmlwdGlvbnM6IHt9LFxuICAgIGVycm9yRm9ybWF0dGVyOiBkZWZhdWx0Rm9ybWF0dGVyLFxuICAgIHRyYW5zZm9ybWVyOiBkZWZhdWx0VHJhbnNmb3JtZXJcbn07XG4vKipcbiAqIFJlc2VydmVkIHdvcmRzIHRoYXQgY2FuJ3QgYmUgdXNlZCBhcyByb3V0ZXIgb3IgcHJvY2VkdXJlIG5hbWVzXG4gKi8gY29uc3QgcmVzZXJ2ZWRXb3JkcyA9IFtcbiAgICAvKipcbiAgICogVGhlbiBpcyBhIHJlc2VydmVkIHdvcmQgYmVjYXVzZSBvdGhlcndpc2Ugd2UgY2FuJ3QgcmV0dXJuIGEgcHJvbWlzZSB0aGF0IHJldHVybnMgYSBQcm94eVxuICAgKiBzaW5jZSBKUyB3aWxsIHRoaW5rIHRoYXQgYC50aGVuYCBpcyBzb21ldGhpbmcgdGhhdCBleGlzdHNcbiAgICovICd0aGVuJ1xuXTtcbi8qKlxuICogQGludGVybmFsXG4gKi8gZnVuY3Rpb24gY3JlYXRlUm91dGVyRmFjdG9yeShjb25maWcpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlUm91dGVySW5uZXIocHJvY2VkdXJlcykge1xuICAgICAgICBjb25zdCByZXNlcnZlZFdvcmRzVXNlZCA9IG5ldyBTZXQoT2JqZWN0LmtleXMocHJvY2VkdXJlcykuZmlsdGVyKCh2KT0+cmVzZXJ2ZWRXb3Jkcy5pbmNsdWRlcyh2KSkpO1xuICAgICAgICBpZiAocmVzZXJ2ZWRXb3Jkc1VzZWQuc2l6ZSA+IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUmVzZXJ2ZWQgd29yZHMgdXNlZCBpbiBgcm91dGVyKHt9KWAgY2FsbDogJyArIEFycmF5LmZyb20ocmVzZXJ2ZWRXb3Jkc1VzZWQpLmpvaW4oJywgJykpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJvdXRlclByb2NlZHVyZXMgPSBvbWl0UHJvdG90eXBlKHt9KTtcbiAgICAgICAgZnVuY3Rpb24gcmVjdXJzaXZlR2V0UGF0aHMocHJvY2VkdXJlcywgcGF0aCA9ICcnKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHByb2NlZHVyZU9yUm91dGVyXSBvZiBPYmplY3QuZW50cmllcyhwcm9jZWR1cmVzID8/IHt9KSl7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3UGF0aCA9IGAke3BhdGh9JHtrZXl9YDtcbiAgICAgICAgICAgICAgICBpZiAoaXNSb3V0ZXIocHJvY2VkdXJlT3JSb3V0ZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlY3Vyc2l2ZUdldFBhdGhzKHByb2NlZHVyZU9yUm91dGVyLl9kZWYucHJvY2VkdXJlcywgYCR7bmV3UGF0aH0uYCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocm91dGVyUHJvY2VkdXJlc1tuZXdQYXRoXSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYER1cGxpY2F0ZSBrZXk6ICR7bmV3UGF0aH1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcm91dGVyUHJvY2VkdXJlc1tuZXdQYXRoXSA9IHByb2NlZHVyZU9yUm91dGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlY3Vyc2l2ZUdldFBhdGhzKHByb2NlZHVyZXMpO1xuICAgICAgICBjb25zdCBfZGVmID0ge1xuICAgICAgICAgICAgX2NvbmZpZzogY29uZmlnLFxuICAgICAgICAgICAgcm91dGVyOiB0cnVlLFxuICAgICAgICAgICAgcHJvY2VkdXJlczogcm91dGVyUHJvY2VkdXJlcyxcbiAgICAgICAgICAgIC4uLmVtcHR5Um91dGVyLFxuICAgICAgICAgICAgcmVjb3JkOiBwcm9jZWR1cmVzLFxuICAgICAgICAgICAgcXVlcmllczogT2JqZWN0LmVudHJpZXMocm91dGVyUHJvY2VkdXJlcykuZmlsdGVyKChwYWlyKT0+cGFpclsxXS5fZGVmLnF1ZXJ5KS5yZWR1Y2UoKGFjYywgW2tleSwgdmFsXSk9Pih7XG4gICAgICAgICAgICAgICAgICAgIC4uLmFjYyxcbiAgICAgICAgICAgICAgICAgICAgW2tleV06IHZhbFxuICAgICAgICAgICAgICAgIH0pLCB7fSksXG4gICAgICAgICAgICBtdXRhdGlvbnM6IE9iamVjdC5lbnRyaWVzKHJvdXRlclByb2NlZHVyZXMpLmZpbHRlcigocGFpcik9PnBhaXJbMV0uX2RlZi5tdXRhdGlvbikucmVkdWNlKChhY2MsIFtrZXksIHZhbF0pPT4oe1xuICAgICAgICAgICAgICAgICAgICAuLi5hY2MsXG4gICAgICAgICAgICAgICAgICAgIFtrZXldOiB2YWxcbiAgICAgICAgICAgICAgICB9KSwge30pLFxuICAgICAgICAgICAgc3Vic2NyaXB0aW9uczogT2JqZWN0LmVudHJpZXMocm91dGVyUHJvY2VkdXJlcykuZmlsdGVyKChwYWlyKT0+cGFpclsxXS5fZGVmLnN1YnNjcmlwdGlvbikucmVkdWNlKChhY2MsIFtrZXksIHZhbF0pPT4oe1xuICAgICAgICAgICAgICAgICAgICAuLi5hY2MsXG4gICAgICAgICAgICAgICAgICAgIFtrZXldOiB2YWxcbiAgICAgICAgICAgICAgICB9KSwge30pXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJvdXRlciA9IHtcbiAgICAgICAgICAgIC4uLnByb2NlZHVyZXMsXG4gICAgICAgICAgICBfZGVmLFxuICAgICAgICAgICAgY3JlYXRlQ2FsbGVyIChjdHgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ2FsbGVyRmFjdG9yeSgpKHJvdXRlcikoY3R4KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRFcnJvclNoYXBlIChvcHRzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBwYXRoICwgZXJyb3IgIH0gPSBvcHRzO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgY29kZSAgfSA9IG9wdHMuZXJyb3I7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2hhcGUgPSB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IGNvZGVzLlRSUENfRVJST1JfQ09ERVNfQllfS0VZW2NvZGVdLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaHR0cFN0YXR1czogaW5kZXguZ2V0SFRUUFN0YXR1c0NvZGVGcm9tRXJyb3IoZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmIChjb25maWcuaXNEZXYgJiYgdHlwZW9mIG9wdHMuZXJyb3Iuc3RhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHNoYXBlLmRhdGEuc3RhY2sgPSBvcHRzLmVycm9yLnN0YWNrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHBhdGggPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHNoYXBlLmRhdGEucGF0aCA9IHBhdGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZWYuX2NvbmZpZy5lcnJvckZvcm1hdHRlcih7XG4gICAgICAgICAgICAgICAgICAgIC4uLm9wdHMsXG4gICAgICAgICAgICAgICAgICAgIHNoYXBlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiByb3V0ZXI7XG4gICAgfTtcbn1cbi8qKlxuICogQGludGVybmFsXG4gKi8gZnVuY3Rpb24gY2FsbFByb2NlZHVyZShvcHRzKSB7XG4gICAgY29uc3QgeyB0eXBlICwgcGF0aCAgfSA9IG9wdHM7XG4gICAgaWYgKCEocGF0aCBpbiBvcHRzLnByb2NlZHVyZXMpIHx8ICFvcHRzLnByb2NlZHVyZXNbcGF0aF0/Ll9kZWZbdHlwZV0pIHtcbiAgICAgICAgdGhyb3cgbmV3IFRSUENFcnJvci5UUlBDRXJyb3Ioe1xuICAgICAgICAgICAgY29kZTogJ05PVF9GT1VORCcsXG4gICAgICAgICAgICBtZXNzYWdlOiBgTm8gXCIke3R5cGV9XCItcHJvY2VkdXJlIG9uIHBhdGggXCIke3BhdGh9XCJgXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBwcm9jZWR1cmUgPSBvcHRzLnByb2NlZHVyZXNbcGF0aF07XG4gICAgcmV0dXJuIHByb2NlZHVyZShvcHRzKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNhbGxlckZhY3RvcnkoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZUNhbGxlcklubmVyKHJvdXRlcikge1xuICAgICAgICBjb25zdCBkZWYgPSByb3V0ZXIuX2RlZjtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZUNhbGxlcihjdHgpIHtcbiAgICAgICAgICAgIGNvbnN0IHByb3h5ID0gaW5kZXguY3JlYXRlUmVjdXJzaXZlUHJveHkoKHsgcGF0aCAsIGFyZ3MgIH0pPT57XG4gICAgICAgICAgICAgICAgLy8gaW50ZXJvcCBtb2RlXG4gICAgICAgICAgICAgICAgaWYgKHBhdGgubGVuZ3RoID09PSAxICYmIHByb2NlZHVyZVR5cGVzLmluY2x1ZGVzKHBhdGhbMF0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsUHJvY2VkdXJlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2NlZHVyZXM6IGRlZi5wcm9jZWR1cmVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogYXJnc1swXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhd0lucHV0OiBhcmdzWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogcGF0aFswXVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgZnVsbFBhdGggPSBwYXRoLmpvaW4oJy4nKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9jZWR1cmUgPSBkZWYucHJvY2VkdXJlc1tmdWxsUGF0aF07XG4gICAgICAgICAgICAgICAgbGV0IHR5cGUgPSAncXVlcnknO1xuICAgICAgICAgICAgICAgIGlmIChwcm9jZWR1cmUuX2RlZi5tdXRhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICB0eXBlID0gJ211dGF0aW9uJztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHByb2NlZHVyZS5fZGVmLnN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgICAgICAgICB0eXBlID0gJ3N1YnNjcmlwdGlvbic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBwcm9jZWR1cmUoe1xuICAgICAgICAgICAgICAgICAgICBwYXRoOiBmdWxsUGF0aCxcbiAgICAgICAgICAgICAgICAgICAgcmF3SW5wdXQ6IGFyZ3NbMF0sXG4gICAgICAgICAgICAgICAgICAgIGN0eCxcbiAgICAgICAgICAgICAgICAgICAgdHlwZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcHJveHk7XG4gICAgICAgIH07XG4gICAgfTtcbn1cblxuLyoqXG4gKiBUaGUgZGVmYXVsdCBjaGVjayB0byBzZWUgaWYgd2UncmUgaW4gYSBzZXJ2ZXJcbiAqLyBjb25zdCBpc1NlcnZlckRlZmF1bHQgPSB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyB8fCAnRGVubycgaW4gd2luZG93IHx8IGdsb2JhbFRoaXMucHJvY2Vzcz8uZW52Py5OT0RFX0VOViA9PT0gJ3Rlc3QnIHx8ICEhZ2xvYmFsVGhpcy5wcm9jZXNzPy5lbnY/LkpFU1RfV09SS0VSX0lEIHx8ICEhZ2xvYmFsVGhpcy5wcm9jZXNzPy5lbnY/LlZJVEVTVF9XT1JLRVJfSUQ7XG5cbmV4cG9ydHMuY2FsbFByb2NlZHVyZSA9IGNhbGxQcm9jZWR1cmU7XG5leHBvcnRzLmNyZWF0ZUNhbGxlckZhY3RvcnkgPSBjcmVhdGVDYWxsZXJGYWN0b3J5O1xuZXhwb3J0cy5jcmVhdGVSb3V0ZXJGYWN0b3J5ID0gY3JlYXRlUm91dGVyRmFjdG9yeTtcbmV4cG9ydHMuZGVmYXVsdEZvcm1hdHRlciA9IGRlZmF1bHRGb3JtYXR0ZXI7XG5leHBvcnRzLmRlZmF1bHRUcmFuc2Zvcm1lciA9IGRlZmF1bHRUcmFuc2Zvcm1lcjtcbmV4cG9ydHMuZ2V0RGF0YVRyYW5zZm9ybWVyID0gZ2V0RGF0YVRyYW5zZm9ybWVyO1xuZXhwb3J0cy5pc1NlcnZlckRlZmF1bHQgPSBpc1NlcnZlckRlZmF1bHQ7XG5leHBvcnRzLnByb2NlZHVyZVR5cGVzID0gcHJvY2VkdXJlVHlwZXM7XG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBjb25maWcgPSByZXF1aXJlKCcuL2NvbmZpZy0xOTRiZGQ0My5qcycpO1xudmFyIFRSUENFcnJvciA9IHJlcXVpcmUoJy4vVFJQQ0Vycm9yLWNhMzdiZjFhLmpzJyk7XG52YXIgaW5kZXggPSByZXF1aXJlKCcuL2luZGV4LTc4NGZmNjQ3LmpzJyk7XG52YXIgY29kZXMgPSByZXF1aXJlKCcuL2NvZGVzLTg3ZjY4MjRiLmpzJyk7XG5yZXF1aXJlKCcuL2dldENhdXNlRnJvbVVua25vd24tZDUzNTI2NGEuanMnKTtcblxuLyoqXG4gKiBAZGVwcmVjYXRlZFxuICovIGNvbnN0IG1pZGRsZXdhcmVNYXJrZXIkMSA9ICdtaWRkbGV3YXJlTWFya2VyJztcblxuZnVuY3Rpb24gZ2V0UGFyc2VGbiQxKHByb2NlZHVyZVBhcnNlcikge1xuICAgIGNvbnN0IHBhcnNlciA9IHByb2NlZHVyZVBhcnNlcjtcbiAgICBpZiAodHlwZW9mIHBhcnNlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBQcm9jZWR1cmVQYXJzZXJDdXN0b21WYWxpZGF0b3JFc3F1ZVxuICAgICAgICByZXR1cm4gcGFyc2VyO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHBhcnNlci5wYXJzZUFzeW5jID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIFByb2NlZHVyZVBhcnNlclpvZEVzcXVlXG4gICAgICAgIHJldHVybiBwYXJzZXIucGFyc2VBc3luYy5iaW5kKHBhcnNlcik7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcGFyc2VyLnBhcnNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIFByb2NlZHVyZVBhcnNlclpvZEVzcXVlXG4gICAgICAgIHJldHVybiBwYXJzZXIucGFyc2UuYmluZChwYXJzZXIpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHBhcnNlci52YWxpZGF0ZVN5bmMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gUHJvY2VkdXJlUGFyc2VyWXVwRXNxdWVcbiAgICAgICAgcmV0dXJuIHBhcnNlci52YWxpZGF0ZVN5bmMuYmluZChwYXJzZXIpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHBhcnNlci5jcmVhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gUHJvY2VkdXJlUGFyc2VyU3VwZXJzdHJ1Y3RFc3F1ZVxuICAgICAgICByZXR1cm4gcGFyc2VyLmNyZWF0ZS5iaW5kKHBhcnNlcik7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGZpbmQgYSB2YWxpZGF0b3IgZm4nKTtcbn1cbi8qKlxuICogQGludGVybmFsXG4gKiBAZGVwcmVjYXRlZFxuICovIGNsYXNzIFByb2NlZHVyZSB7XG4gICAgX2RlZigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1pZGRsZXdhcmVzOiB0aGlzLm1pZGRsZXdhcmVzLFxuICAgICAgICAgICAgcmVzb2x2ZXI6IHRoaXMucmVzb2x2ZXIsXG4gICAgICAgICAgICBpbnB1dFBhcnNlcjogdGhpcy5pbnB1dFBhcnNlcixcbiAgICAgICAgICAgIG91dHB1dFBhcnNlcjogdGhpcy5vdXRwdXRQYXJzZXIsXG4gICAgICAgICAgICBtZXRhOiB0aGlzLm1ldGFcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXN5bmMgcGFyc2VJbnB1dChyYXdJbnB1dCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucGFyc2VJbnB1dEZuKHJhd0lucHV0KTtcbiAgICAgICAgfSBjYXRjaCAoY2F1c2UpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUUlBDRXJyb3IuVFJQQ0Vycm9yKHtcbiAgICAgICAgICAgICAgICBjb2RlOiAnQkFEX1JFUVVFU1QnLFxuICAgICAgICAgICAgICAgIGNhdXNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBwYXJzZU91dHB1dChyYXdPdXRwdXQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnBhcnNlT3V0cHV0Rm4ocmF3T3V0cHV0KTtcbiAgICAgICAgfSBjYXRjaCAoY2F1c2UpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUUlBDRXJyb3IuVFJQQ0Vycm9yKHtcbiAgICAgICAgICAgICAgICBjb2RlOiAnSU5URVJOQUxfU0VSVkVSX0VSUk9SJyxcbiAgICAgICAgICAgICAgICBjYXVzZSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnT3V0cHV0IHZhbGlkYXRpb24gZmFpbGVkJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAqIFRyaWdnZXIgbWlkZGxld2FyZXMgaW4gb3JkZXIsIHBhcnNlIHJhdyBpbnB1dCwgY2FsbCByZXNvbHZlciAmIHBhcnNlIHJhdyBvdXRwdXRcbiAgICogQGludGVybmFsXG4gICAqLyBhc3luYyBjYWxsKG9wdHMpIHtcbiAgICAgICAgLy8gd3JhcCB0aGUgYWN0dWFsIHJlc29sdmVyIGFuZCB0cmVhdCBhcyB0aGUgbGFzdCBcIm1pZGRsZXdhcmVcIlxuICAgICAgICBjb25zdCBtaWRkbGV3YXJlc1dpdGhSZXNvbHZlciA9IHRoaXMubWlkZGxld2FyZXMuY29uY2F0KFtcbiAgICAgICAgICAgIGFzeW5jICh7IGN0eCAgfSk9PntcbiAgICAgICAgICAgICAgICBjb25zdCBpbnB1dCA9IGF3YWl0IHRoaXMucGFyc2VJbnB1dChvcHRzLnJhd0lucHV0KTtcbiAgICAgICAgICAgICAgICBjb25zdCByYXdPdXRwdXQgPSBhd2FpdCB0aGlzLnJlc29sdmVyKHtcbiAgICAgICAgICAgICAgICAgICAgLi4ub3B0cyxcbiAgICAgICAgICAgICAgICAgICAgY3R4LFxuICAgICAgICAgICAgICAgICAgICBpbnB1dFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLnBhcnNlT3V0cHV0KHJhd091dHB1dCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbWFya2VyOiBtaWRkbGV3YXJlTWFya2VyJDEsXG4gICAgICAgICAgICAgICAgICAgIG9rOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgICAgICAgICBjdHhcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICBdKTtcbiAgICAgICAgLy8gcnVuIHRoZSBtaWRkbGV3YXJlcyByZWN1cnNpdmVseSB3aXRoIHRoZSByZXNvbHZlciBhcyB0aGUgbGFzdCBvbmVcbiAgICAgICAgY29uc3QgY2FsbFJlY3Vyc2l2ZSA9IGFzeW5jIChjYWxsT3B0cyA9IHtcbiAgICAgICAgICAgIGluZGV4OiAwLFxuICAgICAgICAgICAgY3R4OiBvcHRzLmN0eFxuICAgICAgICB9KT0+e1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IG1pZGRsZXdhcmVzV2l0aFJlc29sdmVyW2NhbGxPcHRzLmluZGV4XSh7XG4gICAgICAgICAgICAgICAgICAgIGN0eDogY2FsbE9wdHMuY3R4LFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBvcHRzLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IG9wdHMucGF0aCxcbiAgICAgICAgICAgICAgICAgICAgcmF3SW5wdXQ6IG9wdHMucmF3SW5wdXQsXG4gICAgICAgICAgICAgICAgICAgIG1ldGE6IHRoaXMubWV0YSxcbiAgICAgICAgICAgICAgICAgICAgbmV4dDogYXN5bmMgKG5leHRPcHRzKT0+e1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGNhbGxSZWN1cnNpdmUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBjYWxsT3B0cy5pbmRleCArIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4OiBuZXh0T3B0cyA/IG5leHRPcHRzLmN0eCA6IGNhbGxPcHRzLmN0eFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfSBjYXRjaCAoY2F1c2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBjdHg6IGNhbGxPcHRzLmN0eCxcbiAgICAgICAgICAgICAgICAgICAgb2s6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogVFJQQ0Vycm9yLmdldFRSUENFcnJvckZyb21Vbmtub3duKGNhdXNlKSxcbiAgICAgICAgICAgICAgICAgICAgbWFya2VyOiBtaWRkbGV3YXJlTWFya2VyJDFcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyB0aGVyZSdzIGFsd2F5cyBhdCBsZWFzdCBvbmUgXCJuZXh0XCIgc2luY2Ugd2Ugd3JhcCB0aGlzLnJlc29sdmVyIGluIGEgbWlkZGxld2FyZVxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjYWxsUmVjdXJzaXZlKCk7XG4gICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVFJQQ0Vycm9yLlRSUENFcnJvcih7XG4gICAgICAgICAgICAgICAgY29kZTogJ0lOVEVSTkFMX1NFUlZFUl9FUlJPUicsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogJ05vIHJlc3VsdCBmcm9tIG1pZGRsZXdhcmVzIC0gZGlkIHlvdSBmb3JnZXQgdG8gYHJldHVybiBuZXh0KClgPydcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcmVzdWx0Lm9rKSB7XG4gICAgICAgICAgICAvLyByZS10aHJvdyBvcmlnaW5hbCBlcnJvclxuICAgICAgICAgICAgdGhyb3cgcmVzdWx0LmVycm9yO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQuZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAqIENyZWF0ZSBuZXcgcHJvY2VkdXJlIHdpdGggcGFzc2VkIG1pZGRsZXdhcmVzXG4gICAqIEBwYXJhbSBtaWRkbGV3YXJlc1xuICAgKi8gaW5oZXJpdE1pZGRsZXdhcmVzKG1pZGRsZXdhcmVzKSB7XG4gICAgICAgIGNvbnN0IENvbnN0cnVjdG9yID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBuZXcgQ29uc3RydWN0b3Ioe1xuICAgICAgICAgICAgbWlkZGxld2FyZXM6IFtcbiAgICAgICAgICAgICAgICAuLi5taWRkbGV3YXJlcyxcbiAgICAgICAgICAgICAgICAuLi50aGlzLm1pZGRsZXdhcmVzXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgcmVzb2x2ZXI6IHRoaXMucmVzb2x2ZXIsXG4gICAgICAgICAgICBpbnB1dFBhcnNlcjogdGhpcy5pbnB1dFBhcnNlcixcbiAgICAgICAgICAgIG91dHB1dFBhcnNlcjogdGhpcy5vdXRwdXRQYXJzZXIsXG4gICAgICAgICAgICBtZXRhOiB0aGlzLm1ldGFcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9XG4gICAgY29uc3RydWN0b3Iob3B0cyl7XG4gICAgICAgIHRoaXMubWlkZGxld2FyZXMgPSBvcHRzLm1pZGRsZXdhcmVzO1xuICAgICAgICB0aGlzLnJlc29sdmVyID0gb3B0cy5yZXNvbHZlcjtcbiAgICAgICAgdGhpcy5pbnB1dFBhcnNlciA9IG9wdHMuaW5wdXRQYXJzZXI7XG4gICAgICAgIHRoaXMucGFyc2VJbnB1dEZuID0gZ2V0UGFyc2VGbiQxKHRoaXMuaW5wdXRQYXJzZXIpO1xuICAgICAgICB0aGlzLm91dHB1dFBhcnNlciA9IG9wdHMub3V0cHV0UGFyc2VyO1xuICAgICAgICB0aGlzLnBhcnNlT3V0cHV0Rm4gPSBnZXRQYXJzZUZuJDEodGhpcy5vdXRwdXRQYXJzZXIpO1xuICAgICAgICB0aGlzLm1ldGEgPSBvcHRzLm1ldGE7XG4gICAgfVxufVxuZnVuY3Rpb24gY3JlYXRlUHJvY2VkdXJlKG9wdHMpIHtcbiAgICBjb25zdCBpbnB1dFBhcnNlciA9ICdpbnB1dCcgaW4gb3B0cyA/IG9wdHMuaW5wdXQgOiAoaW5wdXQpPT57XG4gICAgICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVFJQQ0Vycm9yLlRSUENFcnJvcih7XG4gICAgICAgICAgICAgICAgY29kZTogJ0JBRF9SRVFVRVNUJyxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnTm8gaW5wdXQgZXhwZWN0ZWQnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH07XG4gICAgY29uc3Qgb3V0cHV0UGFyc2VyID0gJ291dHB1dCcgaW4gb3B0cyAmJiBvcHRzLm91dHB1dCA/IG9wdHMub3V0cHV0IDogKG91dHB1dCk9Pm91dHB1dDtcbiAgICByZXR1cm4gbmV3IFByb2NlZHVyZSh7XG4gICAgICAgIGlucHV0UGFyc2VyOiBpbnB1dFBhcnNlcixcbiAgICAgICAgcmVzb2x2ZXI6IG9wdHMucmVzb2x2ZSxcbiAgICAgICAgbWlkZGxld2FyZXM6IFtdLFxuICAgICAgICBvdXRwdXRQYXJzZXI6IG91dHB1dFBhcnNlcixcbiAgICAgICAgbWV0YTogb3B0cy5tZXRhXG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldFBhcnNlRm4ocHJvY2VkdXJlUGFyc2VyKSB7XG4gICAgY29uc3QgcGFyc2VyID0gcHJvY2VkdXJlUGFyc2VyO1xuICAgIGlmICh0eXBlb2YgcGFyc2VyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIFBhcnNlckN1c3RvbVZhbGlkYXRvckVzcXVlXG4gICAgICAgIHJldHVybiBwYXJzZXI7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcGFyc2VyLnBhcnNlQXN5bmMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gUGFyc2VyWm9kRXNxdWVcbiAgICAgICAgcmV0dXJuIHBhcnNlci5wYXJzZUFzeW5jLmJpbmQocGFyc2VyKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBwYXJzZXIucGFyc2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gUGFyc2VyWm9kRXNxdWVcbiAgICAgICAgLy8gUGFyc2VyVmFsaWJvdEVzcXVlICg8PSB2MC4xMi5YKVxuICAgICAgICByZXR1cm4gcGFyc2VyLnBhcnNlLmJpbmQocGFyc2VyKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBwYXJzZXIudmFsaWRhdGVTeW5jID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIFBhcnNlcll1cEVzcXVlXG4gICAgICAgIHJldHVybiBwYXJzZXIudmFsaWRhdGVTeW5jLmJpbmQocGFyc2VyKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBwYXJzZXIuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIFBhcnNlclN1cGVyc3RydWN0RXNxdWVcbiAgICAgICAgcmV0dXJuIHBhcnNlci5jcmVhdGUuYmluZChwYXJzZXIpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHBhcnNlci5hc3NlcnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gUGFyc2VyU2NhbGVFc3F1ZVxuICAgICAgICByZXR1cm4gKHZhbHVlKT0+e1xuICAgICAgICAgICAgcGFyc2VyLmFzc2VydCh2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGZpbmQgYSB2YWxpZGF0b3IgZm4nKTtcbn1cbi8qKlxuICogQGRlcHJlY2F0ZWQgb25seSBmb3IgYmFja3dhcmRzIGNvbXBhdFxuICogQGludGVybmFsXG4gKi8gZnVuY3Rpb24gZ2V0UGFyc2VGbk9yUGFzc1Rocm91Z2gocHJvY2VkdXJlUGFyc2VyKSB7XG4gICAgaWYgKCFwcm9jZWR1cmVQYXJzZXIpIHtcbiAgICAgICAgcmV0dXJuICh2KT0+djtcbiAgICB9XG4gICAgcmV0dXJuIGdldFBhcnNlRm4ocHJvY2VkdXJlUGFyc2VyKTtcbn1cblxuLyoqXG4gKiBFbnN1cmVzIHRoZXJlIGFyZSBubyBkdXBsaWNhdGUga2V5cyB3aGVuIGJ1aWxkaW5nIGEgcHJvY2VkdXJlLlxuICovIGZ1bmN0aW9uIG1lcmdlV2l0aG91dE92ZXJyaWRlcyhvYmoxLCAuLi5vYmpzKSB7XG4gICAgY29uc3QgbmV3T2JqID0gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG51bGwpLCBvYmoxKTtcbiAgICBmb3IgKGNvbnN0IG92ZXJyaWRlcyBvZiBvYmpzKXtcbiAgICAgICAgZm9yKGNvbnN0IGtleSBpbiBvdmVycmlkZXMpe1xuICAgICAgICAgICAgaWYgKGtleSBpbiBuZXdPYmogJiYgbmV3T2JqW2tleV0gIT09IG92ZXJyaWRlc1trZXldKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEdXBsaWNhdGUga2V5ICR7a2V5fWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3T2JqW2tleV0gPSBvdmVycmlkZXNba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3T2JqO1xufVxuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovIGZ1bmN0aW9uIGNyZWF0ZU1pZGRsZXdhcmVGYWN0b3J5KCkge1xuICAgIGZ1bmN0aW9uIGNyZWF0ZU1pZGRsZXdhcmVJbm5lcihtaWRkbGV3YXJlcykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgX21pZGRsZXdhcmVzOiBtaWRkbGV3YXJlcyxcbiAgICAgICAgICAgIHVuc3RhYmxlX3BpcGUgKG1pZGRsZXdhcmVCdWlsZGVyT3JGbikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBpcGVkTWlkZGxld2FyZSA9ICdfbWlkZGxld2FyZXMnIGluIG1pZGRsZXdhcmVCdWlsZGVyT3JGbiA/IG1pZGRsZXdhcmVCdWlsZGVyT3JGbi5fbWlkZGxld2FyZXMgOiBbXG4gICAgICAgICAgICAgICAgICAgIG1pZGRsZXdhcmVCdWlsZGVyT3JGblxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZU1pZGRsZXdhcmVJbm5lcihbXG4gICAgICAgICAgICAgICAgICAgIC4uLm1pZGRsZXdhcmVzLFxuICAgICAgICAgICAgICAgICAgICAuLi5waXBlZE1pZGRsZXdhcmVcbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlTWlkZGxld2FyZShmbikge1xuICAgICAgICByZXR1cm4gY3JlYXRlTWlkZGxld2FyZUlubmVyKFtcbiAgICAgICAgICAgIGZuXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlTWlkZGxld2FyZTtcbn1cbmNvbnN0IGV4cGVyaW1lbnRhbF9zdGFuZGFsb25lTWlkZGxld2FyZSA9ICgpPT4oe1xuICAgICAgICBjcmVhdGU6IGNyZWF0ZU1pZGRsZXdhcmVGYWN0b3J5KClcbiAgICB9KTtcbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3Qob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShvYmopO1xufVxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqIFBsZWFzZSBub3RlLCBgdHJwYy1vcGVuYXBpYCB1c2VzIHRoaXMgZnVuY3Rpb24uXG4gKi8gZnVuY3Rpb24gY3JlYXRlSW5wdXRNaWRkbGV3YXJlKHBhcnNlKSB7XG4gICAgY29uc3QgaW5wdXRNaWRkbGV3YXJlID0gYXN5bmMgKHsgbmV4dCAsIHJhd0lucHV0ICwgaW5wdXQgLCAgfSk9PntcbiAgICAgICAgbGV0IHBhcnNlZElucHV0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcGFyc2VkSW5wdXQgPSBhd2FpdCBwYXJzZShyYXdJbnB1dCk7XG4gICAgICAgIH0gY2F0Y2ggKGNhdXNlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVFJQQ0Vycm9yLlRSUENFcnJvcih7XG4gICAgICAgICAgICAgICAgY29kZTogJ0JBRF9SRVFVRVNUJyxcbiAgICAgICAgICAgICAgICBjYXVzZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTXVsdGlwbGUgaW5wdXQgcGFyc2Vyc1xuICAgICAgICBjb25zdCBjb21iaW5lZElucHV0ID0gaXNQbGFpbk9iamVjdChpbnB1dCkgJiYgaXNQbGFpbk9iamVjdChwYXJzZWRJbnB1dCkgPyB7XG4gICAgICAgICAgICAuLi5pbnB1dCxcbiAgICAgICAgICAgIC4uLnBhcnNlZElucHV0XG4gICAgICAgIH0gOiBwYXJzZWRJbnB1dDtcbiAgICAgICAgLy8gVE9ETyBmaXggdGhpcyB0eXBpbmc/XG4gICAgICAgIHJldHVybiBuZXh0KHtcbiAgICAgICAgICAgIGlucHV0OiBjb21iaW5lZElucHV0XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgaW5wdXRNaWRkbGV3YXJlLl90eXBlID0gJ2lucHV0JztcbiAgICByZXR1cm4gaW5wdXRNaWRkbGV3YXJlO1xufVxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqLyBmdW5jdGlvbiBjcmVhdGVPdXRwdXRNaWRkbGV3YXJlKHBhcnNlKSB7XG4gICAgY29uc3Qgb3V0cHV0TWlkZGxld2FyZSA9IGFzeW5jICh7IG5leHQgIH0pPT57XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IG5leHQoKTtcbiAgICAgICAgaWYgKCFyZXN1bHQub2spIHtcbiAgICAgICAgICAgIC8vIHBhc3MgdGhyb3VnaCBmYWlsdXJlcyB3aXRob3V0IHZhbGlkYXRpbmdcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBwYXJzZShyZXN1bHQuZGF0YSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIC4uLnJlc3VsdCxcbiAgICAgICAgICAgICAgICBkYXRhXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGNhdGNoIChjYXVzZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFRSUENFcnJvci5UUlBDRXJyb3Ioe1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdPdXRwdXQgdmFsaWRhdGlvbiBmYWlsZWQnLFxuICAgICAgICAgICAgICAgIGNvZGU6ICdJTlRFUk5BTF9TRVJWRVJfRVJST1InLFxuICAgICAgICAgICAgICAgIGNhdXNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgb3V0cHV0TWlkZGxld2FyZS5fdHlwZSA9ICdvdXRwdXQnO1xuICAgIHJldHVybiBvdXRwdXRNaWRkbGV3YXJlO1xufVxuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovIGNvbnN0IG1pZGRsZXdhcmVNYXJrZXIgPSAnbWlkZGxld2FyZU1hcmtlcic7XG5cbmZ1bmN0aW9uIGNyZWF0ZU5ld0J1aWxkZXIoZGVmMSwgZGVmMikge1xuICAgIGNvbnN0IHsgbWlkZGxld2FyZXMgPVtdICwgaW5wdXRzICwgbWV0YSAsIC4uLnJlc3QgfSA9IGRlZjI7XG4gICAgLy8gVE9ETzogbWF5YmUgaGF2ZSBhIGZuIGhlcmUgdG8gd2FybiBhYm91dCBjYWxsc1xuICAgIHJldHVybiBjcmVhdGVCdWlsZGVyKHtcbiAgICAgICAgLi4ubWVyZ2VXaXRob3V0T3ZlcnJpZGVzKGRlZjEsIHJlc3QpLFxuICAgICAgICBpbnB1dHM6IFtcbiAgICAgICAgICAgIC4uLmRlZjEuaW5wdXRzLFxuICAgICAgICAgICAgLi4uaW5wdXRzID8/IFtdXG4gICAgICAgIF0sXG4gICAgICAgIG1pZGRsZXdhcmVzOiBbXG4gICAgICAgICAgICAuLi5kZWYxLm1pZGRsZXdhcmVzLFxuICAgICAgICAgICAgLi4ubWlkZGxld2FyZXNcbiAgICAgICAgXSxcbiAgICAgICAgbWV0YTogZGVmMS5tZXRhICYmIG1ldGEgPyB7XG4gICAgICAgICAgICAuLi5kZWYxLm1ldGEsXG4gICAgICAgICAgICAuLi5tZXRhXG4gICAgICAgIH0gOiBtZXRhID8/IGRlZjEubWV0YVxuICAgIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlQnVpbGRlcihpbml0RGVmID0ge30pIHtcbiAgICBjb25zdCBfZGVmID0ge1xuICAgICAgICBpbnB1dHM6IFtdLFxuICAgICAgICBtaWRkbGV3YXJlczogW10sXG4gICAgICAgIC4uLmluaXREZWZcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIF9kZWYsXG4gICAgICAgIGlucHV0IChpbnB1dCkge1xuICAgICAgICAgICAgY29uc3QgcGFyc2VyID0gZ2V0UGFyc2VGbihpbnB1dCk7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlTmV3QnVpbGRlcihfZGVmLCB7XG4gICAgICAgICAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICAgICAgICAgIGlucHV0XG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBtaWRkbGV3YXJlczogW1xuICAgICAgICAgICAgICAgICAgICBjcmVhdGVJbnB1dE1pZGRsZXdhcmUocGFyc2VyKVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBvdXRwdXQgKG91dHB1dCkge1xuICAgICAgICAgICAgY29uc3QgcGFyc2VPdXRwdXQgPSBnZXRQYXJzZUZuKG91dHB1dCk7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlTmV3QnVpbGRlcihfZGVmLCB7XG4gICAgICAgICAgICAgICAgb3V0cHV0LFxuICAgICAgICAgICAgICAgIG1pZGRsZXdhcmVzOiBbXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZU91dHB1dE1pZGRsZXdhcmUocGFyc2VPdXRwdXQpXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIG1ldGEgKG1ldGEpIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVOZXdCdWlsZGVyKF9kZWYsIHtcbiAgICAgICAgICAgICAgICBtZXRhOiBtZXRhXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKiBUaGlzIGZ1bmN0aW9uYWxpdHkgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24uXG4gICAgICovIHVuc3RhYmxlX2NvbmNhdCAoYnVpbGRlcikge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZU5ld0J1aWxkZXIoX2RlZiwgYnVpbGRlci5fZGVmKTtcbiAgICAgICAgfSxcbiAgICAgICAgdXNlIChtaWRkbGV3YXJlQnVpbGRlck9yRm4pIHtcbiAgICAgICAgICAgIC8vIERpc3Rpbmd1aXNoIGJldHdlZW4gYSBtaWRkbGV3YXJlIGJ1aWxkZXIgYW5kIGEgbWlkZGxld2FyZSBmdW5jdGlvblxuICAgICAgICAgICAgY29uc3QgbWlkZGxld2FyZXMgPSAnX21pZGRsZXdhcmVzJyBpbiBtaWRkbGV3YXJlQnVpbGRlck9yRm4gPyBtaWRkbGV3YXJlQnVpbGRlck9yRm4uX21pZGRsZXdhcmVzIDogW1xuICAgICAgICAgICAgICAgIG1pZGRsZXdhcmVCdWlsZGVyT3JGblxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVOZXdCdWlsZGVyKF9kZWYsIHtcbiAgICAgICAgICAgICAgICBtaWRkbGV3YXJlczogbWlkZGxld2FyZXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBxdWVyeSAocmVzb2x2ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVSZXNvbHZlcih7XG4gICAgICAgICAgICAgICAgLi4uX2RlZixcbiAgICAgICAgICAgICAgICBxdWVyeTogdHJ1ZVxuICAgICAgICAgICAgfSwgcmVzb2x2ZXIpO1xuICAgICAgICB9LFxuICAgICAgICBtdXRhdGlvbiAocmVzb2x2ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVSZXNvbHZlcih7XG4gICAgICAgICAgICAgICAgLi4uX2RlZixcbiAgICAgICAgICAgICAgICBtdXRhdGlvbjogdHJ1ZVxuICAgICAgICAgICAgfSwgcmVzb2x2ZXIpO1xuICAgICAgICB9LFxuICAgICAgICBzdWJzY3JpcHRpb24gKHJlc29sdmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlUmVzb2x2ZXIoe1xuICAgICAgICAgICAgICAgIC4uLl9kZWYsXG4gICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uOiB0cnVlXG4gICAgICAgICAgICB9LCByZXNvbHZlcik7XG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlUmVzb2x2ZXIoX2RlZiwgcmVzb2x2ZXIpIHtcbiAgICBjb25zdCBmaW5hbEJ1aWxkZXIgPSBjcmVhdGVOZXdCdWlsZGVyKF9kZWYsIHtcbiAgICAgICAgcmVzb2x2ZXIsXG4gICAgICAgIG1pZGRsZXdhcmVzOiBbXG4gICAgICAgICAgICBhc3luYyBmdW5jdGlvbiByZXNvbHZlTWlkZGxld2FyZShvcHRzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc29sdmVyKG9wdHMpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG1hcmtlcjogbWlkZGxld2FyZU1hcmtlcixcbiAgICAgICAgICAgICAgICAgICAgb2s6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICAgICAgICAgIGN0eDogb3B0cy5jdHhcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICBdXG4gICAgfSk7XG4gICAgcmV0dXJuIGNyZWF0ZVByb2NlZHVyZUNhbGxlcihmaW5hbEJ1aWxkZXIuX2RlZik7XG59XG5jb25zdCBjb2RlYmxvY2sgPSBgXG5UaGlzIGlzIGEgY2xpZW50LW9ubHkgZnVuY3Rpb24uXG5JZiB5b3Ugd2FudCB0byBjYWxsIHRoaXMgZnVuY3Rpb24gb24gdGhlIHNlcnZlciwgc2VlIGh0dHBzOi8vdHJwYy5pby9kb2NzL3NlcnZlci9zZXJ2ZXItc2lkZS1jYWxsc1xuYC50cmltKCk7XG5mdW5jdGlvbiBjcmVhdGVQcm9jZWR1cmVDYWxsZXIoX2RlZikge1xuICAgIGNvbnN0IHByb2NlZHVyZSA9IGFzeW5jIGZ1bmN0aW9uIHJlc29sdmUob3B0cykge1xuICAgICAgICAvLyBpcyBkaXJlY3Qgc2VydmVyLXNpZGUgY2FsbFxuICAgICAgICBpZiAoIW9wdHMgfHwgISgncmF3SW5wdXQnIGluIG9wdHMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoY29kZWJsb2NrKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBydW4gdGhlIG1pZGRsZXdhcmVzIHJlY3Vyc2l2ZWx5IHdpdGggdGhlIHJlc29sdmVyIGFzIHRoZSBsYXN0IG9uZVxuICAgICAgICBjb25zdCBjYWxsUmVjdXJzaXZlID0gYXN5bmMgKGNhbGxPcHRzID0ge1xuICAgICAgICAgICAgaW5kZXg6IDAsXG4gICAgICAgICAgICBjdHg6IG9wdHMuY3R4XG4gICAgICAgIH0pPT57XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgICAgICAgY29uc3QgbWlkZGxld2FyZSA9IF9kZWYubWlkZGxld2FyZXNbY2FsbE9wdHMuaW5kZXhdO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IG1pZGRsZXdhcmUoe1xuICAgICAgICAgICAgICAgICAgICBjdHg6IGNhbGxPcHRzLmN0eCxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogb3B0cy50eXBlLFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBvcHRzLnBhdGgsXG4gICAgICAgICAgICAgICAgICAgIHJhd0lucHV0OiBjYWxsT3B0cy5yYXdJbnB1dCA/PyBvcHRzLnJhd0lucHV0LFxuICAgICAgICAgICAgICAgICAgICBtZXRhOiBfZGVmLm1ldGEsXG4gICAgICAgICAgICAgICAgICAgIGlucHV0OiBjYWxsT3B0cy5pbnB1dCxcbiAgICAgICAgICAgICAgICAgICAgbmV4dCAoX25leHRPcHRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0T3B0cyA9IF9uZXh0T3B0cztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsUmVjdXJzaXZlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogY2FsbE9wdHMuaW5kZXggKyAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eDogbmV4dE9wdHMgJiYgJ2N0eCcgaW4gbmV4dE9wdHMgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLmNhbGxPcHRzLmN0eCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4ubmV4dE9wdHMuY3R4XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSA6IGNhbGxPcHRzLmN0eCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dDogbmV4dE9wdHMgJiYgJ2lucHV0JyBpbiBuZXh0T3B0cyA/IG5leHRPcHRzLmlucHV0IDogY2FsbE9wdHMuaW5wdXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmF3SW5wdXQ6IG5leHRPcHRzICYmICdyYXdJbnB1dCcgaW4gbmV4dE9wdHMgPyBuZXh0T3B0cy5yYXdJbnB1dCA6IGNhbGxPcHRzLnJhd0lucHV0XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9IGNhdGNoIChjYXVzZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG9rOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IFRSUENFcnJvci5nZXRUUlBDRXJyb3JGcm9tVW5rbm93bihjYXVzZSksXG4gICAgICAgICAgICAgICAgICAgIG1hcmtlcjogbWlkZGxld2FyZU1hcmtlclxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8vIHRoZXJlJ3MgYWx3YXlzIGF0IGxlYXN0IG9uZSBcIm5leHRcIiBzaW5jZSB3ZSB3cmFwIHRoaXMucmVzb2x2ZXIgaW4gYSBtaWRkbGV3YXJlXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNhbGxSZWN1cnNpdmUoKTtcbiAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUUlBDRXJyb3IuVFJQQ0Vycm9yKHtcbiAgICAgICAgICAgICAgICBjb2RlOiAnSU5URVJOQUxfU0VSVkVSX0VSUk9SJyxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnTm8gcmVzdWx0IGZyb20gbWlkZGxld2FyZXMgLSBkaWQgeW91IGZvcmdldCB0byBgcmV0dXJuIG5leHQoKWA/J1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyZXN1bHQub2spIHtcbiAgICAgICAgICAgIC8vIHJlLXRocm93IG9yaWdpbmFsIGVycm9yXG4gICAgICAgICAgICB0aHJvdyByZXN1bHQuZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdC5kYXRhO1xuICAgIH07XG4gICAgcHJvY2VkdXJlLl9kZWYgPSBfZGVmO1xuICAgIHByb2NlZHVyZS5tZXRhID0gX2RlZi5tZXRhO1xuICAgIHJldHVybiBwcm9jZWR1cmU7XG59XG5cbmZ1bmN0aW9uIG1pZ3JhdGVQcm9jZWR1cmUob2xkUHJvYywgdHlwZSkge1xuICAgIGNvbnN0IGRlZiA9IG9sZFByb2MuX2RlZigpO1xuICAgIGNvbnN0IGlucHV0UGFyc2VyID0gZ2V0UGFyc2VGbk9yUGFzc1Rocm91Z2goZGVmLmlucHV0UGFyc2VyKTtcbiAgICBjb25zdCBvdXRwdXRQYXJzZXIgPSBnZXRQYXJzZUZuT3JQYXNzVGhyb3VnaChkZWYub3V0cHV0UGFyc2VyKTtcbiAgICBjb25zdCBpbnB1dE1pZGRsZXdhcmUgPSBjcmVhdGVJbnB1dE1pZGRsZXdhcmUoaW5wdXRQYXJzZXIpO1xuICAgIGNvbnN0IGJ1aWxkZXIgPSBjcmVhdGVCdWlsZGVyKHtcbiAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICBkZWYuaW5wdXRQYXJzZXJcbiAgICAgICAgXSxcbiAgICAgICAgbWlkZGxld2FyZXM6IFtcbiAgICAgICAgICAgIC4uLmRlZi5taWRkbGV3YXJlcyxcbiAgICAgICAgICAgIGlucHV0TWlkZGxld2FyZSxcbiAgICAgICAgICAgIGNyZWF0ZU91dHB1dE1pZGRsZXdhcmUob3V0cHV0UGFyc2VyKVxuICAgICAgICBdLFxuICAgICAgICBtZXRhOiBkZWYubWV0YSxcbiAgICAgICAgb3V0cHV0OiBkZWYub3V0cHV0UGFyc2VyLFxuICAgICAgICBtdXRhdGlvbjogdHlwZSA9PT0gJ211dGF0aW9uJyxcbiAgICAgICAgcXVlcnk6IHR5cGUgPT09ICdxdWVyeScsXG4gICAgICAgIHN1YnNjcmlwdGlvbjogdHlwZSA9PT0gJ3N1YnNjcmlwdGlvbidcbiAgICB9KTtcbiAgICBjb25zdCBwcm9jID0gYnVpbGRlclt0eXBlXSgob3B0cyk9PmRlZi5yZXNvbHZlcihvcHRzKSk7XG4gICAgcmV0dXJuIHByb2M7XG59XG5mdW5jdGlvbiBtaWdyYXRlUm91dGVyKG9sZFJvdXRlcikge1xuICAgIGNvbnN0IGVycm9yRm9ybWF0dGVyID0gb2xkUm91dGVyLl9kZWYuZXJyb3JGb3JtYXR0ZXI7XG4gICAgY29uc3QgdHJhbnNmb3JtZXIgPSBvbGRSb3V0ZXIuX2RlZi50cmFuc2Zvcm1lcjtcbiAgICBjb25zdCBxdWVyaWVzID0ge307XG4gICAgY29uc3QgbXV0YXRpb25zID0ge307XG4gICAgY29uc3Qgc3Vic2NyaXB0aW9ucyA9IHt9O1xuICAgIGZvciAoY29uc3QgW25hbWUsIHByb2NlZHVyZV0gb2YgT2JqZWN0LmVudHJpZXMob2xkUm91dGVyLl9kZWYucXVlcmllcykpe1xuICAgICAgICBxdWVyaWVzW25hbWVdID0gbWlncmF0ZVByb2NlZHVyZShwcm9jZWR1cmUsICdxdWVyeScpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IFtuYW1lMSwgcHJvY2VkdXJlMV0gb2YgT2JqZWN0LmVudHJpZXMob2xkUm91dGVyLl9kZWYubXV0YXRpb25zKSl7XG4gICAgICAgIG11dGF0aW9uc1tuYW1lMV0gPSBtaWdyYXRlUHJvY2VkdXJlKHByb2NlZHVyZTEsICdtdXRhdGlvbicpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IFtuYW1lMiwgcHJvY2VkdXJlMl0gb2YgT2JqZWN0LmVudHJpZXMob2xkUm91dGVyLl9kZWYuc3Vic2NyaXB0aW9ucykpe1xuICAgICAgICBzdWJzY3JpcHRpb25zW25hbWUyXSA9IG1pZ3JhdGVQcm9jZWR1cmUocHJvY2VkdXJlMiwgJ3N1YnNjcmlwdGlvbicpO1xuICAgIH1cbiAgICBjb25zdCBwcm9jZWR1cmVzID0gbWVyZ2VXaXRob3V0T3ZlcnJpZGVzKHF1ZXJpZXMsIG11dGF0aW9ucywgc3Vic2NyaXB0aW9ucyk7XG4gICAgY29uc3QgbmV3Um91dGVyID0gY29uZmlnLmNyZWF0ZVJvdXRlckZhY3Rvcnkoe1xuICAgICAgICB0cmFuc2Zvcm1lcixcbiAgICAgICAgZXJyb3JGb3JtYXR0ZXIsXG4gICAgICAgIGlzRGV2OiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nXG4gICAgfSkocHJvY2VkdXJlcyk7XG4gICAgcmV0dXJuIG5ld1JvdXRlcjtcbn1cblxuZnVuY3Rpb24gZ2V0RGF0YVRyYW5zZm9ybWVyKHRyYW5zZm9ybWVyKSB7XG4gICAgaWYgKCdpbnB1dCcgaW4gdHJhbnNmb3JtZXIpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVyO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBpbnB1dDogdHJhbnNmb3JtZXIsXG4gICAgICAgIG91dHB1dDogdHJhbnNmb3JtZXJcbiAgICB9O1xufVxuY29uc3QgUFJPQ0VEVVJFX0RFRklOSVRJT05fTUFQID0ge1xuICAgIHF1ZXJ5OiAncXVlcmllcycsXG4gICAgbXV0YXRpb246ICdtdXRhdGlvbnMnLFxuICAgIHN1YnNjcmlwdGlvbjogJ3N1YnNjcmlwdGlvbnMnXG59O1xuZnVuY3Rpb24gc2FmZU9iamVjdCguLi5hcmdzKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShudWxsKSwgLi4uYXJncyk7XG59XG4vKipcbiAqIEBpbnRlcm5hbCBUaGUgdHlwZSBzaWduYXR1cmUgb2YgdGhpcyBjbGFzcyBtYXkgY2hhbmdlIHdpdGhvdXQgd2FybmluZy5cbiAqIEBkZXByZWNhdGVkXG4gKi8gY2xhc3MgUm91dGVyIHtcbiAgICBzdGF0aWMgcHJlZml4UHJvY2VkdXJlcyhwcm9jZWR1cmVzLCBwcmVmaXgpIHtcbiAgICAgICAgY29uc3QgZXBzID0gc2FmZU9iamVjdCgpO1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHByb2NlZHVyZV0gb2YgT2JqZWN0LmVudHJpZXMocHJvY2VkdXJlcykpe1xuICAgICAgICAgICAgZXBzW3ByZWZpeCArIGtleV0gPSBwcm9jZWR1cmU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVwcztcbiAgICB9XG4gICAgcXVlcnkocGF0aCwgcHJvY2VkdXJlKSB7XG4gICAgICAgIGNvbnN0IHJvdXRlciA9IG5ldyBSb3V0ZXIoe1xuICAgICAgICAgICAgcXVlcmllczogc2FmZU9iamVjdCh7XG4gICAgICAgICAgICAgICAgW3BhdGhdOiBjcmVhdGVQcm9jZWR1cmUocHJvY2VkdXJlKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLm1lcmdlKHJvdXRlcik7XG4gICAgfVxuICAgIG11dGF0aW9uKHBhdGgsIHByb2NlZHVyZSkge1xuICAgICAgICBjb25zdCByb3V0ZXIgPSBuZXcgUm91dGVyKHtcbiAgICAgICAgICAgIG11dGF0aW9uczogc2FmZU9iamVjdCh7XG4gICAgICAgICAgICAgICAgW3BhdGhdOiBjcmVhdGVQcm9jZWR1cmUocHJvY2VkdXJlKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLm1lcmdlKHJvdXRlcik7XG4gICAgfVxuICAgIHN1YnNjcmlwdGlvbihwYXRoLCBwcm9jZWR1cmUpIHtcbiAgICAgICAgY29uc3Qgcm91dGVyID0gbmV3IFJvdXRlcih7XG4gICAgICAgICAgICBzdWJzY3JpcHRpb25zOiBzYWZlT2JqZWN0KHtcbiAgICAgICAgICAgICAgICBbcGF0aF06IGNyZWF0ZVByb2NlZHVyZShwcm9jZWR1cmUpXG4gICAgICAgICAgICB9KVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMubWVyZ2Uocm91dGVyKTtcbiAgICB9XG4gICAgbWVyZ2UocHJlZml4T3JSb3V0ZXIsIG1heWJlUm91dGVyKSB7XG4gICAgICAgIGxldCBwcmVmaXggPSAnJztcbiAgICAgICAgbGV0IGNoaWxkUm91dGVyO1xuICAgICAgICBpZiAodHlwZW9mIHByZWZpeE9yUm91dGVyID09PSAnc3RyaW5nJyAmJiBtYXliZVJvdXRlciBpbnN0YW5jZW9mIFJvdXRlcikge1xuICAgICAgICAgICAgcHJlZml4ID0gcHJlZml4T3JSb3V0ZXI7XG4gICAgICAgICAgICBjaGlsZFJvdXRlciA9IG1heWJlUm91dGVyO1xuICAgICAgICB9IGVsc2UgaWYgKHByZWZpeE9yUm91dGVyIGluc3RhbmNlb2YgUm91dGVyKSB7XG4gICAgICAgICAgICBjaGlsZFJvdXRlciA9IHByZWZpeE9yUm91dGVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFyZ3MnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkdXBsaWNhdGVRdWVyaWVzID0gT2JqZWN0LmtleXMoY2hpbGRSb3V0ZXIuX2RlZi5xdWVyaWVzKS5maWx0ZXIoKGtleSk9PiEhdGhpcy5fZGVmLnF1ZXJpZXNbcHJlZml4ICsga2V5XSk7XG4gICAgICAgIGNvbnN0IGR1cGxpY2F0ZU11dGF0aW9ucyA9IE9iamVjdC5rZXlzKGNoaWxkUm91dGVyLl9kZWYubXV0YXRpb25zKS5maWx0ZXIoKGtleSk9PiEhdGhpcy5fZGVmLm11dGF0aW9uc1twcmVmaXggKyBrZXldKTtcbiAgICAgICAgY29uc3QgZHVwbGljYXRlU3Vic2NyaXB0aW9ucyA9IE9iamVjdC5rZXlzKGNoaWxkUm91dGVyLl9kZWYuc3Vic2NyaXB0aW9ucykuZmlsdGVyKChrZXkpPT4hIXRoaXMuX2RlZi5zdWJzY3JpcHRpb25zW3ByZWZpeCArIGtleV0pO1xuICAgICAgICBjb25zdCBkdXBsaWNhdGVzID0gW1xuICAgICAgICAgICAgLi4uZHVwbGljYXRlUXVlcmllcyxcbiAgICAgICAgICAgIC4uLmR1cGxpY2F0ZU11dGF0aW9ucyxcbiAgICAgICAgICAgIC4uLmR1cGxpY2F0ZVN1YnNjcmlwdGlvbnNcbiAgICAgICAgXTtcbiAgICAgICAgaWYgKGR1cGxpY2F0ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYER1cGxpY2F0ZSBlbmRwb2ludChzKTogJHtkdXBsaWNhdGVzLmpvaW4oJywgJyl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWVyZ2VQcm9jZWR1cmVzID0gKGRlZnMpPT57XG4gICAgICAgICAgICBjb25zdCBuZXdEZWZzID0gc2FmZU9iamVjdCgpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBba2V5LCBwcm9jZWR1cmVdIG9mIE9iamVjdC5lbnRyaWVzKGRlZnMpKXtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdQcm9jZWR1cmUgPSBwcm9jZWR1cmUuaW5oZXJpdE1pZGRsZXdhcmVzKHRoaXMuX2RlZi5taWRkbGV3YXJlcyk7XG4gICAgICAgICAgICAgICAgbmV3RGVmc1trZXldID0gbmV3UHJvY2VkdXJlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFJvdXRlci5wcmVmaXhQcm9jZWR1cmVzKG5ld0RlZnMsIHByZWZpeCk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBuZXcgUm91dGVyKHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIHF1ZXJpZXM6IHNhZmVPYmplY3QodGhpcy5fZGVmLnF1ZXJpZXMsIG1lcmdlUHJvY2VkdXJlcyhjaGlsZFJvdXRlci5fZGVmLnF1ZXJpZXMpKSxcbiAgICAgICAgICAgIG11dGF0aW9uczogc2FmZU9iamVjdCh0aGlzLl9kZWYubXV0YXRpb25zLCBtZXJnZVByb2NlZHVyZXMoY2hpbGRSb3V0ZXIuX2RlZi5tdXRhdGlvbnMpKSxcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbnM6IHNhZmVPYmplY3QodGhpcy5fZGVmLnN1YnNjcmlwdGlvbnMsIG1lcmdlUHJvY2VkdXJlcyhjaGlsZFJvdXRlci5fZGVmLnN1YnNjcmlwdGlvbnMpKVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAqIEludm9rZSBwcm9jZWR1cmUuIE9ubHkgZm9yIGludGVybmFsIHVzZSB3aXRoaW4gbGlicmFyeS5cbiAgICovIGFzeW5jIGNhbGwob3B0cykge1xuICAgICAgICBjb25zdCB7IHR5cGUgLCBwYXRoICB9ID0gb3B0cztcbiAgICAgICAgY29uc3QgZGVmVGFyZ2V0ID0gUFJPQ0VEVVJFX0RFRklOSVRJT05fTUFQW3R5cGVdO1xuICAgICAgICBjb25zdCBkZWZzID0gdGhpcy5fZGVmW2RlZlRhcmdldF07XG4gICAgICAgIGNvbnN0IHByb2NlZHVyZSA9IGRlZnNbcGF0aF07XG4gICAgICAgIGlmICghcHJvY2VkdXJlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVFJQQ0Vycm9yLlRSUENFcnJvcih7XG4gICAgICAgICAgICAgICAgY29kZTogJ05PVF9GT1VORCcsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogYE5vIFwiJHt0eXBlfVwiLXByb2NlZHVyZSBvbiBwYXRoIFwiJHtwYXRofVwiYFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb2NlZHVyZS5jYWxsKG9wdHMpO1xuICAgIH1cbiAgICBjcmVhdGVDYWxsZXIoY3R4KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBxdWVyeTogKHBhdGgsIC4uLmFyZ3MpPT57XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FsbCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdxdWVyeScsXG4gICAgICAgICAgICAgICAgICAgIGN0eCxcbiAgICAgICAgICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgICAgICAgICAgcmF3SW5wdXQ6IGFyZ3NbMF1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtdXRhdGlvbjogKHBhdGgsIC4uLmFyZ3MpPT57XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FsbCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdtdXRhdGlvbicsXG4gICAgICAgICAgICAgICAgICAgIGN0eCxcbiAgICAgICAgICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgICAgICAgICAgcmF3SW5wdXQ6IGFyZ3NbMF1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdWJzY3JpcHRpb246IChwYXRoLCAuLi5hcmdzKT0+e1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNhbGwoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnc3Vic2NyaXB0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgY3R4LFxuICAgICAgICAgICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgICAgICAgICByYXdJbnB1dDogYXJnc1swXVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICogRnVuY3Rpb24gdG8gYmUgY2FsbGVkIGJlZm9yZSBhbnkgcHJvY2VkdXJlIGlzIGludm9rZWRcbiAgICogQGxpbmsgaHR0cHM6Ly90cnBjLmlvL2RvY3MvbWlkZGxld2FyZXNcbiAgICovIG1pZGRsZXdhcmUobWlkZGxld2FyZSkge1xuICAgICAgICByZXR1cm4gbmV3IFJvdXRlcih7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBtaWRkbGV3YXJlczogW1xuICAgICAgICAgICAgICAgIC4uLnRoaXMuX2RlZi5taWRkbGV3YXJlcyxcbiAgICAgICAgICAgICAgICBtaWRkbGV3YXJlXG4gICAgICAgICAgICBdXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICogRm9ybWF0IGVycm9yc1xuICAgKiBAbGluayBodHRwczovL3RycGMuaW8vZG9jcy9lcnJvci1mb3JtYXR0aW5nXG4gICAqLyBmb3JtYXRFcnJvcihlcnJvckZvcm1hdHRlcikge1xuICAgICAgICBpZiAodGhpcy5fZGVmLmVycm9yRm9ybWF0dGVyICE9PSBjb25maWcuZGVmYXVsdEZvcm1hdHRlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3Ugc2VlbSB0byBoYXZlIGRvdWJsZSBgZm9ybWF0RXJyb3IoKWAtY2FsbHMgaW4geW91ciByb3V0ZXIgdHJlZScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUm91dGVyKHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIGVycm9yRm9ybWF0dGVyOiBlcnJvckZvcm1hdHRlclxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0RXJyb3JTaGFwZShvcHRzKSB7XG4gICAgICAgIGNvbnN0IHsgcGF0aCAsIGVycm9yICB9ID0gb3B0cztcbiAgICAgICAgY29uc3QgeyBjb2RlICB9ID0gb3B0cy5lcnJvcjtcbiAgICAgICAgY29uc3Qgc2hhcGUgPSB7XG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlLFxuICAgICAgICAgICAgY29kZTogY29kZXMuVFJQQ19FUlJPUl9DT0RFU19CWV9LRVlbY29kZV0sXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgY29kZSxcbiAgICAgICAgICAgICAgICBodHRwU3RhdHVzOiBpbmRleC5nZXRIVFRQU3RhdHVzQ29kZUZyb21FcnJvcihlcnJvcilcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGdsb2JhbFRoaXMucHJvY2Vzcz8uZW52Py5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHR5cGVvZiBvcHRzLmVycm9yLnN0YWNrID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgc2hhcGUuZGF0YS5zdGFjayA9IG9wdHMuZXJyb3Iuc3RhY2s7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBwYXRoID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgc2hhcGUuZGF0YS5wYXRoID0gcGF0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmVycm9yRm9ybWF0dGVyKHtcbiAgICAgICAgICAgIC4uLm9wdHMsXG4gICAgICAgICAgICBzaGFwZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAqIEFkZCBkYXRhIHRyYW5zZm9ybWVyIHRvIHNlcmlhbGl6ZS9kZXNlcmlhbGl6ZSBpbnB1dCBhcmdzICsgb3V0cHV0XG4gICAqIEBsaW5rIGh0dHBzOi8vdHJwYy5pby9kb2NzL2RhdGEtdHJhbnNmb3JtZXJzXG4gICAqLyB0cmFuc2Zvcm1lcihfdHJhbnNmb3JtZXIpIHtcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtZXIgPSBnZXREYXRhVHJhbnNmb3JtZXIoX3RyYW5zZm9ybWVyKTtcbiAgICAgICAgaWYgKHRoaXMuX2RlZi50cmFuc2Zvcm1lciAhPT0gY29uZmlnLmRlZmF1bHRUcmFuc2Zvcm1lcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3Ugc2VlbSB0byBoYXZlIGRvdWJsZSBgdHJhbnNmb3JtZXIoKWAtY2FsbHMgaW4geW91ciByb3V0ZXIgdHJlZScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUm91dGVyKHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIHRyYW5zZm9ybWVyXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICogRmxhdHRlbnMgdGhlIGdlbmVyaWNzIG9mIFRRdWVyaWVzL1RNdXRhdGlvbnMvVFN1YnNjcmlwdGlvbnMuXG4gICAqIOKaoO+4jyBFeHBlcmltZW50YWwgLSBtaWdodCBkaXNhcHBlYXIuIOKaoO+4j1xuICAgKlxuICAgKiBAYWxwaGFcbiAgICovIGZsYXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICogSW50ZXJvcCBtb2RlIGZvciB2OS54IC0+IHYxMC54XG4gICAqLyBpbnRlcm9wKCkge1xuICAgICAgICByZXR1cm4gbWlncmF0ZVJvdXRlcih0aGlzKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZGVmKXtcbiAgICAgICAgdGhpcy5fZGVmID0ge1xuICAgICAgICAgICAgcXVlcmllczogZGVmPy5xdWVyaWVzID8/IHNhZmVPYmplY3QoKSxcbiAgICAgICAgICAgIG11dGF0aW9uczogZGVmPy5tdXRhdGlvbnMgPz8gc2FmZU9iamVjdCgpLFxuICAgICAgICAgICAgc3Vic2NyaXB0aW9uczogZGVmPy5zdWJzY3JpcHRpb25zID8/IHNhZmVPYmplY3QoKSxcbiAgICAgICAgICAgIG1pZGRsZXdhcmVzOiBkZWY/Lm1pZGRsZXdhcmVzID8/IFtdLFxuICAgICAgICAgICAgZXJyb3JGb3JtYXR0ZXI6IGRlZj8uZXJyb3JGb3JtYXR0ZXIgPz8gY29uZmlnLmRlZmF1bHRGb3JtYXR0ZXIsXG4gICAgICAgICAgICB0cmFuc2Zvcm1lcjogZGVmPy50cmFuc2Zvcm1lciA/PyBjb25maWcuZGVmYXVsdFRyYW5zZm9ybWVyXG4gICAgICAgIH07XG4gICAgfVxufVxuLyoqXG4gKiBAZGVwcmVjYXRlZFxuICovIGZ1bmN0aW9uIHJvdXRlcigpIHtcbiAgICByZXR1cm4gbmV3IFJvdXRlcigpO1xufVxuXG5mdW5jdGlvbiBtZXJnZVJvdXRlcnMoLi4ucm91dGVyTGlzdCkge1xuICAgIGNvbnN0IHJlY29yZCA9IG1lcmdlV2l0aG91dE92ZXJyaWRlcyh7fSwgLi4ucm91dGVyTGlzdC5tYXAoKHIpPT5yLl9kZWYucmVjb3JkKSk7XG4gICAgY29uc3QgZXJyb3JGb3JtYXR0ZXIgPSByb3V0ZXJMaXN0LnJlZHVjZSgoY3VycmVudEVycm9yRm9ybWF0dGVyLCBuZXh0Um91dGVyKT0+e1xuICAgICAgICBpZiAobmV4dFJvdXRlci5fZGVmLl9jb25maWcuZXJyb3JGb3JtYXR0ZXIgJiYgbmV4dFJvdXRlci5fZGVmLl9jb25maWcuZXJyb3JGb3JtYXR0ZXIgIT09IGNvbmZpZy5kZWZhdWx0Rm9ybWF0dGVyKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudEVycm9yRm9ybWF0dGVyICE9PSBjb25maWcuZGVmYXVsdEZvcm1hdHRlciAmJiBjdXJyZW50RXJyb3JGb3JtYXR0ZXIgIT09IG5leHRSb3V0ZXIuX2RlZi5fY29uZmlnLmVycm9yRm9ybWF0dGVyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3Ugc2VlbSB0byBoYXZlIHNldmVyYWwgZXJyb3IgZm9ybWF0dGVycycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5leHRSb3V0ZXIuX2RlZi5fY29uZmlnLmVycm9yRm9ybWF0dGVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjdXJyZW50RXJyb3JGb3JtYXR0ZXI7XG4gICAgfSwgY29uZmlnLmRlZmF1bHRGb3JtYXR0ZXIpO1xuICAgIGNvbnN0IHRyYW5zZm9ybWVyID0gcm91dGVyTGlzdC5yZWR1Y2UoKHByZXYsIGN1cnJlbnQpPT57XG4gICAgICAgIGlmIChjdXJyZW50Ll9kZWYuX2NvbmZpZy50cmFuc2Zvcm1lciAmJiBjdXJyZW50Ll9kZWYuX2NvbmZpZy50cmFuc2Zvcm1lciAhPT0gY29uZmlnLmRlZmF1bHRUcmFuc2Zvcm1lcikge1xuICAgICAgICAgICAgaWYgKHByZXYgIT09IGNvbmZpZy5kZWZhdWx0VHJhbnNmb3JtZXIgJiYgcHJldiAhPT0gY3VycmVudC5fZGVmLl9jb25maWcudHJhbnNmb3JtZXIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBzZWVtIHRvIGhhdmUgc2V2ZXJhbCB0cmFuc2Zvcm1lcnMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50Ll9kZWYuX2NvbmZpZy50cmFuc2Zvcm1lcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJldjtcbiAgICB9LCBjb25maWcuZGVmYXVsdFRyYW5zZm9ybWVyKTtcbiAgICBjb25zdCByb3V0ZXIgPSBjb25maWcuY3JlYXRlUm91dGVyRmFjdG9yeSh7XG4gICAgICAgIGVycm9yRm9ybWF0dGVyLFxuICAgICAgICB0cmFuc2Zvcm1lcixcbiAgICAgICAgaXNEZXY6IHJvdXRlckxpc3Quc29tZSgocik9PnIuX2RlZi5fY29uZmlnLmlzRGV2KSxcbiAgICAgICAgYWxsb3dPdXRzaWRlT2ZTZXJ2ZXI6IHJvdXRlckxpc3Quc29tZSgocik9PnIuX2RlZi5fY29uZmlnLmFsbG93T3V0c2lkZU9mU2VydmVyKSxcbiAgICAgICAgaXNTZXJ2ZXI6IHJvdXRlckxpc3Quc29tZSgocik9PnIuX2RlZi5fY29uZmlnLmlzU2VydmVyKSxcbiAgICAgICAgJHR5cGVzOiByb3V0ZXJMaXN0WzBdPy5fZGVmLl9jb25maWcuJHR5cGVzXG4gICAgfSkocmVjb3JkKTtcbiAgICByZXR1cm4gcm91dGVyO1xufVxuXG4vKipcbiAqIFRPRE86IFRoaXMgY2FuIGJlIGltcHJvdmVkOlxuICogLSBXZSBzaG91bGQgYmUgYWJsZSB0byBjaGFpbiBgLm1ldGEoKWAvYC5jb250ZXh0KClgIG9ubHkgb25jZVxuICogLSBTaW1wbGlmeSB0eXBpbmdzXG4gKiAtIERvZXNuJ3QgbmVlZCB0byBiZSBhIGNsYXNzIGJ1dCBpdCBkb2Vzbid0IHJlYWxseSBodXJ0IGVpdGhlclxuICovIGNsYXNzIFRSUENCdWlsZGVyIHtcbiAgICBjb250ZXh0KCkge1xuICAgICAgICByZXR1cm4gbmV3IFRSUENCdWlsZGVyKCk7XG4gICAgfVxuICAgIG1ldGEoKSB7XG4gICAgICAgIHJldHVybiBuZXcgVFJQQ0J1aWxkZXIoKTtcbiAgICB9XG4gICAgY3JlYXRlKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVRSUENJbm5lcigpKG9wdGlvbnMpO1xuICAgIH1cbn1cbi8qKlxuICogSW5pdGlhbGl6ZSB0UlBDIC0gZG9uZSBleGFjdGx5IG9uY2UgcGVyIGJhY2tlbmRcbiAqLyBjb25zdCBpbml0VFJQQyA9IG5ldyBUUlBDQnVpbGRlcigpO1xuZnVuY3Rpb24gY3JlYXRlVFJQQ0lubmVyKCkge1xuICAgIHJldHVybiBmdW5jdGlvbiBpbml0VFJQQ0lubmVyKHJ1bnRpbWUpIHtcbiAgICAgICAgY29uc3QgZXJyb3JGb3JtYXR0ZXIgPSBydW50aW1lPy5lcnJvckZvcm1hdHRlciA/PyBjb25maWcuZGVmYXVsdEZvcm1hdHRlcjtcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtZXIgPSBjb25maWcuZ2V0RGF0YVRyYW5zZm9ybWVyKHJ1bnRpbWU/LnRyYW5zZm9ybWVyID8/IGNvbmZpZy5kZWZhdWx0VHJhbnNmb3JtZXIpO1xuICAgICAgICBjb25zdCBjb25maWckMSA9IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVyLFxuICAgICAgICAgICAgaXNEZXY6IHJ1bnRpbWU/LmlzRGV2ID8/IGdsb2JhbFRoaXMucHJvY2Vzcz8uZW52Py5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nLFxuICAgICAgICAgICAgYWxsb3dPdXRzaWRlT2ZTZXJ2ZXI6IHJ1bnRpbWU/LmFsbG93T3V0c2lkZU9mU2VydmVyID8/IGZhbHNlLFxuICAgICAgICAgICAgZXJyb3JGb3JtYXR0ZXIsXG4gICAgICAgICAgICBpc1NlcnZlcjogcnVudGltZT8uaXNTZXJ2ZXIgPz8gY29uZmlnLmlzU2VydmVyRGVmYXVsdCxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICogQGludGVybmFsXG4gICAgICAgKi8gJHR5cGVzOiBpbmRleC5jcmVhdGVGbGF0UHJveHkoKGtleSk9PntcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRyaWVkIHRvIGFjY2VzcyBcIiR0eXBlcy4ke2tleX1cIiB3aGljaCBpcyBub3QgYXZhaWxhYmxlIGF0IHJ1bnRpbWVgKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH07XG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIFNlcnZlciBjaGVja1xuICAgICAgICAgICAgY29uc3QgaXNTZXJ2ZXIgPSBydW50aW1lPy5pc1NlcnZlciA/PyBjb25maWcuaXNTZXJ2ZXJEZWZhdWx0O1xuICAgICAgICAgICAgaWYgKCFpc1NlcnZlciAmJiBydW50aW1lPy5hbGxvd091dHNpZGVPZlNlcnZlciAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgWW91J3JlIHRyeWluZyB0byB1c2UgQHRycGMvc2VydmVyIGluIGEgbm9uLXNlcnZlciBlbnZpcm9ubWVudC4gVGhpcyBpcyBub3Qgc3VwcG9ydGVkIGJ5IGRlZmF1bHQuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICogVGhlc2UgYXJlIGp1c3QgdHlwZXMsIHRoZXkgY2FuJ3QgYmUgdXNlZFxuICAgICAgICogQGludGVybmFsXG4gICAgICAgKi8gX2NvbmZpZzogY29uZmlnJDEsXG4gICAgICAgICAgICAvKipcbiAgICAgICAqIEJ1aWxkZXIgb2JqZWN0IGZvciBjcmVhdGluZyBwcm9jZWR1cmVzXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdHJwYy5pby9kb2NzL3NlcnZlci9wcm9jZWR1cmVzXG4gICAgICAgKi8gcHJvY2VkdXJlOiBjcmVhdGVCdWlsZGVyKHtcbiAgICAgICAgICAgICAgICBtZXRhOiBydW50aW1lPy5kZWZhdWx0TWV0YVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAvKipcbiAgICAgICAqIENyZWF0ZSByZXVzYWJsZSBtaWRkbGV3YXJlc1xuICAgICAgICogQHNlZSBodHRwczovL3RycGMuaW8vZG9jcy9zZXJ2ZXIvbWlkZGxld2FyZXNcbiAgICAgICAqLyBtaWRkbGV3YXJlOiBjcmVhdGVNaWRkbGV3YXJlRmFjdG9yeSgpLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgKiBDcmVhdGUgYSByb3V0ZXJcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90cnBjLmlvL2RvY3Mvc2VydmVyL3JvdXRlcnNcbiAgICAgICAqLyByb3V0ZXI6IGNvbmZpZy5jcmVhdGVSb3V0ZXJGYWN0b3J5KGNvbmZpZyQxKSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICogTWVyZ2UgUm91dGVyc1xuICAgICAgICogQHNlZSBodHRwczovL3RycGMuaW8vZG9jcy9zZXJ2ZXIvbWVyZ2luZy1yb3V0ZXJzXG4gICAgICAgKi8gbWVyZ2VSb3V0ZXJzLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgKiBDcmVhdGUgYSBzZXJ2ZXItc2lkZSBjYWxsZXIgZm9yIGEgcm91dGVyXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdHJwYy5pby9kb2NzL3NlcnZlci9zZXJ2ZXItc2lkZS1jYWxsc1xuICAgICAgICovIGNyZWF0ZUNhbGxlckZhY3Rvcnk6IGNvbmZpZy5jcmVhdGVDYWxsZXJGYWN0b3J5KClcbiAgICAgICAgfTtcbiAgICB9O1xufVxuXG5leHBvcnRzLmNhbGxQcm9jZWR1cmUgPSBjb25maWcuY2FsbFByb2NlZHVyZTtcbmV4cG9ydHMuY3JlYXRlQ2FsbGVyRmFjdG9yeSA9IGNvbmZpZy5jcmVhdGVDYWxsZXJGYWN0b3J5O1xuZXhwb3J0cy5kZWZhdWx0VHJhbnNmb3JtZXIgPSBjb25maWcuZGVmYXVsdFRyYW5zZm9ybWVyO1xuZXhwb3J0cy5nZXREYXRhVHJhbnNmb3JtZXIgPSBjb25maWcuZ2V0RGF0YVRyYW5zZm9ybWVyO1xuZXhwb3J0cy5wcm9jZWR1cmVUeXBlcyA9IGNvbmZpZy5wcm9jZWR1cmVUeXBlcztcbmV4cG9ydHMuVFJQQ0Vycm9yID0gVFJQQ0Vycm9yLlRSUENFcnJvcjtcbmV4cG9ydHMuZ2V0VFJQQ0Vycm9yRnJvbVVua25vd24gPSBUUlBDRXJyb3IuZ2V0VFJQQ0Vycm9yRnJvbVVua25vd247XG5leHBvcnRzLmNyZWF0ZUlucHV0TWlkZGxld2FyZSA9IGNyZWF0ZUlucHV0TWlkZGxld2FyZTtcbmV4cG9ydHMuY3JlYXRlT3V0cHV0TWlkZGxld2FyZSA9IGNyZWF0ZU91dHB1dE1pZGRsZXdhcmU7XG5leHBvcnRzLmV4cGVyaW1lbnRhbF9zdGFuZGFsb25lTWlkZGxld2FyZSA9IGV4cGVyaW1lbnRhbF9zdGFuZGFsb25lTWlkZGxld2FyZTtcbmV4cG9ydHMuaW5pdFRSUEMgPSBpbml0VFJQQztcbmV4cG9ydHMucm91dGVyID0gcm91dGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBpZGVudGl0eSh4KSB7XG4gICAgcmV0dXJuIHg7XG59XG5cbi8qKiBAaW50ZXJuYWwgKi8gZnVuY3Rpb24gcGlwZUZyb21BcnJheShmbnMpIHtcbiAgICBpZiAoZm5zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gaWRlbnRpdHk7XG4gICAgfVxuICAgIGlmIChmbnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgIHJldHVybiBmbnNbMF07XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiBwaXBlZChpbnB1dCkge1xuICAgICAgICByZXR1cm4gZm5zLnJlZHVjZSgocHJldiwgZm4pPT5mbihwcmV2KSwgaW5wdXQpO1xuICAgIH07XG59XG5cbmZ1bmN0aW9uIGlzT2JzZXJ2YWJsZSh4KSB7XG4gICAgcmV0dXJuIHR5cGVvZiB4ID09PSAnb2JqZWN0JyAmJiB4ICE9PSBudWxsICYmICdzdWJzY3JpYmUnIGluIHg7XG59XG5mdW5jdGlvbiBvYnNlcnZhYmxlKHN1YnNjcmliZSkge1xuICAgIGNvbnN0IHNlbGYgPSB7XG4gICAgICAgIHN1YnNjcmliZSAob2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgIGxldCB0ZWFyZG93blJlZiA9IG51bGw7XG4gICAgICAgICAgICBsZXQgaXNEb25lID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgdW5zdWJzY3JpYmVkID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgdGVhcmRvd25JbW1lZGlhdGVseSA9IGZhbHNlO1xuICAgICAgICAgICAgZnVuY3Rpb24gdW5zdWJzY3JpYmUoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRlYXJkb3duUmVmID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRlYXJkb3duSW1tZWRpYXRlbHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh1bnN1YnNjcmliZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB1bnN1YnNjcmliZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGVhcmRvd25SZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgdGVhcmRvd25SZWYoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRlYXJkb3duUmVmKSB7XG4gICAgICAgICAgICAgICAgICAgIHRlYXJkb3duUmVmLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGVhcmRvd25SZWYgPSBzdWJzY3JpYmUoe1xuICAgICAgICAgICAgICAgIG5leHQgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0RvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5uZXh0Py4odmFsdWUpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZXJyb3IgKGVycikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNEb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaXNEb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIuZXJyb3I/LihlcnIpO1xuICAgICAgICAgICAgICAgICAgICB1bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY29tcGxldGUgKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNEb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaXNEb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIuY29tcGxldGU/LigpO1xuICAgICAgICAgICAgICAgICAgICB1bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHRlYXJkb3duSW1tZWRpYXRlbHkpIHtcbiAgICAgICAgICAgICAgICB1bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1bnN1YnNjcmliZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgcGlwZSAoLi4ub3BlcmF0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIHBpcGVGcm9tQXJyYXkob3BlcmF0aW9ucykoc2VsZik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBzZWxmO1xufVxuXG5leHBvcnRzLmlzT2JzZXJ2YWJsZSA9IGlzT2JzZXJ2YWJsZTtcbmV4cG9ydHMub2JzZXJ2YWJsZSA9IG9ic2VydmFibGU7XG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBvYnNlcnZhYmxlID0gcmVxdWlyZSgnLi4vb2JzZXJ2YWJsZS00NjQxMTZhYy5qcycpO1xuXG5mdW5jdGlvbiBzaGFyZShfb3B0cykge1xuICAgIHJldHVybiAob3JpZ2luYWxPYnNlcnZlcik9PntcbiAgICAgICAgbGV0IHJlZkNvdW50ID0gMDtcbiAgICAgICAgbGV0IHN1YnNjcmlwdGlvbiA9IG51bGw7XG4gICAgICAgIGNvbnN0IG9ic2VydmVycyA9IFtdO1xuICAgICAgICBmdW5jdGlvbiBzdGFydElmTmVlZGVkKCkge1xuICAgICAgICAgICAgaWYgKHN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbiA9IG9yaWdpbmFsT2JzZXJ2ZXIuc3Vic2NyaWJlKHtcbiAgICAgICAgICAgICAgICBuZXh0ICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG9ic2VydmVyIG9mIG9ic2VydmVycyl7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5uZXh0Py4odmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBlcnJvciAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBvYnNlcnZlciBvZiBvYnNlcnZlcnMpe1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIuZXJyb3I/LihlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGNvbXBsZXRlICgpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBvYnNlcnZlciBvZiBvYnNlcnZlcnMpe1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIuY29tcGxldGU/LigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcmVzZXRJZk5lZWRlZCgpIHtcbiAgICAgICAgICAgIC8vIFwicmVzZXRPblJlZkNvdW50WmVyb1wiXG4gICAgICAgICAgICBpZiAocmVmQ291bnQgPT09IDAgJiYgc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgX3N1YiA9IHN1YnNjcmlwdGlvbjtcbiAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb24gPSBudWxsO1xuICAgICAgICAgICAgICAgIF9zdWIudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3Vic2NyaWJlIChvYnNlcnZlcikge1xuICAgICAgICAgICAgICAgIHJlZkNvdW50Kys7XG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXJzLnB1c2gob2JzZXJ2ZXIpO1xuICAgICAgICAgICAgICAgIHN0YXJ0SWZOZWVkZWQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB1bnN1YnNjcmliZSAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWZDb3VudC0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzZXRJZk5lZWRlZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBvYnNlcnZlcnMuZmluZEluZGV4KCh2KT0+diA9PT0gb2JzZXJ2ZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYnNlcnZlcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gbWFwKHByb2plY3QpIHtcbiAgICByZXR1cm4gKG9yaWdpbmFsT2JzZXJ2ZXIpPT57XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdWJzY3JpYmUgKG9ic2VydmVyKSB7XG4gICAgICAgICAgICAgICAgbGV0IGluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBvcmlnaW5hbE9ic2VydmVyLnN1YnNjcmliZSh7XG4gICAgICAgICAgICAgICAgICAgIG5leHQgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5uZXh0Py4ocHJvamVjdCh2YWx1ZSwgaW5kZXgrKykpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBlcnJvciAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLmVycm9yPy4oZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZSAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5jb21wbGV0ZT8uKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3Vic2NyaXB0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG59XG5cbmZ1bmN0aW9uIHRhcChvYnNlcnZlcikge1xuICAgIHJldHVybiAob3JpZ2luYWxPYnNlcnZlcik9PntcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN1YnNjcmliZSAob2JzZXJ2ZXIyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsT2JzZXJ2ZXIuc3Vic2NyaWJlKHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCAodikge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dD8uKHYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIyLm5leHQ/Lih2KTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IgKHYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLmVycm9yPy4odik7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYnNlcnZlcjIuZXJyb3I/Lih2KTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgY29tcGxldGUgKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIuY29tcGxldGU/LigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIyLmNvbXBsZXRlPy4oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG59XG5cbmNsYXNzIE9ic2VydmFibGVBYm9ydEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2Upe1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ09ic2VydmFibGVBYm9ydEVycm9yJztcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIE9ic2VydmFibGVBYm9ydEVycm9yLnByb3RvdHlwZSk7XG4gICAgfVxufVxuLyoqIEBpbnRlcm5hbCAqLyBmdW5jdGlvbiBvYnNlcnZhYmxlVG9Qcm9taXNlKG9ic2VydmFibGUpIHtcbiAgICBsZXQgYWJvcnQ7XG4gICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpPT57XG4gICAgICAgIGxldCBpc0RvbmUgPSBmYWxzZTtcbiAgICAgICAgZnVuY3Rpb24gb25Eb25lKCkge1xuICAgICAgICAgICAgaWYgKGlzRG9uZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlzRG9uZSA9IHRydWU7XG4gICAgICAgICAgICByZWplY3QobmV3IE9ic2VydmFibGVBYm9ydEVycm9yKCdUaGlzIG9wZXJhdGlvbiB3YXMgYWJvcnRlZC4nKSk7XG4gICAgICAgICAgICBvYnMkLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb2JzJCA9IG9ic2VydmFibGUuc3Vic2NyaWJlKHtcbiAgICAgICAgICAgIG5leHQgKGRhdGEpIHtcbiAgICAgICAgICAgICAgICBpc0RvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJlc29sdmUoZGF0YSk7XG4gICAgICAgICAgICAgICAgb25Eb25lKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZXJyb3IgKGRhdGEpIHtcbiAgICAgICAgICAgICAgICBpc0RvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJlamVjdChkYXRhKTtcbiAgICAgICAgICAgICAgICBvbkRvbmUoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb21wbGV0ZSAoKSB7XG4gICAgICAgICAgICAgICAgaXNEb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBvbkRvbmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGFib3J0ID0gb25Eb25lO1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIHByb21pc2UsXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgIGFib3J0OiBhYm9ydFxuICAgIH07XG59XG5cbmV4cG9ydHMuaXNPYnNlcnZhYmxlID0gb2JzZXJ2YWJsZS5pc09ic2VydmFibGU7XG5leHBvcnRzLm9ic2VydmFibGUgPSBvYnNlcnZhYmxlLm9ic2VydmFibGU7XG5leHBvcnRzLm1hcCA9IG1hcDtcbmV4cG9ydHMub2JzZXJ2YWJsZVRvUHJvbWlzZSA9IG9ic2VydmFibGVUb1Byb21pc2U7XG5leHBvcnRzLnNoYXJlID0gc2hhcmU7XG5leHBvcnRzLnRhcCA9IHRhcDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGluZGV4ID0gcmVxdWlyZSgnLi9pbmRleC03ODRmZjY0Ny5qcycpO1xudmFyIGNvZGVzID0gcmVxdWlyZSgnLi9jb2Rlcy04N2Y2ODI0Yi5qcycpO1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovIGZ1bmN0aW9uIGdldEVycm9yU2hhcGUob3B0cykge1xuICAgIGNvbnN0IHsgcGF0aCAsIGVycm9yICwgY29uZmlnICB9ID0gb3B0cztcbiAgICBjb25zdCB7IGNvZGUgIH0gPSBvcHRzLmVycm9yO1xuICAgIGNvbnN0IHNoYXBlID0ge1xuICAgICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlLFxuICAgICAgICBjb2RlOiBjb2Rlcy5UUlBDX0VSUk9SX0NPREVTX0JZX0tFWVtjb2RlXSxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgY29kZSxcbiAgICAgICAgICAgIGh0dHBTdGF0dXM6IGluZGV4LmdldEhUVFBTdGF0dXNDb2RlRnJvbUVycm9yKGVycm9yKVxuICAgICAgICB9XG4gICAgfTtcbiAgICBpZiAoY29uZmlnLmlzRGV2ICYmIHR5cGVvZiBvcHRzLmVycm9yLnN0YWNrID09PSAnc3RyaW5nJykge1xuICAgICAgICBzaGFwZS5kYXRhLnN0YWNrID0gb3B0cy5lcnJvci5zdGFjaztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBwYXRoID09PSAnc3RyaW5nJykge1xuICAgICAgICBzaGFwZS5kYXRhLnBhdGggPSBwYXRoO1xuICAgIH1cbiAgICByZXR1cm4gY29uZmlnLmVycm9yRm9ybWF0dGVyKHtcbiAgICAgICAgLi4ub3B0cyxcbiAgICAgICAgc2hhcGVcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gdHJhbnNmb3JtVFJQQ1Jlc3BvbnNlSXRlbShjb25maWcsIGl0ZW0pIHtcbiAgICBpZiAoJ2Vycm9yJyBpbiBpdGVtKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5pdGVtLFxuICAgICAgICAgICAgZXJyb3I6IGNvbmZpZy50cmFuc2Zvcm1lci5vdXRwdXQuc2VyaWFsaXplKGl0ZW0uZXJyb3IpXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmICgnZGF0YScgaW4gaXRlbS5yZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLml0ZW0sXG4gICAgICAgICAgICByZXN1bHQ6IHtcbiAgICAgICAgICAgICAgICAuLi5pdGVtLnJlc3VsdCxcbiAgICAgICAgICAgICAgICBkYXRhOiBjb25maWcudHJhbnNmb3JtZXIub3V0cHV0LnNlcmlhbGl6ZShpdGVtLnJlc3VsdC5kYXRhKVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gaXRlbTtcbn1cbi8qKlxuICogVGFrZXMgYSB1bnNlcmlhbGl6ZWQgYFRSUENSZXNwb25zZWAgYW5kIHNlcmlhbGl6ZXMgaXQgd2l0aCB0aGUgcm91dGVyJ3MgdHJhbnNmb3JtZXJzXG4gKiovIGZ1bmN0aW9uIHRyYW5zZm9ybVRSUENSZXNwb25zZShjb25maWcsIGl0ZW1Pckl0ZW1zKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoaXRlbU9ySXRlbXMpID8gaXRlbU9ySXRlbXMubWFwKChpdGVtKT0+dHJhbnNmb3JtVFJQQ1Jlc3BvbnNlSXRlbShjb25maWcsIGl0ZW0pKSA6IHRyYW5zZm9ybVRSUENSZXNwb25zZUl0ZW0oY29uZmlnLCBpdGVtT3JJdGVtcyk7XG59XG5cbmV4cG9ydHMuZ2V0RXJyb3JTaGFwZSA9IGdldEVycm9yU2hhcGU7XG5leHBvcnRzLnRyYW5zZm9ybVRSUENSZXNwb25zZSA9IHRyYW5zZm9ybVRSUENSZXNwb25zZTtcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIGluZGV4ID0gcmVxdWlyZSgnLi4vaW5kZXgtNzg0ZmY2NDcuanMnKTtcbnZhciB0cmFuc2Zvcm1UUlBDUmVzcG9uc2UgPSByZXF1aXJlKCcuLi90cmFuc2Zvcm1UUlBDUmVzcG9uc2UtZTY1ZjM0ZTkuanMnKTtcbnZhciBnZXRDYXVzZUZyb21Vbmtub3duID0gcmVxdWlyZSgnLi4vZ2V0Q2F1c2VGcm9tVW5rbm93bi1kNTM1MjY0YS5qcycpO1xucmVxdWlyZSgnLi4vY29kZXMtODdmNjgyNGIuanMnKTtcblxuXG5cbmV4cG9ydHMuY3JlYXRlRmxhdFByb3h5ID0gaW5kZXguY3JlYXRlRmxhdFByb3h5O1xuZXhwb3J0cy5jcmVhdGVSZWN1cnNpdmVQcm94eSA9IGluZGV4LmNyZWF0ZVJlY3Vyc2l2ZVByb3h5O1xuZXhwb3J0cy5nZXRFcnJvclNoYXBlID0gdHJhbnNmb3JtVFJQQ1Jlc3BvbnNlLmdldEVycm9yU2hhcGU7XG5leHBvcnRzLnRyYW5zZm9ybVRSUENSZXNwb25zZSA9IHRyYW5zZm9ybVRSUENSZXNwb25zZS50cmFuc2Zvcm1UUlBDUmVzcG9uc2U7XG5leHBvcnRzLmdldENhdXNlRnJvbVVua25vd24gPSBnZXRDYXVzZUZyb21Vbmtub3duLmdldENhdXNlRnJvbVVua25vd247XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaXNUUlBDUmVxdWVzdFdpdGhJZCA9IGV4cG9ydHMuaXNUUlBDUmVxdWVzdCA9IGV4cG9ydHMuaXNUUlBDUmVzcG9uc2UgPSBleHBvcnRzLmlzVFJQQ01lc3NhZ2UgPSB2b2lkIDA7XG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KG9iaikge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiBvYmogIT09IG51bGwgJiYgIUFycmF5LmlzQXJyYXkob2JqKTtcbn1cbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKHgpIHtcbiAgICByZXR1cm4geCA9PT0gbnVsbCB8fCB4ID09PSB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBpc1RSUENNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gQm9vbGVhbihpc1BsYWluT2JqZWN0KG1lc3NhZ2UpICYmICd0cnBjJyBpbiBtZXNzYWdlICYmIGlzUGxhaW5PYmplY3QobWVzc2FnZS50cnBjKSk7XG59XG5leHBvcnRzLmlzVFJQQ01lc3NhZ2UgPSBpc1RSUENNZXNzYWdlO1xuZnVuY3Rpb24gaXNUUlBDTWVzc2FnZVdpdGhJZChtZXNzYWdlKSB7XG4gICAgcmV0dXJuIGlzVFJQQ01lc3NhZ2UobWVzc2FnZSkgJiYgJ2lkJyBpbiBtZXNzYWdlLnRycGMgJiYgIWlzTnVsbE9yVW5kZWZpbmVkKG1lc3NhZ2UudHJwYy5pZCk7XG59XG4vLyByZXBvbnNlIG5lZWRzIGVycm9yIG9yIHJlc3VsdFxuZnVuY3Rpb24gaXNUUlBDUmVzcG9uc2UobWVzc2FnZSkge1xuICAgIHJldHVybiBpc1RSUENNZXNzYWdlV2l0aElkKG1lc3NhZ2UpICYmICgnZXJyb3InIGluIG1lc3NhZ2UudHJwYyB8fCAncmVzdWx0JyBpbiBtZXNzYWdlLnRycGMpO1xufVxuZXhwb3J0cy5pc1RSUENSZXNwb25zZSA9IGlzVFJQQ1Jlc3BvbnNlO1xuLy8gcmVxdWVzdCBuZWVkcyBtZXRob2RcbmZ1bmN0aW9uIGlzVFJQQ1JlcXVlc3QobWVzc2FnZSkge1xuICAgIHJldHVybiBpc1RSUENNZXNzYWdlV2l0aElkKG1lc3NhZ2UpICYmICdtZXRob2QnIGluIG1lc3NhZ2UudHJwYztcbn1cbmV4cG9ydHMuaXNUUlBDUmVxdWVzdCA9IGlzVFJQQ1JlcXVlc3Q7XG5mdW5jdGlvbiBpc1RSUENSZXF1ZXN0V2l0aElkKG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gaXNUUlBDUmVxdWVzdChtZXNzYWdlKSAmJiBpc1RSUENNZXNzYWdlV2l0aElkKG1lc3NhZ2UpO1xufVxuZXhwb3J0cy5pc1RSUENSZXF1ZXN0V2l0aElkID0gaXNUUlBDUmVxdWVzdFdpdGhJZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRycGNNZXNzYWdlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRFcnJvckZyb21Vbmtub3duID0gdm9pZCAwO1xuY29uc3Qgc2VydmVyXzEgPSByZXF1aXJlKFwiQHRycGMvc2VydmVyXCIpO1xuZnVuY3Rpb24gZ2V0RXJyb3JGcm9tVW5rbm93bihjYXVzZSkge1xuICAgIGlmIChjYXVzZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIGlmIChjYXVzZS5uYW1lID09PSAnVFJQQ0Vycm9yJykge1xuICAgICAgICAgICAgcmV0dXJuIGNhdXNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVycm9yID0gbmV3IHNlcnZlcl8xLlRSUENFcnJvcih7XG4gICAgICAgICAgICBtZXNzYWdlOiAnSW50ZXJuYWwgc2VydmVyIGVycm9yJyxcbiAgICAgICAgICAgIGNvZGU6ICdJTlRFUk5BTF9TRVJWRVJfRVJST1InLFxuICAgICAgICAgICAgY2F1c2U6IGNhdXNlLFxuICAgICAgICB9KTtcbiAgICAgICAgZXJyb3Iuc3RhY2sgPSBjYXVzZS5zdGFjaztcbiAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IHNlcnZlcl8xLlRSUENFcnJvcih7XG4gICAgICAgIG1lc3NhZ2U6ICdJbnRlcm5hbCBzZXJ2ZXIgZXJyb3InLFxuICAgICAgICBjb2RlOiAnSU5URVJOQUxfU0VSVkVSX0VSUk9SJyxcbiAgICB9KTtcbn1cbmV4cG9ydHMuZ2V0RXJyb3JGcm9tVW5rbm93biA9IGdldEVycm9yRnJvbVVua25vd247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lcnJvcnMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNyZWF0ZUNocm9tZUhhbmRsZXIgPSB2b2lkIDA7XG5jb25zdCBzZXJ2ZXJfMSA9IHJlcXVpcmUoXCJAdHJwYy9zZXJ2ZXJcIik7XG5jb25zdCBvYnNlcnZhYmxlXzEgPSByZXF1aXJlKFwiQHRycGMvc2VydmVyL29ic2VydmFibGVcIik7XG5jb25zdCBzaGFyZWRfMSA9IHJlcXVpcmUoXCJAdHJwYy9zZXJ2ZXIvc2hhcmVkXCIpO1xuY29uc3QgdHJwY01lc3NhZ2VfMSA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvdHJwY01lc3NhZ2VcIik7XG5jb25zdCBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuL2Vycm9yc1wiKTtcbmNvbnN0IGNyZWF0ZUNocm9tZUhhbmRsZXIgPSAob3B0cykgPT4ge1xuICAgIGNvbnN0IHsgcm91dGVyLCBjcmVhdGVDb250ZXh0LCBvbkVycm9yLCBjaHJvbWUgPSBnbG9iYWwuY2hyb21lIH0gPSBvcHRzO1xuICAgIGlmICghY2hyb21lKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIlNraXBwaW5nIGNocm9tZSBoYW5kbGVyIGNyZWF0aW9uOiAnb3B0cy5jaHJvbWUnIG5vdCBkZWZpbmVkXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNocm9tZS5ydW50aW1lLm9uQ29ubmVjdC5hZGRMaXN0ZW5lcigocG9ydCkgPT4ge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50XG4gICAgICAgIGNvbnN0IHsgdHJhbnNmb3JtZXIgfSA9IHJvdXRlci5fZGVmLl9jb25maWc7XG4gICAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IFtdO1xuICAgICAgICBjb25zdCBjbGVhbnVwID0gKCkgPT4gbGlzdGVuZXJzLmZvckVhY2goKHVuc3ViKSA9PiB1bnN1YigpKTtcbiAgICAgICAgcG9ydC5vbkRpc2Nvbm5lY3QuYWRkTGlzdGVuZXIoY2xlYW51cCk7XG4gICAgICAgIGxpc3RlbmVycy5wdXNoKCgpID0+IHBvcnQub25EaXNjb25uZWN0LnJlbW92ZUxpc3RlbmVyKGNsZWFudXApKTtcbiAgICAgICAgY29uc3Qgb25NZXNzYWdlID0gYXN5bmMgKG1lc3NhZ2UpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGlmICghcG9ydCB8fCAhKDAsIHRycGNNZXNzYWdlXzEuaXNUUlBDUmVxdWVzdFdpdGhJZCkobWVzc2FnZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY29uc3QgeyB0cnBjIH0gPSBtZXNzYWdlO1xuICAgICAgICAgICAgY29uc3Qgc2VuZFJlc3BvbnNlID0gKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcG9ydC5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgIHRycGM6IE9iamVjdC5hc3NpZ24oeyBpZDogdHJwYy5pZCwganNvbnJwYzogdHJwYy5qc29ucnBjIH0sIHJlc3BvbnNlKSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAodHJwYy5tZXRob2QgPT09ICdzdWJzY3JpcHRpb24uc3RvcCcpIHtcbiAgICAgICAgICAgICAgICAoX2EgPSBzdWJzY3JpcHRpb25zLmdldCh0cnBjLmlkKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9ucy5kZWxldGUodHJwYy5pZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbmRSZXNwb25zZSh7IHJlc3VsdDogeyB0eXBlOiAnc3RvcHBlZCcgfSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgbWV0aG9kLCBwYXJhbXMsIGlkIH0gPSB0cnBjO1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gYXdhaXQgKGNyZWF0ZUNvbnRleHQgPT09IG51bGwgfHwgY3JlYXRlQ29udGV4dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3JlYXRlQ29udGV4dCh7IHJlcTogcG9ydCwgcmVzOiB1bmRlZmluZWQgfSkpO1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlRXJyb3IgPSAoY2F1c2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9ICgwLCBlcnJvcnNfMS5nZXRFcnJvckZyb21Vbmtub3duKShjYXVzZSk7XG4gICAgICAgICAgICAgICAgb25FcnJvciA9PT0gbnVsbCB8fCBvbkVycm9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbkVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IG1ldGhvZCxcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogcGFyYW1zLnBhdGgsXG4gICAgICAgICAgICAgICAgICAgIGlucHV0OiBwYXJhbXMuaW5wdXQsXG4gICAgICAgICAgICAgICAgICAgIGN0eCxcbiAgICAgICAgICAgICAgICAgICAgcmVxOiBwb3J0LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHNlbmRSZXNwb25zZSh7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnRcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6ICgwLCBzaGFyZWRfMS5nZXRFcnJvclNoYXBlKSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWc6IHJvdXRlci5fZGVmLl9jb25maWcsXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IG1ldGhvZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6IHBhcmFtcy5wYXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQ6IHBhcmFtcy5pbnB1dCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eCxcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50LCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3MsIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtY2FsbFxuICAgICAgICAgICAgICAgIGNvbnN0IGlucHV0ID0gdHJhbnNmb3JtZXIuaW5wdXQuZGVzZXJpYWxpemUodHJwYy5wYXJhbXMuaW5wdXQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhbGxlciA9IHJvdXRlci5jcmVhdGVDYWxsZXIoY3R4KTtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9jZWR1cmVGbiA9IHRycGMucGFyYW1zLnBhdGhcbiAgICAgICAgICAgICAgICAgICAgLnNwbGl0KCcuJylcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2VzcywgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1yZXR1cm4sIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgICAgICAgLnJlZHVjZSgoYWNjLCBzZWdtZW50KSA9PiBhY2Nbc2VnbWVudF0sIGNhbGxlcik7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXJndW1lbnRcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBwcm9jZWR1cmVGbihpbnB1dCk7XG4gICAgICAgICAgICAgICAgaWYgKHRycGMubWV0aG9kICE9PSAnc3Vic2NyaXB0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VuZFJlc3BvbnNlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnQsIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2VzcywgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1jYWxsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IHsgdHlwZTogJ2RhdGEnLCBkYXRhOiB0cmFuc2Zvcm1lci5vdXRwdXQuc2VyaWFsaXplKHJlc3VsdCkgfSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghKDAsIG9ic2VydmFibGVfMS5pc09ic2VydmFibGUpKHJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IHNlcnZlcl8xLlRSUENFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBgU3Vic2NyaXB0aW9uICR7cGFyYW1zLnBhdGh9IGRpZCBub3QgcmV0dXJuIGFuIG9ic2VydmFibGVgLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogJ0lOVEVSTkFMX1NFUlZFUl9FUlJPUicsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBzdWJzY3JpcHRpb24gPSByZXN1bHQuc3Vic2NyaWJlKHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dDogKGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlcmlhbGl6ZWREYXRhID0gdHJhbnNmb3JtZXIub3V0cHV0LnNlcmlhbGl6ZShkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbmRSZXNwb25zZSh7IHJlc3VsdDogeyB0eXBlOiAnZGF0YScsIGRhdGE6IHNlcmlhbGl6ZWREYXRhIH0gfSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBoYW5kbGVFcnJvcixcbiAgICAgICAgICAgICAgICAgICAgY29tcGxldGU6ICgpID0+IHNlbmRSZXNwb25zZSh7IHJlc3VsdDogeyB0eXBlOiAnc3RvcHBlZCcgfSB9KSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoc3Vic2NyaXB0aW9ucy5oYXMoaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgICAgICBzZW5kUmVzcG9uc2UoeyByZXN1bHQ6IHsgdHlwZTogJ3N0b3BwZWQnIH0gfSk7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBzZXJ2ZXJfMS5UUlBDRXJyb3IoeyBtZXNzYWdlOiBgRHVwbGljYXRlIGlkICR7aWR9YCwgY29kZTogJ0JBRF9SRVFVRVNUJyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzLnB1c2goKCkgPT4gc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCkpO1xuICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbnMuc2V0KGlkLCBzdWJzY3JpcHRpb24pO1xuICAgICAgICAgICAgICAgIHNlbmRSZXNwb25zZSh7IHJlc3VsdDogeyB0eXBlOiAnc3RhcnRlZCcgfSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChjYXVzZSkge1xuICAgICAgICAgICAgICAgIGhhbmRsZUVycm9yKGNhdXNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcG9ydC5vbk1lc3NhZ2UuYWRkTGlzdGVuZXIob25NZXNzYWdlKTtcbiAgICAgICAgbGlzdGVuZXJzLnB1c2goKCkgPT4gcG9ydC5vbk1lc3NhZ2UucmVtb3ZlTGlzdGVuZXIob25NZXNzYWdlKSk7XG4gICAgfSk7XG59O1xuZXhwb3J0cy5jcmVhdGVDaHJvbWVIYW5kbGVyID0gY3JlYXRlQ2hyb21lSGFuZGxlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNocm9tZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVFJQQ19CUk9XU0VSX0xPQURFRF9FVkVOVCA9IHZvaWQgMDtcbmV4cG9ydHMuVFJQQ19CUk9XU0VSX0xPQURFRF9FVkVOVCA9ICdUUlBDX0JST1dTRVI6OlBPUFVQX0xPQURFRCc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25zdGFudHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNyZWF0ZVdpbmRvd0hhbmRsZXIgPSB2b2lkIDA7XG5jb25zdCBzZXJ2ZXJfMSA9IHJlcXVpcmUoXCJAdHJwYy9zZXJ2ZXJcIik7XG5jb25zdCBvYnNlcnZhYmxlXzEgPSByZXF1aXJlKFwiQHRycGMvc2VydmVyL29ic2VydmFibGVcIik7XG5jb25zdCBzaGFyZWRfMSA9IHJlcXVpcmUoXCJAdHJwYy9zZXJ2ZXIvc2hhcmVkXCIpO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2NvbnN0YW50c1wiKTtcbmNvbnN0IHRycGNNZXNzYWdlXzEgPSByZXF1aXJlKFwiLi4vc2hhcmVkL3RycGNNZXNzYWdlXCIpO1xuY29uc3QgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi9lcnJvcnNcIik7XG5jb25zdCBjcmVhdGVXaW5kb3dIYW5kbGVyID0gKG9wdHMpID0+IHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGNvbnN0IHsgcm91dGVyLCBjcmVhdGVDb250ZXh0LCBvbkVycm9yLCB3aW5kb3csIHBvc3RPcmlnaW4gfSA9IG9wdHM7XG4gICAgaWYgKCF3aW5kb3cpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiU2tpcHBpbmcgd2luZG93IGhhbmRsZXIgY3JlYXRpb246ICdvcHRzLndpbmRvdycgbm90IGRlZmluZWRcIik7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbG9hZExpc3RlbmVyID0gKF9iID0gKF9hID0gb3B0cy5wb3N0V2luZG93KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB3aW5kb3cub3BlbmVyKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB3aW5kb3c7XG4gICAgbG9hZExpc3RlbmVyLnBvc3RNZXNzYWdlKGNvbnN0YW50c18xLlRSUENfQlJPV1NFUl9MT0FERURfRVZFTlQsIHsgdGFyZ2V0T3JpZ2luOiBwb3N0T3JpZ2luIH0pO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnRcbiAgICBjb25zdCB7IHRyYW5zZm9ybWVyIH0gPSByb3V0ZXIuX2RlZi5fY29uZmlnO1xuICAgIGNvbnN0IHN1YnNjcmlwdGlvbnMgPSBuZXcgTWFwKCk7XG4gICAgY29uc3QgbGlzdGVuZXJzID0gW107XG4gICAgY29uc3QgY2xlYW51cCA9ICgpID0+IGxpc3RlbmVycy5mb3JFYWNoKCh1bnN1YikgPT4gdW5zdWIoKSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2JlZm9yZXVubG9hZCcsIGNsZWFudXApO1xuICAgIGxpc3RlbmVycy5wdXNoKCgpID0+IHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdiZWZvcmV1bmxvYWQnLCBjbGVhbnVwKSk7XG4gICAgY29uc3Qgb25NZXNzYWdlID0gYXN5bmMgKGV2ZW50KSA9PiB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICBjb25zdCB7IGRhdGE6IG1lc3NhZ2UsIHNvdXJjZSB9ID0gZXZlbnQ7XG4gICAgICAgIGNvbnN0IHBvc3RXaW5kb3cgPSAoX2IgPSAoX2EgPSBvcHRzLnBvc3RXaW5kb3cpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHNvdXJjZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogd2luZG93O1xuICAgICAgICBpZiAoIXBvc3RXaW5kb3cgfHwgISgwLCB0cnBjTWVzc2FnZV8xLmlzVFJQQ1JlcXVlc3RXaXRoSWQpKG1lc3NhZ2UpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCB7IHRycGMgfSA9IG1lc3NhZ2U7XG4gICAgICAgIGNvbnN0IHNlbmRSZXNwb25zZSA9IChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgcG9zdFdpbmRvdy5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgdHJwYzogT2JqZWN0LmFzc2lnbih7IGlkOiB0cnBjLmlkLCBqc29ucnBjOiB0cnBjLmpzb25ycGMgfSwgcmVzcG9uc2UpLFxuICAgICAgICAgICAgfSwgeyB0YXJnZXRPcmlnaW46IHBvc3RPcmlnaW4gfSk7XG4gICAgICAgIH07XG4gICAgICAgIGlmICh0cnBjLm1ldGhvZCA9PT0gJ3N1YnNjcmlwdGlvbi5zdG9wJykge1xuICAgICAgICAgICAgKF9jID0gc3Vic2NyaXB0aW9ucy5nZXQodHJwYy5pZCkpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgc3Vic2NyaXB0aW9ucy5kZWxldGUodHJwYy5pZCk7XG4gICAgICAgICAgICByZXR1cm4gc2VuZFJlc3BvbnNlKHsgcmVzdWx0OiB7IHR5cGU6ICdzdG9wcGVkJyB9IH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgbWV0aG9kLCBwYXJhbXMsIGlkIH0gPSB0cnBjO1xuICAgICAgICBjb25zdCBjdHggPSBhd2FpdCAoY3JlYXRlQ29udGV4dCA9PT0gbnVsbCB8fCBjcmVhdGVDb250ZXh0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjcmVhdGVDb250ZXh0KHsgcmVxOiB7IG9yaWdpbjogZXZlbnQub3JpZ2luIH0sIHJlczogdW5kZWZpbmVkIH0pKTtcbiAgICAgICAgY29uc3QgaGFuZGxlRXJyb3IgPSAoY2F1c2UpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gKDAsIGVycm9yc18xLmdldEVycm9yRnJvbVVua25vd24pKGNhdXNlKTtcbiAgICAgICAgICAgIG9uRXJyb3IgPT09IG51bGwgfHwgb25FcnJvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogb25FcnJvcih7XG4gICAgICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICAgICAgdHlwZTogbWV0aG9kLFxuICAgICAgICAgICAgICAgIHBhdGg6IHBhcmFtcy5wYXRoLFxuICAgICAgICAgICAgICAgIGlucHV0OiBwYXJhbXMuaW5wdXQsXG4gICAgICAgICAgICAgICAgY3R4LFxuICAgICAgICAgICAgICAgIHJlcTogeyBvcmlnaW46IGV2ZW50Lm9yaWdpbiB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZW5kUmVzcG9uc2Uoe1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnRcbiAgICAgICAgICAgICAgICBlcnJvcjogKDAsIHNoYXJlZF8xLmdldEVycm9yU2hhcGUpKHtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnOiByb3V0ZXIuX2RlZi5fY29uZmlnLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogbWV0aG9kLFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBwYXJhbXMucGF0aCxcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQ6IHBhcmFtcy5pbnB1dCxcbiAgICAgICAgICAgICAgICAgICAgY3R4LFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50LCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3MsIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtY2FsbFxuICAgICAgICAgICAgY29uc3QgaW5wdXQgPSB0cmFuc2Zvcm1lci5pbnB1dC5kZXNlcmlhbGl6ZSh0cnBjLnBhcmFtcy5pbnB1dCk7XG4gICAgICAgICAgICBjb25zdCBjYWxsZXIgPSByb3V0ZXIuY3JlYXRlQ2FsbGVyKGN0eCk7XG4gICAgICAgICAgICBjb25zdCBwcm9jZWR1cmVGbiA9IHRycGMucGFyYW1zLnBhdGhcbiAgICAgICAgICAgICAgICAuc3BsaXQoJy4nKVxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3MsIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtcmV0dXJuLCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgLnJlZHVjZSgoYWNjLCBzZWdtZW50KSA9PiBhY2Nbc2VnbWVudF0sIGNhbGxlcik7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hcmd1bWVudFxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcHJvY2VkdXJlRm4oaW5wdXQpO1xuICAgICAgICAgICAgaWYgKHRycGMubWV0aG9kICE9PSAnc3Vic2NyaXB0aW9uJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZW5kUmVzcG9uc2Uoe1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50LCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3MsIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtY2FsbFxuICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IHsgdHlwZTogJ2RhdGEnLCBkYXRhOiB0cmFuc2Zvcm1lci5vdXRwdXQuc2VyaWFsaXplKHJlc3VsdCkgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghKDAsIG9ic2VydmFibGVfMS5pc09ic2VydmFibGUpKHJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgc2VydmVyXzEuVFJQQ0Vycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogYFN1YnNjcmlwdGlvbiAke3BhcmFtcy5wYXRofSBkaWQgbm90IHJldHVybiBhbiBvYnNlcnZhYmxlYCxcbiAgICAgICAgICAgICAgICAgICAgY29kZTogJ0lOVEVSTkFMX1NFUlZFUl9FUlJPUicsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzdWJzY3JpcHRpb24gPSByZXN1bHQuc3Vic2NyaWJlKHtcbiAgICAgICAgICAgICAgICBuZXh0OiAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzZXJpYWxpemVkRGF0YSA9IHRyYW5zZm9ybWVyLm91dHB1dC5zZXJpYWxpemUoZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIHNlbmRSZXNwb25zZSh7IHJlc3VsdDogeyB0eXBlOiAnZGF0YScsIGRhdGE6IHNlcmlhbGl6ZWREYXRhIH0gfSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBlcnJvcjogaGFuZGxlRXJyb3IsXG4gICAgICAgICAgICAgICAgY29tcGxldGU6ICgpID0+IHNlbmRSZXNwb25zZSh7IHJlc3VsdDogeyB0eXBlOiAnc3RvcHBlZCcgfSB9KSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHN1YnNjcmlwdGlvbnMuaGFzKGlkKSkge1xuICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgIHNlbmRSZXNwb25zZSh7IHJlc3VsdDogeyB0eXBlOiAnc3RvcHBlZCcgfSB9KTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgc2VydmVyXzEuVFJQQ0Vycm9yKHsgbWVzc2FnZTogYER1cGxpY2F0ZSBpZCAke2lkfWAsIGNvZGU6ICdCQURfUkVRVUVTVCcgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsaXN0ZW5lcnMucHVzaCgoKSA9PiBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKSk7XG4gICAgICAgICAgICBzdWJzY3JpcHRpb25zLnNldChpZCwgc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgICAgIHNlbmRSZXNwb25zZSh7IHJlc3VsdDogeyB0eXBlOiAnc3RhcnRlZCcgfSB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoY2F1c2UpIHtcbiAgICAgICAgICAgIGhhbmRsZUVycm9yKGNhdXNlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBvbk1lc3NhZ2UpO1xuICAgIGxpc3RlbmVycy5wdXNoKCgpID0+IHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgb25NZXNzYWdlKSk7XG59O1xuZXhwb3J0cy5jcmVhdGVXaW5kb3dIYW5kbGVyID0gY3JlYXRlV2luZG93SGFuZGxlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdpbmRvdy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2Nocm9tZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vd2luZG93XCIpLCBleHBvcnRzKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxudmFyIG9ic2VydmFibGUgPSByZXF1aXJlKCdAdHJwYy9zZXJ2ZXIvb2JzZXJ2YWJsZScpO1xuXG4vKiogQGludGVybmFsICovIGZ1bmN0aW9uIGNyZWF0ZUNoYWluKG9wdHMpIHtcbiAgICByZXR1cm4gb2JzZXJ2YWJsZS5vYnNlcnZhYmxlKChvYnNlcnZlcik9PntcbiAgICAgICAgZnVuY3Rpb24gZXhlY3V0ZShpbmRleCA9IDAsIG9wID0gb3B0cy5vcCkge1xuICAgICAgICAgICAgY29uc3QgbmV4dCA9IG9wdHMubGlua3NbaW5kZXhdO1xuICAgICAgICAgICAgaWYgKCFuZXh0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBtb3JlIGxpbmtzIHRvIGV4ZWN1dGUgLSBkaWQgeW91IGZvcmdldCB0byBhZGQgYW4gZW5kaW5nIGxpbms/Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBuZXh0KHtcbiAgICAgICAgICAgICAgICBvcCxcbiAgICAgICAgICAgICAgICBuZXh0IChuZXh0T3ApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV4dE9ic2VydmVyID0gZXhlY3V0ZShpbmRleCArIDEsIG5leHRPcCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXh0T2JzZXJ2ZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gc3Vic2NyaXB0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9icyQgPSBleGVjdXRlKCk7XG4gICAgICAgIHJldHVybiBvYnMkLnN1YnNjcmliZShvYnNlcnZlcik7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGFzQXJyYXkodmFsdWUpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFtcbiAgICAgICAgdmFsdWVcbiAgICBdO1xufVxuZnVuY3Rpb24gc3BsaXRMaW5rKG9wdHMpIHtcbiAgICByZXR1cm4gKHJ1bnRpbWUpPT57XG4gICAgICAgIGNvbnN0IHllcyA9IGFzQXJyYXkob3B0cy50cnVlKS5tYXAoKGxpbmspPT5saW5rKHJ1bnRpbWUpKTtcbiAgICAgICAgY29uc3Qgbm8gPSBhc0FycmF5KG9wdHMuZmFsc2UpLm1hcCgobGluayk9PmxpbmsocnVudGltZSkpO1xuICAgICAgICByZXR1cm4gKHByb3BzKT0+e1xuICAgICAgICAgICAgcmV0dXJuIG9ic2VydmFibGUub2JzZXJ2YWJsZSgob2JzZXJ2ZXIpPT57XG4gICAgICAgICAgICAgICAgY29uc3QgbGlua3MgPSBvcHRzLmNvbmRpdGlvbihwcm9wcy5vcCkgPyB5ZXMgOiBubztcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ2hhaW4oe1xuICAgICAgICAgICAgICAgICAgICBvcDogcHJvcHMub3AsXG4gICAgICAgICAgICAgICAgICAgIGxpbmtzXG4gICAgICAgICAgICAgICAgfSkuc3Vic2NyaWJlKG9ic2VydmVyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH07XG59XG5cbmV4cG9ydHMuY3JlYXRlQ2hhaW4gPSBjcmVhdGVDaGFpbjtcbmV4cG9ydHMuc3BsaXRMaW5rID0gc3BsaXRMaW5rO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICAgIC8vIGNoZWNrIHRoYXQgdmFsdWUgaXMgb2JqZWN0XG4gICAgcmV0dXJuICEhdmFsdWUgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCc7XG59XG5cbi8vIEZJWE1FOlxuLy8gLSB0aGUgZ2VuZXJpY3MgaGVyZSBhcmUgcHJvYmFibHkgdW5uZWNlc3Nhcnlcbi8vIC0gdGhlIFJQQy1zcGVjIGNvdWxkIHByb2JhYmx5IGJlIHNpbXBsaWZpZWQgdG8gY29tYmluZSBIVFRQICsgV1Ncbi8qKiBAaW50ZXJuYWwgKi8gZnVuY3Rpb24gdHJhbnNmb3JtUmVzdWx0SW5uZXIocmVzcG9uc2UsIHJ1bnRpbWUpIHtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXNwb25zZSkge1xuICAgICAgICBjb25zdCBlcnJvciA9IHJ1bnRpbWUudHJhbnNmb3JtZXIuZGVzZXJpYWxpemUocmVzcG9uc2UuZXJyb3IpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgb2s6IGZhbHNlLFxuICAgICAgICAgICAgZXJyb3I6IHtcbiAgICAgICAgICAgICAgICAuLi5yZXNwb25zZSxcbiAgICAgICAgICAgICAgICBlcnJvclxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgIC4uLnJlc3BvbnNlLnJlc3VsdCxcbiAgICAgICAgLi4uKCFyZXNwb25zZS5yZXN1bHQudHlwZSB8fCByZXNwb25zZS5yZXN1bHQudHlwZSA9PT0gJ2RhdGEnKSAmJiB7XG4gICAgICAgICAgICB0eXBlOiAnZGF0YScsXG4gICAgICAgICAgICBkYXRhOiBydW50aW1lLnRyYW5zZm9ybWVyLmRlc2VyaWFsaXplKHJlc3BvbnNlLnJlc3VsdC5kYXRhKVxuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgICBvazogdHJ1ZSxcbiAgICAgICAgcmVzdWx0XG4gICAgfTtcbn1cbmNsYXNzIFRyYW5zZm9ybVJlc3VsdEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHN1cGVyKCdVbmFibGUgdG8gdHJhbnNmb3JtIHJlc3BvbnNlIGZyb20gc2VydmVyJyk7XG4gICAgfVxufVxuLyoqXG4gKiBUcmFuc2Zvcm1zIGFuZCB2YWxpZGF0ZXMgdGhhdCB0aGUgcmVzdWx0IGlzIGEgdmFsaWQgVFJQQ1Jlc3BvbnNlXG4gKiBAaW50ZXJuYWxcbiAqLyBmdW5jdGlvbiB0cmFuc2Zvcm1SZXN1bHQocmVzcG9uc2UsIHJ1bnRpbWUpIHtcbiAgICBsZXQgcmVzdWx0O1xuICAgIHRyeSB7XG4gICAgICAgIC8vIFVzZSB0aGUgZGF0YSB0cmFuc2Zvcm1lcnMgb24gdGhlIEpTT04tcmVzcG9uc2VcbiAgICAgICAgcmVzdWx0ID0gdHJhbnNmb3JtUmVzdWx0SW5uZXIocmVzcG9uc2UsIHJ1bnRpbWUpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICB0aHJvdyBuZXcgVHJhbnNmb3JtUmVzdWx0RXJyb3IoKTtcbiAgICB9XG4gICAgLy8gY2hlY2sgdGhhdCBvdXRwdXQgb2YgdGhlIHRyYW5zZm9ybWVycyBpcyBhIHZhbGlkIFRSUENSZXNwb25zZVxuICAgIGlmICghcmVzdWx0Lm9rICYmICghaXNPYmplY3QocmVzdWx0LmVycm9yLmVycm9yKSB8fCB0eXBlb2YgcmVzdWx0LmVycm9yLmVycm9yLmNvZGUgIT09ICdudW1iZXInKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHJhbnNmb3JtUmVzdWx0RXJyb3IoKTtcbiAgICB9XG4gICAgaWYgKHJlc3VsdC5vayAmJiAhaXNPYmplY3QocmVzdWx0LnJlc3VsdCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFRyYW5zZm9ybVJlc3VsdEVycm9yKCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcbmV4cG9ydHMudHJhbnNmb3JtUmVzdWx0ID0gdHJhbnNmb3JtUmVzdWx0O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgc2hhcmVkID0gcmVxdWlyZSgnQHRycGMvc2VydmVyL3NoYXJlZCcpO1xudmFyIHRyYW5zZm9ybVJlc3VsdCA9IHJlcXVpcmUoJy4vdHJhbnNmb3JtUmVzdWx0LWRmY2U4ZjE1LmpzJyk7XG5cbmZ1bmN0aW9uIGlzVFJQQ0NsaWVudEVycm9yKGNhdXNlKSB7XG4gICAgcmV0dXJuIGNhdXNlIGluc3RhbmNlb2YgVFJQQ0NsaWVudEVycm9yIHx8IC8qKlxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICogRGVsZXRlIGluIG5leHQgbWFqb3JcbiAgICAgKi8gY2F1c2UgaW5zdGFuY2VvZiBFcnJvciAmJiBjYXVzZS5uYW1lID09PSAnVFJQQ0NsaWVudEVycm9yJztcbn1cbmZ1bmN0aW9uIGlzVFJQQ0Vycm9yUmVzcG9uc2Uob2JqKSB7XG4gICAgcmV0dXJuIHRyYW5zZm9ybVJlc3VsdC5pc09iamVjdChvYmopICYmIHRyYW5zZm9ybVJlc3VsdC5pc09iamVjdChvYmouZXJyb3IpICYmIHR5cGVvZiBvYmouZXJyb3IuY29kZSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIG9iai5lcnJvci5tZXNzYWdlID09PSAnc3RyaW5nJztcbn1cbmNsYXNzIFRSUENDbGllbnRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBzdGF0aWMgZnJvbShfY2F1c2UsIG9wdHMgPSB7fSkge1xuICAgICAgICBjb25zdCBjYXVzZSA9IF9jYXVzZTtcbiAgICAgICAgaWYgKGlzVFJQQ0NsaWVudEVycm9yKGNhdXNlKSkge1xuICAgICAgICAgICAgaWYgKG9wdHMubWV0YSkge1xuICAgICAgICAgICAgICAgIC8vIERlY29yYXRlIHdpdGggbWV0YSBlcnJvciBkYXRhXG4gICAgICAgICAgICAgICAgY2F1c2UubWV0YSA9IHtcbiAgICAgICAgICAgICAgICAgICAgLi4uY2F1c2UubWV0YSxcbiAgICAgICAgICAgICAgICAgICAgLi4ub3B0cy5tZXRhXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjYXVzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNUUlBDRXJyb3JSZXNwb25zZShjYXVzZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVFJQQ0NsaWVudEVycm9yKGNhdXNlLmVycm9yLm1lc3NhZ2UsIHtcbiAgICAgICAgICAgICAgICAuLi5vcHRzLFxuICAgICAgICAgICAgICAgIHJlc3VsdDogY2F1c2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKGNhdXNlIGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFRSUENDbGllbnRFcnJvcignVW5rbm93biBlcnJvcicsIHtcbiAgICAgICAgICAgICAgICAuLi5vcHRzLFxuICAgICAgICAgICAgICAgIGNhdXNlOiBjYXVzZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBUUlBDQ2xpZW50RXJyb3IoY2F1c2UubWVzc2FnZSwge1xuICAgICAgICAgICAgLi4ub3B0cyxcbiAgICAgICAgICAgIGNhdXNlOiBzaGFyZWQuZ2V0Q2F1c2VGcm9tVW5rbm93bihjYXVzZSlcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIG9wdHMpe1xuICAgICAgICBjb25zdCBjYXVzZSA9IG9wdHM/LmNhdXNlO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG4gICAgICAgIC8vIEB0cy1pZ25vcmUgaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtZXJyb3ItY2F1c2VcbiAgICAgICAgc3VwZXIobWVzc2FnZSwge1xuICAgICAgICAgICAgY2F1c2VcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubWV0YSA9IG9wdHM/Lm1ldGE7XG4gICAgICAgIHRoaXMuY2F1c2UgPSBjYXVzZTtcbiAgICAgICAgdGhpcy5zaGFwZSA9IG9wdHM/LnJlc3VsdD8uZXJyb3I7XG4gICAgICAgIHRoaXMuZGF0YSA9IG9wdHM/LnJlc3VsdD8uZXJyb3IuZGF0YTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ1RSUENDbGllbnRFcnJvcic7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBUUlBDQ2xpZW50RXJyb3IucHJvdG90eXBlKTtcbiAgICB9XG59XG5cbmV4cG9ydHMuVFJQQ0NsaWVudEVycm9yID0gVFJQQ0NsaWVudEVycm9yO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVFJQQ0NsaWVudEVycm9yID0gcmVxdWlyZSgnLi9UUlBDQ2xpZW50RXJyb3ItN2UwYzMxZTcuanMnKTtcblxuY29uc3QgaXNGdW5jdGlvbiA9IChmbik9PnR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJztcbmZ1bmN0aW9uIGdldEZldGNoKGN1c3RvbUZldGNoSW1wbCkge1xuICAgIGlmIChjdXN0b21GZXRjaEltcGwpIHtcbiAgICAgICAgcmV0dXJuIGN1c3RvbUZldGNoSW1wbDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIGlzRnVuY3Rpb24od2luZG93LmZldGNoKSkge1xuICAgICAgICByZXR1cm4gd2luZG93LmZldGNoO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnICYmIGlzRnVuY3Rpb24oZ2xvYmFsVGhpcy5mZXRjaCkpIHtcbiAgICAgICAgcmV0dXJuIGdsb2JhbFRoaXMuZmV0Y2g7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignTm8gZmV0Y2ggaW1wbGVtZW50YXRpb24gZm91bmQnKTtcbn1cblxuZnVuY3Rpb24gZ2V0QWJvcnRDb250cm9sbGVyKGN1c3RvbUFib3J0Q29udHJvbGxlckltcGwpIHtcbiAgICBpZiAoY3VzdG9tQWJvcnRDb250cm9sbGVySW1wbCkge1xuICAgICAgICByZXR1cm4gY3VzdG9tQWJvcnRDb250cm9sbGVySW1wbDtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9wcmVmZXItb3B0aW9uYWwtY2hhaW5cbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LkFib3J0Q29udHJvbGxlcikge1xuICAgICAgICByZXR1cm4gd2luZG93LkFib3J0Q29udHJvbGxlcjtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9wcmVmZXItb3B0aW9uYWwtY2hhaW5cbiAgICBpZiAodHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnICYmIGdsb2JhbFRoaXMuQWJvcnRDb250cm9sbGVyKSB7XG4gICAgICAgIHJldHVybiBnbG9iYWxUaGlzLkFib3J0Q29udHJvbGxlcjtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVIVFRQTGlua09wdGlvbnMob3B0cykge1xuICAgIHJldHVybiB7XG4gICAgICAgIHVybDogb3B0cy51cmwudG9TdHJpbmcoKS5yZXBsYWNlKC9cXC8kLywgJycpLFxuICAgICAgICBmZXRjaDogb3B0cy5mZXRjaCxcbiAgICAgICAgQWJvcnRDb250cm9sbGVyOiBnZXRBYm9ydENvbnRyb2xsZXIob3B0cy5BYm9ydENvbnRyb2xsZXIpXG4gICAgfTtcbn1cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90cnBjL3RycGMvcHVsbC82NjlcbmZ1bmN0aW9uIGFycmF5VG9EaWN0KGFycmF5KSB7XG4gICAgY29uc3QgZGljdCA9IHt9O1xuICAgIGZvcihsZXQgaW5kZXggPSAwOyBpbmRleCA8IGFycmF5Lmxlbmd0aDsgaW5kZXgrKyl7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSBhcnJheVtpbmRleF07XG4gICAgICAgIGRpY3RbaW5kZXhdID0gZWxlbWVudDtcbiAgICB9XG4gICAgcmV0dXJuIGRpY3Q7XG59XG5jb25zdCBNRVRIT0QgPSB7XG4gICAgcXVlcnk6ICdHRVQnLFxuICAgIG11dGF0aW9uOiAnUE9TVCdcbn07XG5mdW5jdGlvbiBnZXRJbnB1dChvcHRzKSB7XG4gICAgcmV0dXJuICdpbnB1dCcgaW4gb3B0cyA/IG9wdHMucnVudGltZS50cmFuc2Zvcm1lci5zZXJpYWxpemUob3B0cy5pbnB1dCkgOiBhcnJheVRvRGljdChvcHRzLmlucHV0cy5tYXAoKF9pbnB1dCk9Pm9wdHMucnVudGltZS50cmFuc2Zvcm1lci5zZXJpYWxpemUoX2lucHV0KSkpO1xufVxuY29uc3QgZ2V0VXJsID0gKG9wdHMpPT57XG4gICAgbGV0IHVybCA9IG9wdHMudXJsICsgJy8nICsgb3B0cy5wYXRoO1xuICAgIGNvbnN0IHF1ZXJ5UGFydHMgPSBbXTtcbiAgICBpZiAoJ2lucHV0cycgaW4gb3B0cykge1xuICAgICAgICBxdWVyeVBhcnRzLnB1c2goJ2JhdGNoPTEnKTtcbiAgICB9XG4gICAgaWYgKG9wdHMudHlwZSA9PT0gJ3F1ZXJ5Jykge1xuICAgICAgICBjb25zdCBpbnB1dCA9IGdldElucHV0KG9wdHMpO1xuICAgICAgICBpZiAoaW5wdXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcXVlcnlQYXJ0cy5wdXNoKGBpbnB1dD0ke2VuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShpbnB1dCkpfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChxdWVyeVBhcnRzLmxlbmd0aCkge1xuICAgICAgICB1cmwgKz0gJz8nICsgcXVlcnlQYXJ0cy5qb2luKCcmJyk7XG4gICAgfVxuICAgIHJldHVybiB1cmw7XG59O1xuY29uc3QgZ2V0Qm9keSA9IChvcHRzKT0+e1xuICAgIGlmIChvcHRzLnR5cGUgPT09ICdxdWVyeScpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3QgaW5wdXQgPSBnZXRJbnB1dChvcHRzKTtcbiAgICByZXR1cm4gaW5wdXQgIT09IHVuZGVmaW5lZCA/IEpTT04uc3RyaW5naWZ5KGlucHV0KSA6IHVuZGVmaW5lZDtcbn07XG5jb25zdCBqc29uSHR0cFJlcXVlc3RlciA9IChvcHRzKT0+e1xuICAgIHJldHVybiBodHRwUmVxdWVzdCh7XG4gICAgICAgIC4uLm9wdHMsXG4gICAgICAgIGNvbnRlbnRUeXBlSGVhZGVyOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIGdldFVybCxcbiAgICAgICAgZ2V0Qm9keVxuICAgIH0pO1xufTtcbmFzeW5jIGZ1bmN0aW9uIGZldGNoSFRUUFJlc3BvbnNlKG9wdHMsIGFjKSB7XG4gICAgY29uc3QgdXJsID0gb3B0cy5nZXRVcmwob3B0cyk7XG4gICAgY29uc3QgYm9keSA9IG9wdHMuZ2V0Qm9keShvcHRzKTtcbiAgICBjb25zdCB7IHR5cGUgIH0gPSBvcHRzO1xuICAgIGNvbnN0IHJlc29sdmVkSGVhZGVycyA9IGF3YWl0IG9wdHMuaGVhZGVycygpO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAtLSBAcHJlc2VydmUgKi8gaWYgKHR5cGUgPT09ICdzdWJzY3JpcHRpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignU3Vic2NyaXB0aW9ucyBzaG91bGQgdXNlIHdzTGluaycpO1xuICAgIH1cbiAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgICAuLi5vcHRzLmNvbnRlbnRUeXBlSGVhZGVyID8ge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6IG9wdHMuY29udGVudFR5cGVIZWFkZXJcbiAgICAgICAgfSA6IHt9LFxuICAgICAgICAuLi5vcHRzLmJhdGNoTW9kZUhlYWRlciA/IHtcbiAgICAgICAgICAgICd0cnBjLWJhdGNoLW1vZGUnOiBvcHRzLmJhdGNoTW9kZUhlYWRlclxuICAgICAgICB9IDoge30sXG4gICAgICAgIC4uLnJlc29sdmVkSGVhZGVyc1xuICAgIH07XG4gICAgcmV0dXJuIGdldEZldGNoKG9wdHMuZmV0Y2gpKHVybCwge1xuICAgICAgICBtZXRob2Q6IE1FVEhPRFt0eXBlXSxcbiAgICAgICAgc2lnbmFsOiBhYz8uc2lnbmFsLFxuICAgICAgICBib2R5OiBib2R5LFxuICAgICAgICBoZWFkZXJzXG4gICAgfSk7XG59XG5mdW5jdGlvbiBodHRwUmVxdWVzdChvcHRzKSB7XG4gICAgY29uc3QgYWMgPSBvcHRzLkFib3J0Q29udHJvbGxlciA/IG5ldyBvcHRzLkFib3J0Q29udHJvbGxlcigpIDogbnVsbDtcbiAgICBjb25zdCBtZXRhID0ge307XG4gICAgbGV0IGRvbmUgPSBmYWxzZTtcbiAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCk9PntcbiAgICAgICAgZmV0Y2hIVFRQUmVzcG9uc2Uob3B0cywgYWMpLnRoZW4oKF9yZXMpPT57XG4gICAgICAgICAgICBtZXRhLnJlc3BvbnNlID0gX3JlcztcbiAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIF9yZXMuanNvbigpO1xuICAgICAgICB9KS50aGVuKChqc29uKT0+e1xuICAgICAgICAgICAgbWV0YS5yZXNwb25zZUpTT04gPSBqc29uO1xuICAgICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAganNvbjoganNvbixcbiAgICAgICAgICAgICAgICBtZXRhXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSkuY2F0Y2goKGVycik9PntcbiAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgcmVqZWN0KFRSUENDbGllbnRFcnJvci5UUlBDQ2xpZW50RXJyb3IuZnJvbShlcnIsIHtcbiAgICAgICAgICAgICAgICBtZXRhXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIGNvbnN0IGNhbmNlbCA9ICgpPT57XG4gICAgICAgIGlmICghZG9uZSkge1xuICAgICAgICAgICAgYWM/LmFib3J0KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIHByb21pc2UsXG4gICAgICAgIGNhbmNlbFxuICAgIH07XG59XG5cbmV4cG9ydHMuZmV0Y2hIVFRQUmVzcG9uc2UgPSBmZXRjaEhUVFBSZXNwb25zZTtcbmV4cG9ydHMuZ2V0Qm9keSA9IGdldEJvZHk7XG5leHBvcnRzLmdldEZldGNoID0gZ2V0RmV0Y2g7XG5leHBvcnRzLmdldFVybCA9IGdldFVybDtcbmV4cG9ydHMuaHR0cFJlcXVlc3QgPSBodHRwUmVxdWVzdDtcbmV4cG9ydHMuanNvbkh0dHBSZXF1ZXN0ZXIgPSBqc29uSHR0cFJlcXVlc3RlcjtcbmV4cG9ydHMucmVzb2x2ZUhUVFBMaW5rT3B0aW9ucyA9IHJlc29sdmVIVFRQTGlua09wdGlvbnM7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBvYnNlcnZhYmxlID0gcmVxdWlyZSgnQHRycGMvc2VydmVyL29ic2VydmFibGUnKTtcbnZhciB0cmFuc2Zvcm1SZXN1bHQgPSByZXF1aXJlKCcuL3RyYW5zZm9ybVJlc3VsdC1kZmNlOGYxNS5qcycpO1xudmFyIFRSUENDbGllbnRFcnJvciA9IHJlcXVpcmUoJy4vVFJQQ0NsaWVudEVycm9yLTdlMGMzMWU3LmpzJyk7XG52YXIgaHR0cFV0aWxzID0gcmVxdWlyZSgnLi9odHRwVXRpbHMtNDQyOWYzNmUuanMnKTtcblxuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvbiAqLyAvKipcbiAqIEEgZnVuY3Rpb24gdGhhdCBzaG91bGQgbmV2ZXIgYmUgY2FsbGVkIHVubGVzcyB3ZSBtZXNzZWQgc29tZXRoaW5nIHVwLlxuICovIGNvbnN0IHRocm93RmF0YWxFcnJvciA9ICgpPT57XG4gICAgdGhyb3cgbmV3IEVycm9yKCdTb21ldGhpbmcgd2VudCB3cm9uZy4gUGxlYXNlIHN1Ym1pdCBhbiBpc3N1ZSBhdCBodHRwczovL2dpdGh1Yi5jb20vdHJwYy90cnBjL2lzc3Vlcy9uZXcnKTtcbn07XG4vKipcbiAqIERhdGFsb2FkZXIgdGhhdCdzIHZlcnkgaW5zcGlyZWQgYnkgaHR0cHM6Ly9naXRodWIuY29tL2dyYXBocWwvZGF0YWxvYWRlclxuICogTGVzcyBjb25maWd1cmF0aW9uLCBubyBjYWNoaW5nLCBhbmQgYWxsb3dzIHlvdSB0byBjYW5jZWwgcmVxdWVzdHNcbiAqIFdoZW4gY2FuY2VsbGluZyBhIHNpbmdsZSBmZXRjaCB0aGUgd2hvbGUgYmF0Y2ggd2lsbCBiZSBjYW5jZWxsZWQgb25seSB3aGVuIF9hbGxfIGl0ZW1zIGFyZSBjYW5jZWxsZWRcbiAqLyBmdW5jdGlvbiBkYXRhTG9hZGVyKGJhdGNoTG9hZGVyKSB7XG4gICAgbGV0IHBlbmRpbmdJdGVtcyA9IG51bGw7XG4gICAgbGV0IGRpc3BhdGNoVGltZXIgPSBudWxsO1xuICAgIGNvbnN0IGRlc3Ryb3lUaW1lckFuZFBlbmRpbmdJdGVtcyA9ICgpPT57XG4gICAgICAgIGNsZWFyVGltZW91dChkaXNwYXRjaFRpbWVyKTtcbiAgICAgICAgZGlzcGF0Y2hUaW1lciA9IG51bGw7XG4gICAgICAgIHBlbmRpbmdJdGVtcyA9IG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICogSXRlcmF0ZSB0aHJvdWdoIHRoZSBpdGVtcyBhbmQgc3BsaXQgdGhlbSBpbnRvIGdyb3VwcyBiYXNlZCBvbiB0aGUgYGJhdGNoTG9hZGVyYCdzIHZhbGlkYXRlIGZ1bmN0aW9uXG4gICAqLyBmdW5jdGlvbiBncm91cEl0ZW1zKGl0ZW1zKSB7XG4gICAgICAgIGNvbnN0IGdyb3VwZWRJdGVtcyA9IFtcbiAgICAgICAgICAgIFtdXG4gICAgICAgIF07XG4gICAgICAgIGxldCBpbmRleCA9IDA7XG4gICAgICAgIHdoaWxlKHRydWUpe1xuICAgICAgICAgICAgY29uc3QgaXRlbSA9IGl0ZW1zW2luZGV4XTtcbiAgICAgICAgICAgIGlmICghaXRlbSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbGFzdEdyb3VwID0gZ3JvdXBlZEl0ZW1zW2dyb3VwZWRJdGVtcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGlmIChpdGVtLmFib3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBJdGVtIHdhcyBhYm9ydGVkIGJlZm9yZSBpdCB3YXMgZGlzcGF0Y2hlZFxuICAgICAgICAgICAgICAgIGl0ZW0ucmVqZWN0Py4obmV3IEVycm9yKCdBYm9ydGVkJykpO1xuICAgICAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBpc1ZhbGlkID0gYmF0Y2hMb2FkZXIudmFsaWRhdGUobGFzdEdyb3VwLmNvbmNhdChpdGVtKS5tYXAoKGl0KT0+aXQua2V5KSk7XG4gICAgICAgICAgICBpZiAoaXNWYWxpZCkge1xuICAgICAgICAgICAgICAgIGxhc3RHcm91cC5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGFzdEdyb3VwLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGl0ZW0ucmVqZWN0Py4obmV3IEVycm9yKCdJbnB1dCBpcyB0b28gYmlnIGZvciBhIHNpbmdsZSBkaXNwYXRjaCcpKTtcbiAgICAgICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ3JlYXRlIG5ldyBncm91cCwgbmV4dCBpdGVyYXRpb24gd2lsbCB0cnkgdG8gYWRkIHRoZSBpdGVtIHRvIHRoYXRcbiAgICAgICAgICAgIGdyb3VwZWRJdGVtcy5wdXNoKFtdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ3JvdXBlZEl0ZW1zO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkaXNwYXRjaCgpIHtcbiAgICAgICAgY29uc3QgZ3JvdXBlZEl0ZW1zID0gZ3JvdXBJdGVtcyhwZW5kaW5nSXRlbXMpO1xuICAgICAgICBkZXN0cm95VGltZXJBbmRQZW5kaW5nSXRlbXMoKTtcbiAgICAgICAgLy8gQ3JlYXRlIGJhdGNoZXMgZm9yIGVhY2ggZ3JvdXAgb2YgaXRlbXNcbiAgICAgICAgZm9yIChjb25zdCBpdGVtcyBvZiBncm91cGVkSXRlbXMpe1xuICAgICAgICAgICAgaWYgKCFpdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGJhdGNoID0ge1xuICAgICAgICAgICAgICAgIGl0ZW1zLFxuICAgICAgICAgICAgICAgIGNhbmNlbDogdGhyb3dGYXRhbEVycm9yXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGl0ZW1zKXtcbiAgICAgICAgICAgICAgICBpdGVtLmJhdGNoID0gYmF0Y2g7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB1bml0UmVzb2x2ZXIgPSAoaW5kZXgsIHZhbHVlKT0+e1xuICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSBiYXRjaC5pdGVtc1tpbmRleF07XG4gICAgICAgICAgICAgICAgaXRlbS5yZXNvbHZlPy4odmFsdWUpO1xuICAgICAgICAgICAgICAgIGl0ZW0uYmF0Y2ggPSBudWxsO1xuICAgICAgICAgICAgICAgIGl0ZW0ucmVqZWN0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpdGVtLnJlc29sdmUgPSBudWxsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IHsgcHJvbWlzZSAsIGNhbmNlbCAgfSA9IGJhdGNoTG9hZGVyLmZldGNoKGJhdGNoLml0ZW1zLm1hcCgoX2l0ZW0pPT5faXRlbS5rZXkpLCB1bml0UmVzb2x2ZXIpO1xuICAgICAgICAgICAgYmF0Y2guY2FuY2VsID0gY2FuY2VsO1xuICAgICAgICAgICAgcHJvbWlzZS50aGVuKChyZXN1bHQpPT57XG4gICAgICAgICAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHJlc3VsdC5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gcmVzdWx0W2ldO1xuICAgICAgICAgICAgICAgICAgICB1bml0UmVzb2x2ZXIoaSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgYmF0Y2guaXRlbXMpe1xuICAgICAgICAgICAgICAgICAgICBpdGVtLnJlamVjdD8uKG5ldyBFcnJvcignTWlzc2luZyByZXN1bHQnKSk7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uYmF0Y2ggPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLmNhdGNoKChjYXVzZSk9PntcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgYmF0Y2guaXRlbXMpe1xuICAgICAgICAgICAgICAgICAgICBpdGVtLnJlamVjdD8uKGNhdXNlKTtcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5iYXRjaCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gbG9hZChrZXkpIHtcbiAgICAgICAgY29uc3QgaXRlbSA9IHtcbiAgICAgICAgICAgIGFib3J0ZWQ6IGZhbHNlLFxuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgYmF0Y2g6IG51bGwsXG4gICAgICAgICAgICByZXNvbHZlOiB0aHJvd0ZhdGFsRXJyb3IsXG4gICAgICAgICAgICByZWplY3Q6IHRocm93RmF0YWxFcnJvclxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCk9PntcbiAgICAgICAgICAgIGl0ZW0ucmVqZWN0ID0gcmVqZWN0O1xuICAgICAgICAgICAgaXRlbS5yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgICAgICAgIGlmICghcGVuZGluZ0l0ZW1zKSB7XG4gICAgICAgICAgICAgICAgcGVuZGluZ0l0ZW1zID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwZW5kaW5nSXRlbXMucHVzaChpdGVtKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghZGlzcGF0Y2hUaW1lcikge1xuICAgICAgICAgICAgZGlzcGF0Y2hUaW1lciA9IHNldFRpbWVvdXQoZGlzcGF0Y2gpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNhbmNlbCA9ICgpPT57XG4gICAgICAgICAgICBpdGVtLmFib3J0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKGl0ZW0uYmF0Y2g/Lml0ZW1zLmV2ZXJ5KChpdGVtKT0+aXRlbS5hYm9ydGVkKSkge1xuICAgICAgICAgICAgICAgIC8vIEFsbCBpdGVtcyBpbiB0aGUgYmF0Y2ggaGF2ZSBiZWVuIGNhbmNlbGxlZFxuICAgICAgICAgICAgICAgIGl0ZW0uYmF0Y2guY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgaXRlbS5iYXRjaCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwcm9taXNlLFxuICAgICAgICAgICAgY2FuY2VsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGxvYWRcbiAgICB9O1xufVxuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovIGZ1bmN0aW9uIGNyZWF0ZUhUVFBCYXRjaExpbmsocmVxdWVzdGVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGh0dHBCYXRjaExpbmsob3B0cykge1xuICAgICAgICBjb25zdCByZXNvbHZlZE9wdHMgPSBodHRwVXRpbHMucmVzb2x2ZUhUVFBMaW5rT3B0aW9ucyhvcHRzKTtcbiAgICAgICAgY29uc3QgbWF4VVJMTGVuZ3RoID0gb3B0cy5tYXhVUkxMZW5ndGggPz8gSW5maW5pdHk7XG4gICAgICAgIC8vIGluaXRpYWxpemVkIGNvbmZpZ1xuICAgICAgICByZXR1cm4gKHJ1bnRpbWUpPT57XG4gICAgICAgICAgICBjb25zdCBiYXRjaExvYWRlciA9ICh0eXBlKT0+e1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbGlkYXRlID0gKGJhdGNoT3BzKT0+e1xuICAgICAgICAgICAgICAgICAgICBpZiAobWF4VVJMTGVuZ3RoID09PSBJbmZpbml0eSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNjYXBlIGhhdGNoIGZvciBxdWljayBjYWxjc1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGF0aCA9IGJhdGNoT3BzLm1hcCgob3ApPT5vcC5wYXRoKS5qb2luKCcsJyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlucHV0cyA9IGJhdGNoT3BzLm1hcCgob3ApPT5vcC5pbnB1dCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHVybCA9IGh0dHBVdGlscy5nZXRVcmwoe1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4ucmVzb2x2ZWRPcHRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgcnVudGltZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRzXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdXJsLmxlbmd0aCA8PSBtYXhVUkxMZW5ndGg7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjb25zdCBmZXRjaCA9IHJlcXVlc3Rlcih7XG4gICAgICAgICAgICAgICAgICAgIC4uLnJlc29sdmVkT3B0cyxcbiAgICAgICAgICAgICAgICAgICAgcnVudGltZSxcbiAgICAgICAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgb3B0c1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRlLFxuICAgICAgICAgICAgICAgICAgICBmZXRjaFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgcXVlcnkgPSBkYXRhTG9hZGVyKGJhdGNoTG9hZGVyKCdxdWVyeScpKTtcbiAgICAgICAgICAgIGNvbnN0IG11dGF0aW9uID0gZGF0YUxvYWRlcihiYXRjaExvYWRlcignbXV0YXRpb24nKSk7XG4gICAgICAgICAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBkYXRhTG9hZGVyKGJhdGNoTG9hZGVyKCdzdWJzY3JpcHRpb24nKSk7XG4gICAgICAgICAgICBjb25zdCBsb2FkZXJzID0ge1xuICAgICAgICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICBtdXRhdGlvblxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiAoeyBvcCAgfSk9PntcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JzZXJ2YWJsZS5vYnNlcnZhYmxlKChvYnNlcnZlcik9PntcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9hZGVyID0gbG9hZGVyc1tvcC50eXBlXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBwcm9taXNlICwgY2FuY2VsICB9ID0gbG9hZGVyLmxvYWQob3ApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgX3JlcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS50aGVuKChyZXMpPT57XG4gICAgICAgICAgICAgICAgICAgICAgICBfcmVzID0gcmVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdHJhbnNmb3JtZWQgPSB0cmFuc2Zvcm1SZXN1bHQudHJhbnNmb3JtUmVzdWx0KHJlcy5qc29uLCBydW50aW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdHJhbnNmb3JtZWQub2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5lcnJvcihUUlBDQ2xpZW50RXJyb3IuVFJQQ0NsaWVudEVycm9yLmZyb20odHJhbnNmb3JtZWQuZXJyb3IsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0YTogcmVzLm1ldGFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dDogcmVzLm1ldGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiB0cmFuc2Zvcm1lZC5yZXN1bHRcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIuY29tcGxldGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2goKGVycik9PntcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLmVycm9yKFRSUENDbGllbnRFcnJvci5UUlBDQ2xpZW50RXJyb3IuZnJvbShlcnIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRhOiBfcmVzPy5tZXRhXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCk9PntcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbmNlbCgpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICB9O1xufVxuXG5jb25zdCBiYXRjaFJlcXVlc3RlciA9IChyZXF1ZXN0ZXJPcHRzKT0+e1xuICAgIHJldHVybiAoYmF0Y2hPcHMpPT57XG4gICAgICAgIGNvbnN0IHBhdGggPSBiYXRjaE9wcy5tYXAoKG9wKT0+b3AucGF0aCkuam9pbignLCcpO1xuICAgICAgICBjb25zdCBpbnB1dHMgPSBiYXRjaE9wcy5tYXAoKG9wKT0+b3AuaW5wdXQpO1xuICAgICAgICBjb25zdCB7IHByb21pc2UgLCBjYW5jZWwgIH0gPSBodHRwVXRpbHMuanNvbkh0dHBSZXF1ZXN0ZXIoe1xuICAgICAgICAgICAgLi4ucmVxdWVzdGVyT3B0cyxcbiAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICBpbnB1dHMsXG4gICAgICAgICAgICBoZWFkZXJzICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXJlcXVlc3Rlck9wdHMub3B0cy5oZWFkZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZXF1ZXN0ZXJPcHRzLm9wdHMuaGVhZGVycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVxdWVzdGVyT3B0cy5vcHRzLmhlYWRlcnMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BMaXN0OiBiYXRjaE9wc1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3Rlck9wdHMub3B0cy5oZWFkZXJzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHByb21pc2U6IHByb21pc2UudGhlbigocmVzKT0+e1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc0pTT04gPSBBcnJheS5pc0FycmF5KHJlcy5qc29uKSA/IHJlcy5qc29uIDogYmF0Y2hPcHMubWFwKCgpPT5yZXMuanNvbik7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gcmVzSlNPTi5tYXAoKGl0ZW0pPT4oe1xuICAgICAgICAgICAgICAgICAgICAgICAgbWV0YTogcmVzLm1ldGEsXG4gICAgICAgICAgICAgICAgICAgICAgICBqc29uOiBpdGVtXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBjYW5jZWxcbiAgICAgICAgfTtcbiAgICB9O1xufTtcbmNvbnN0IGh0dHBCYXRjaExpbmsgPSBjcmVhdGVIVFRQQmF0Y2hMaW5rKGJhdGNoUmVxdWVzdGVyKTtcblxuZXhwb3J0cy5jcmVhdGVIVFRQQmF0Y2hMaW5rID0gY3JlYXRlSFRUUEJhdGNoTGluaztcbmV4cG9ydHMuaHR0cEJhdGNoTGluayA9IGh0dHBCYXRjaExpbms7XG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBvYnNlcnZhYmxlID0gcmVxdWlyZSgnQHRycGMvc2VydmVyL29ic2VydmFibGUnKTtcbnZhciB0cmFuc2Zvcm1SZXN1bHQgPSByZXF1aXJlKCcuLi90cmFuc2Zvcm1SZXN1bHQtZGZjZThmMTUuanMnKTtcbnZhciBUUlBDQ2xpZW50RXJyb3IgPSByZXF1aXJlKCcuLi9UUlBDQ2xpZW50RXJyb3ItN2UwYzMxZTcuanMnKTtcbnZhciBodHRwVXRpbHMgPSByZXF1aXJlKCcuLi9odHRwVXRpbHMtNDQyOWYzNmUuanMnKTtcbnJlcXVpcmUoJ0B0cnBjL3NlcnZlci9zaGFyZWQnKTtcblxuZnVuY3Rpb24gaHR0cExpbmtGYWN0b3J5KGZhY3RvcnlPcHRzKSB7XG4gICAgcmV0dXJuIChvcHRzKT0+e1xuICAgICAgICBjb25zdCByZXNvbHZlZE9wdHMgPSBodHRwVXRpbHMucmVzb2x2ZUhUVFBMaW5rT3B0aW9ucyhvcHRzKTtcbiAgICAgICAgcmV0dXJuIChydW50aW1lKT0+KHsgb3AgIH0pPT5vYnNlcnZhYmxlLm9ic2VydmFibGUoKG9ic2VydmVyKT0+e1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHBhdGggLCBpbnB1dCAsIHR5cGUgIH0gPSBvcDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBwcm9taXNlICwgY2FuY2VsICB9ID0gZmFjdG9yeU9wdHMucmVxdWVzdGVyKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnJlc29sdmVkT3B0cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bnRpbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVycyAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFvcHRzLmhlYWRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9wdHMuaGVhZGVycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3B0cy5oZWFkZXJzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3B0cy5oZWFkZXJzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1ldGEgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIHByb21pc2UudGhlbigocmVzKT0+e1xuICAgICAgICAgICAgICAgICAgICAgICAgbWV0YSA9IHJlcy5tZXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdHJhbnNmb3JtZWQgPSB0cmFuc2Zvcm1SZXN1bHQudHJhbnNmb3JtUmVzdWx0KHJlcy5qc29uLCBydW50aW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdHJhbnNmb3JtZWQub2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5lcnJvcihUUlBDQ2xpZW50RXJyb3IuVFJQQ0NsaWVudEVycm9yLmZyb20odHJhbnNmb3JtZWQuZXJyb3IsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0YVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5uZXh0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0OiByZXMubWV0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IHRyYW5zZm9ybWVkLnJlc3VsdFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9KS5jYXRjaCgoY2F1c2UpPT57XG4gICAgICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5lcnJvcihUUlBDQ2xpZW50RXJyb3IuVFJQQ0NsaWVudEVycm9yLmZyb20oY2F1c2UsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRhXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCk9PntcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbmNlbCgpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgIH07XG59XG4vKipcbiAqIEBzZWUgaHR0cHM6Ly90cnBjLmlvL2RvY3MvY2xpZW50L2xpbmtzL2h0dHBMaW5rXG4gKi8gY29uc3QgaHR0cExpbmsgPSBodHRwTGlua0ZhY3Rvcnkoe1xuICAgIHJlcXVlc3RlcjogaHR0cFV0aWxzLmpzb25IdHRwUmVxdWVzdGVyXG59KTtcblxuZXhwb3J0cy5odHRwTGluayA9IGh0dHBMaW5rO1xuZXhwb3J0cy5odHRwTGlua0ZhY3RvcnkgPSBodHRwTGlua0ZhY3Rvcnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBvYnNlcnZhYmxlID0gcmVxdWlyZSgnQHRycGMvc2VydmVyL29ic2VydmFibGUnKTtcblxuLy8vIDxyZWZlcmVuY2UgbGliPVwiZG9tLml0ZXJhYmxlXCIgLz5cbmZ1bmN0aW9uIGlzRm9ybURhdGEodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIEZvcm1EYXRhID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAvLyBGb3JtRGF0YSBpcyBub3Qgc3VwcG9ydGVkXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgRm9ybURhdGE7XG59XG5jb25zdCBwYWxldHRlcyA9IHtcbiAgICBjc3M6IHtcbiAgICAgICAgcXVlcnk6IFtcbiAgICAgICAgICAgICc3MmUzZmYnLFxuICAgICAgICAgICAgJzNmYjBkOCdcbiAgICAgICAgXSxcbiAgICAgICAgbXV0YXRpb246IFtcbiAgICAgICAgICAgICdjNWEzZmMnLFxuICAgICAgICAgICAgJzkwNGRmYydcbiAgICAgICAgXSxcbiAgICAgICAgc3Vic2NyaXB0aW9uOiBbXG4gICAgICAgICAgICAnZmY0OWUxJyxcbiAgICAgICAgICAgICdkODNmYmUnXG4gICAgICAgIF1cbiAgICB9LFxuICAgIGFuc2k6IHtcbiAgICAgICAgcmVndWxhcjoge1xuICAgICAgICAgICAgLy8gQ3lhbiBiYWNrZ3JvdW5kLCBibGFjayBhbmQgd2hpdGUgdGV4dCByZXNwZWN0aXZlbHlcbiAgICAgICAgICAgIHF1ZXJ5OiBbXG4gICAgICAgICAgICAgICAgJ1xceDFiWzMwOzQ2bScsXG4gICAgICAgICAgICAgICAgJ1xceDFiWzk3OzQ2bSdcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAvLyBNYWdlbnRhIGJhY2tncm91bmQsIGJsYWNrIGFuZCB3aGl0ZSB0ZXh0IHJlc3BlY3RpdmVseVxuICAgICAgICAgICAgbXV0YXRpb246IFtcbiAgICAgICAgICAgICAgICAnXFx4MWJbMzA7NDVtJyxcbiAgICAgICAgICAgICAgICAnXFx4MWJbOTc7NDVtJ1xuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIC8vIEdyZWVuIGJhY2tncm91bmQsIGJsYWNrIGFuZCB3aGl0ZSB0ZXh0IHJlc3BlY3RpdmVseVxuICAgICAgICAgICAgc3Vic2NyaXB0aW9uOiBbXG4gICAgICAgICAgICAgICAgJ1xceDFiWzMwOzQybScsXG4gICAgICAgICAgICAgICAgJ1xceDFiWzk3OzQybSdcbiAgICAgICAgICAgIF1cbiAgICAgICAgfSxcbiAgICAgICAgYm9sZDoge1xuICAgICAgICAgICAgcXVlcnk6IFtcbiAgICAgICAgICAgICAgICAnXFx4MWJbMTszMDs0Nm0nLFxuICAgICAgICAgICAgICAgICdcXHgxYlsxOzk3OzQ2bSdcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBtdXRhdGlvbjogW1xuICAgICAgICAgICAgICAgICdcXHgxYlsxOzMwOzQ1bScsXG4gICAgICAgICAgICAgICAgJ1xceDFiWzE7OTc7NDVtJ1xuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbjogW1xuICAgICAgICAgICAgICAgICdcXHgxYlsxOzMwOzQybScsXG4gICAgICAgICAgICAgICAgJ1xceDFiWzE7OTc7NDJtJ1xuICAgICAgICAgICAgXVxuICAgICAgICB9XG4gICAgfVxufTtcbmZ1bmN0aW9uIGNvbnN0cnVjdFBhcnRzQW5kQXJncyhvcHRzKSB7XG4gICAgY29uc3QgeyBkaXJlY3Rpb24gLCB0eXBlICwgcGF0aCAsIGlkICwgaW5wdXQgIH0gPSBvcHRzO1xuICAgIGNvbnN0IHBhcnRzID0gW107XG4gICAgY29uc3QgYXJncyA9IFtdO1xuICAgIGlmIChvcHRzLmNvbG9yTW9kZSA9PT0gJ2Fuc2knKSB7XG4gICAgICAgIGNvbnN0IFtsaWdodFJlZ3VsYXIsIGRhcmtSZWd1bGFyXSA9IHBhbGV0dGVzLmFuc2kucmVndWxhclt0eXBlXTtcbiAgICAgICAgY29uc3QgW2xpZ2h0Qm9sZCwgZGFya0JvbGRdID0gcGFsZXR0ZXMuYW5zaS5ib2xkW3R5cGVdO1xuICAgICAgICBjb25zdCByZXNldCA9ICdcXHgxYlswbSc7XG4gICAgICAgIHBhcnRzLnB1c2goZGlyZWN0aW9uID09PSAndXAnID8gbGlnaHRSZWd1bGFyIDogZGFya1JlZ3VsYXIsIGRpcmVjdGlvbiA9PT0gJ3VwJyA/ICc+PicgOiAnPDwnLCB0eXBlLCBkaXJlY3Rpb24gPT09ICd1cCcgPyBsaWdodEJvbGQgOiBkYXJrQm9sZCwgYCMke2lkfWAsIHBhdGgsIHJlc2V0KTtcbiAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gJ3VwJykge1xuICAgICAgICAgICAgYXJncy5wdXNoKHtcbiAgICAgICAgICAgICAgICBpbnB1dDogb3B0cy5pbnB1dFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhcmdzLnB1c2goe1xuICAgICAgICAgICAgICAgIGlucHV0OiBvcHRzLmlucHV0LFxuICAgICAgICAgICAgICAgIC8vIHN0cmlwIGNvbnRleHQgZnJvbSByZXN1bHQgY2F1c2UgaXQncyB0b28gbm9pc3kgaW4gdGVybWluYWwgd2lodG91dCBjb2xsYXBzZSBtb2RlXG4gICAgICAgICAgICAgICAgcmVzdWx0OiAncmVzdWx0JyBpbiBvcHRzLnJlc3VsdCA/IG9wdHMucmVzdWx0LnJlc3VsdCA6IG9wdHMucmVzdWx0LFxuICAgICAgICAgICAgICAgIGVsYXBzZWRNczogb3B0cy5lbGFwc2VkTXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwYXJ0cyxcbiAgICAgICAgICAgIGFyZ3NcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgW2xpZ2h0LCBkYXJrXSA9IHBhbGV0dGVzLmNzc1t0eXBlXTtcbiAgICBjb25zdCBjc3MgPSBgXG4gICAgYmFja2dyb3VuZC1jb2xvcjogIyR7ZGlyZWN0aW9uID09PSAndXAnID8gbGlnaHQgOiBkYXJrfTsgXG4gICAgY29sb3I6ICR7ZGlyZWN0aW9uID09PSAndXAnID8gJ2JsYWNrJyA6ICd3aGl0ZSd9O1xuICAgIHBhZGRpbmc6IDJweDtcbiAgYDtcbiAgICBwYXJ0cy5wdXNoKCclYycsIGRpcmVjdGlvbiA9PT0gJ3VwJyA/ICc+PicgOiAnPDwnLCB0eXBlLCBgIyR7aWR9YCwgYCVjJHtwYXRofSVjYCwgJyVPJyk7XG4gICAgYXJncy5wdXNoKGNzcywgYCR7Y3NzfTsgZm9udC13ZWlnaHQ6IGJvbGQ7YCwgYCR7Y3NzfTsgZm9udC13ZWlnaHQ6IG5vcm1hbDtgKTtcbiAgICBpZiAoZGlyZWN0aW9uID09PSAndXAnKSB7XG4gICAgICAgIGFyZ3MucHVzaCh7XG4gICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgIGNvbnRleHQ6IG9wdHMuY29udGV4dFxuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBhcmdzLnB1c2goe1xuICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICByZXN1bHQ6IG9wdHMucmVzdWx0LFxuICAgICAgICAgICAgZWxhcHNlZE1zOiBvcHRzLmVsYXBzZWRNcyxcbiAgICAgICAgICAgIGNvbnRleHQ6IG9wdHMuY29udGV4dFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcGFydHMsXG4gICAgICAgIGFyZ3NcbiAgICB9O1xufVxuLy8gbWF5YmUgdGhpcyBzaG91bGQgYmUgbW92ZWQgdG8gaXQncyBvd24gcGFja2FnZVxuY29uc3QgZGVmYXVsdExvZ2dlciA9ICh7IGMgPWNvbnNvbGUgLCBjb2xvck1vZGUgPSdjc3MnICB9KT0+KHByb3BzKT0+e1xuICAgICAgICBjb25zdCByYXdJbnB1dCA9IHByb3BzLmlucHV0O1xuICAgICAgICBjb25zdCBpbnB1dCA9IGlzRm9ybURhdGEocmF3SW5wdXQpID8gT2JqZWN0LmZyb21FbnRyaWVzKHJhd0lucHV0KSA6IHJhd0lucHV0O1xuICAgICAgICBjb25zdCB7IHBhcnRzICwgYXJncyAgfSA9IGNvbnN0cnVjdFBhcnRzQW5kQXJncyh7XG4gICAgICAgICAgICAuLi5wcm9wcyxcbiAgICAgICAgICAgIGNvbG9yTW9kZSxcbiAgICAgICAgICAgIGlucHV0XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBmbiA9IHByb3BzLmRpcmVjdGlvbiA9PT0gJ2Rvd24nICYmIHByb3BzLnJlc3VsdCAmJiAocHJvcHMucmVzdWx0IGluc3RhbmNlb2YgRXJyb3IgfHwgJ2Vycm9yJyBpbiBwcm9wcy5yZXN1bHQucmVzdWx0KSA/ICdlcnJvcicgOiAnbG9nJztcbiAgICAgICAgY1tmbl0uYXBwbHkobnVsbCwgW1xuICAgICAgICAgICAgcGFydHMuam9pbignICcpXG4gICAgICAgIF0uY29uY2F0KGFyZ3MpKTtcbiAgICB9O1xuLyoqXG4gKiBAc2VlIGh0dHBzOi8vdHJwYy5pby9kb2NzL2NsaWVudC9saW5rcy9sb2dnZXJMaW5rXG4gKi8gZnVuY3Rpb24gbG9nZ2VyTGluayhvcHRzID0ge30pIHtcbiAgICBjb25zdCB7IGVuYWJsZWQgPSgpPT50cnVlICB9ID0gb3B0cztcbiAgICBjb25zdCBjb2xvck1vZGUgPSBvcHRzLmNvbG9yTW9kZSA/PyAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyAnYW5zaScgOiAnY3NzJyk7XG4gICAgY29uc3QgeyBsb2dnZXIgPWRlZmF1bHRMb2dnZXIoe1xuICAgICAgICBjOiBvcHRzLmNvbnNvbGUsXG4gICAgICAgIGNvbG9yTW9kZVxuICAgIH0pICB9ID0gb3B0cztcbiAgICByZXR1cm4gKCk9PntcbiAgICAgICAgcmV0dXJuICh7IG9wICwgbmV4dCAgfSk9PntcbiAgICAgICAgICAgIHJldHVybiBvYnNlcnZhYmxlLm9ic2VydmFibGUoKG9ic2VydmVyKT0+e1xuICAgICAgICAgICAgICAgIC8vIC0+XG4gICAgICAgICAgICAgICAgZW5hYmxlZCh7XG4gICAgICAgICAgICAgICAgICAgIC4uLm9wLFxuICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb246ICd1cCdcbiAgICAgICAgICAgICAgICB9KSAmJiBsb2dnZXIoe1xuICAgICAgICAgICAgICAgICAgICAuLi5vcCxcbiAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uOiAndXAnXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVxdWVzdFN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gbG9nUmVzdWx0KHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlbGFwc2VkTXMgPSBEYXRlLm5vdygpIC0gcmVxdWVzdFN0YXJ0VGltZTtcbiAgICAgICAgICAgICAgICAgICAgZW5hYmxlZCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5vcCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogJ2Rvd24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0XG4gICAgICAgICAgICAgICAgICAgIH0pICYmIGxvZ2dlcih7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5vcCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogJ2Rvd24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgZWxhcHNlZE1zLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbmV4dChvcCkucGlwZShvYnNlcnZhYmxlLnRhcCh7XG4gICAgICAgICAgICAgICAgICAgIG5leHQgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nUmVzdWx0KHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGVycm9yIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ1Jlc3VsdChyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkpLnN1YnNjcmliZShvYnNlcnZlcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICB9O1xufVxuXG5leHBvcnRzLmxvZ2dlckxpbmsgPSBsb2dnZXJMaW5rO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgb2JzZXJ2YWJsZSA9IHJlcXVpcmUoJ0B0cnBjL3NlcnZlci9vYnNlcnZhYmxlJyk7XG52YXIgdHJhbnNmb3JtUmVzdWx0ID0gcmVxdWlyZSgnLi4vdHJhbnNmb3JtUmVzdWx0LWRmY2U4ZjE1LmpzJyk7XG52YXIgVFJQQ0NsaWVudEVycm9yID0gcmVxdWlyZSgnLi4vVFJQQ0NsaWVudEVycm9yLTdlMGMzMWU3LmpzJyk7XG5yZXF1aXJlKCdAdHJwYy9zZXJ2ZXIvc2hhcmVkJyk7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0IC0tIEBwcmVzZXJ2ZSAqLyBjb25zdCByZXRyeURlbGF5ID0gKGF0dGVtcHRJbmRleCk9PmF0dGVtcHRJbmRleCA9PT0gMCA/IDAgOiBNYXRoLm1pbigxMDAwICogMiAqKiBhdHRlbXB0SW5kZXgsIDMwMDAwKTtcblxuZnVuY3Rpb24gY3JlYXRlV1NDbGllbnQob3B0cykge1xuICAgIGNvbnN0IHsgdXJsICwgV2ViU29ja2V0OiBXZWJTb2NrZXRJbXBsID0gV2ViU29ja2V0ICwgcmV0cnlEZWxheU1zOiByZXRyeURlbGF5Rm4gPSByZXRyeURlbGF5ICwgb25PcGVuICwgb25DbG9zZSAsICB9ID0gb3B0cztcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAtLSBAcHJlc2VydmUgKi8gaWYgKCFXZWJTb2NrZXRJbXBsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIFdlYlNvY2tldCBpbXBsZW1lbnRhdGlvbiBmb3VuZCAtIHlvdSBwcm9iYWJseSBkb24ndCB3YW50IHRvIHVzZSB0aGlzIG9uIHRoZSBzZXJ2ZXIsIGJ1dCBpZiB5b3UgZG8geW91IG5lZWQgdG8gcGFzcyBhIGBXZWJTb2NrZXRgLXBvbnlmaWxsXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICogb3V0Z29pbmcgbWVzc2FnZXMgYnVmZmVyIHdoaWxzdCBub3Qgb3BlblxuICAgKi8gbGV0IG91dGdvaW5nID0gW107XG4gICAgY29uc3QgcGVuZGluZ1JlcXVlc3RzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBsZXQgY29ubmVjdEF0dGVtcHQgPSAwO1xuICAgIGxldCBkaXNwYXRjaFRpbWVyID0gbnVsbDtcbiAgICBsZXQgY29ubmVjdFRpbWVyID0gbnVsbDtcbiAgICBsZXQgYWN0aXZlQ29ubmVjdGlvbiA9IGNyZWF0ZVdTKCk7XG4gICAgbGV0IHN0YXRlID0gJ2Nvbm5lY3RpbmcnO1xuICAgIC8qKlxuICAgKiB0cmllcyB0byBzZW5kIHRoZSBsaXN0IG9mIG1lc3NhZ2VzXG4gICAqLyBmdW5jdGlvbiBkaXNwYXRjaCgpIHtcbiAgICAgICAgaWYgKHN0YXRlICE9PSAnb3BlbicgfHwgZGlzcGF0Y2hUaW1lcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGRpc3BhdGNoVGltZXIgPSBzZXRUaW1lb3V0KCgpPT57XG4gICAgICAgICAgICBkaXNwYXRjaFRpbWVyID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChvdXRnb2luZy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAvLyBzaW5nbGUgc2VuZFxuICAgICAgICAgICAgICAgIGFjdGl2ZUNvbm5lY3Rpb24uc2VuZChKU09OLnN0cmluZ2lmeShvdXRnb2luZy5wb3AoKSkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBiYXRjaCBzZW5kXG4gICAgICAgICAgICAgICAgYWN0aXZlQ29ubmVjdGlvbi5zZW5kKEpTT04uc3RyaW5naWZ5KG91dGdvaW5nKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjbGVhclxuICAgICAgICAgICAgb3V0Z29pbmcgPSBbXTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRyeVJlY29ubmVjdCgpIHtcbiAgICAgICAgaWYgKGNvbm5lY3RUaW1lciAhPT0gbnVsbCB8fCBzdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0aW1lb3V0ID0gcmV0cnlEZWxheUZuKGNvbm5lY3RBdHRlbXB0KyspO1xuICAgICAgICByZWNvbm5lY3RJbk1zKHRpbWVvdXQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZWNvbm5lY3QoKSB7XG4gICAgICAgIHN0YXRlID0gJ2Nvbm5lY3RpbmcnO1xuICAgICAgICBjb25zdCBvbGRDb25uZWN0aW9uID0gYWN0aXZlQ29ubmVjdGlvbjtcbiAgICAgICAgYWN0aXZlQ29ubmVjdGlvbiA9IGNyZWF0ZVdTKCk7XG4gICAgICAgIGNsb3NlSWZOb1BlbmRpbmcob2xkQ29ubmVjdGlvbik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlY29ubmVjdEluTXMobXMpIHtcbiAgICAgICAgaWYgKGNvbm5lY3RUaW1lcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlID0gJ2Nvbm5lY3RpbmcnO1xuICAgICAgICBjb25uZWN0VGltZXIgPSBzZXRUaW1lb3V0KHJlY29ubmVjdCwgbXMpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjbG9zZUlmTm9QZW5kaW5nKGNvbm4pIHtcbiAgICAgICAgLy8gZGlzY29ubmVjdCBhcyBzb29uIGFzIHRoZXJlIGFyZSBhcmUgbm8gcGVuZGluZyByZXN1bHRcbiAgICAgICAgY29uc3QgaGFzUGVuZGluZ1JlcXVlc3RzID0gT2JqZWN0LnZhbHVlcyhwZW5kaW5nUmVxdWVzdHMpLnNvbWUoKHApPT5wLndzID09PSBjb25uKTtcbiAgICAgICAgaWYgKCFoYXNQZW5kaW5nUmVxdWVzdHMpIHtcbiAgICAgICAgICAgIGNvbm4uY2xvc2UoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjbG9zZUFjdGl2ZVN1YnNjcmlwdGlvbnMoKSB7XG4gICAgICAgIE9iamVjdC52YWx1ZXMocGVuZGluZ1JlcXVlc3RzKS5mb3JFYWNoKChyZXEpPT57XG4gICAgICAgICAgICBpZiAocmVxLnR5cGUgPT09ICdzdWJzY3JpcHRpb24nKSB7XG4gICAgICAgICAgICAgICAgcmVxLmNhbGxiYWNrcy5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzdW1lU3Vic2NyaXB0aW9uT25SZWNvbm5lY3QocmVxKSB7XG4gICAgICAgIGlmIChvdXRnb2luZy5zb21lKChyKT0+ci5pZCA9PT0gcmVxLm9wLmlkKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJlcXVlc3QocmVxLm9wLCByZXEuY2FsbGJhY2tzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlV1MoKSB7XG4gICAgICAgIGNvbnN0IHVybFN0cmluZyA9IHR5cGVvZiB1cmwgPT09ICdmdW5jdGlvbicgPyB1cmwoKSA6IHVybDtcbiAgICAgICAgY29uc3QgY29ubiA9IG5ldyBXZWJTb2NrZXRJbXBsKHVybFN0cmluZyk7XG4gICAgICAgIGNsZWFyVGltZW91dChjb25uZWN0VGltZXIpO1xuICAgICAgICBjb25uZWN0VGltZXIgPSBudWxsO1xuICAgICAgICBjb25uLmFkZEV2ZW50TGlzdGVuZXIoJ29wZW4nLCAoKT0+e1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgLS0gQHByZXNlcnZlICovIGlmIChjb25uICE9PSBhY3RpdmVDb25uZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29ubmVjdEF0dGVtcHQgPSAwO1xuICAgICAgICAgICAgc3RhdGUgPSAnb3Blbic7XG4gICAgICAgICAgICBvbk9wZW4/LigpO1xuICAgICAgICAgICAgZGlzcGF0Y2goKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbm4uYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCAoKT0+e1xuICAgICAgICAgICAgaWYgKGNvbm4gPT09IGFjdGl2ZUNvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgICAgICB0cnlSZWNvbm5lY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGhhbmRsZUluY29taW5nUmVxdWVzdCA9IChyZXEpPT57XG4gICAgICAgICAgICBpZiAocmVxLm1ldGhvZCA9PT0gJ3JlY29ubmVjdCcgJiYgY29ubiA9PT0gYWN0aXZlQ29ubmVjdGlvbikge1xuICAgICAgICAgICAgICAgIGlmIChzdGF0ZSA9PT0gJ29wZW4nKSB7XG4gICAgICAgICAgICAgICAgICAgIG9uQ2xvc2U/LigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZWNvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICAvLyBub3RpZnkgc3Vic2NyaWJlcnNcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHBlbmRpbmdSZXEgb2YgT2JqZWN0LnZhbHVlcyhwZW5kaW5nUmVxdWVzdHMpKXtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBlbmRpbmdSZXEudHlwZSA9PT0gJ3N1YnNjcmlwdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VtZVN1YnNjcmlwdGlvbk9uUmVjb25uZWN0KHBlbmRpbmdSZXEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBoYW5kbGVJbmNvbWluZ1Jlc3BvbnNlID0gKGRhdGEpPT57XG4gICAgICAgICAgICBjb25zdCByZXEgPSBkYXRhLmlkICE9PSBudWxsICYmIHBlbmRpbmdSZXF1ZXN0c1tkYXRhLmlkXTtcbiAgICAgICAgICAgIGlmICghcmVxKSB7XG4gICAgICAgICAgICAgICAgLy8gZG8gc29tZXRoaW5nP1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcS5jYWxsYmFja3MubmV4dD8uKGRhdGEpO1xuICAgICAgICAgICAgaWYgKHJlcS53cyAhPT0gYWN0aXZlQ29ubmVjdGlvbiAmJiBjb25uID09PSBhY3RpdmVDb25uZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2xkV3MgPSByZXEud3M7XG4gICAgICAgICAgICAgICAgLy8gZ3JhY2VmdWxseSByZXBsYWNlIG9sZCBjb25uZWN0aW9uIHdpdGggdGhpc1xuICAgICAgICAgICAgICAgIHJlcS53cyA9IGFjdGl2ZUNvbm5lY3Rpb247XG4gICAgICAgICAgICAgICAgY2xvc2VJZk5vUGVuZGluZyhvbGRXcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoJ3Jlc3VsdCcgaW4gZGF0YSAmJiBkYXRhLnJlc3VsdC50eXBlID09PSAnc3RvcHBlZCcgJiYgY29ubiA9PT0gYWN0aXZlQ29ubmVjdGlvbikge1xuICAgICAgICAgICAgICAgIHJlcS5jYWxsYmFja3MuY29tcGxldGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29ubi5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgKHsgZGF0YSAgfSk9PntcbiAgICAgICAgICAgIGNvbnN0IG1zZyA9IEpTT04ucGFyc2UoZGF0YSk7XG4gICAgICAgICAgICBpZiAoJ21ldGhvZCcgaW4gbXNnKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlSW5jb21pbmdSZXF1ZXN0KG1zZyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGhhbmRsZUluY29taW5nUmVzcG9uc2UobXNnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb25uICE9PSBhY3RpdmVDb25uZWN0aW9uIHx8IHN0YXRlID09PSAnY2xvc2VkJykge1xuICAgICAgICAgICAgICAgIC8vIHdoZW4gcmVjZWl2aW5nIGEgbWVzc2FnZSwgd2UgY2xvc2Ugb2xkIGNvbm5lY3Rpb24gdGhhdCBoYXMgbm8gcGVuZGluZyByZXF1ZXN0c1xuICAgICAgICAgICAgICAgIGNsb3NlSWZOb1BlbmRpbmcoY29ubik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25uLmFkZEV2ZW50TGlzdGVuZXIoJ2Nsb3NlJywgKHsgY29kZSAgfSk9PntcbiAgICAgICAgICAgIGlmIChzdGF0ZSA9PT0gJ29wZW4nKSB7XG4gICAgICAgICAgICAgICAgb25DbG9zZT8uKHtcbiAgICAgICAgICAgICAgICAgICAgY29kZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFjdGl2ZUNvbm5lY3Rpb24gPT09IGNvbm4pIHtcbiAgICAgICAgICAgICAgICAvLyBjb25uZWN0aW9uIG1pZ2h0IGhhdmUgYmVlbiByZXBsYWNlZCBhbHJlYWR5XG4gICAgICAgICAgICAgICAgdHJ5UmVjb25uZWN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHJlcV0gb2YgT2JqZWN0LmVudHJpZXMocGVuZGluZ1JlcXVlc3RzKSl7XG4gICAgICAgICAgICAgICAgaWYgKHJlcS53cyAhPT0gY29ubikge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlID09PSAnY2xvc2VkJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgY29ubmVjdGlvbiB3YXMgY2xvc2VkLCB3ZSBqdXN0IGNhbGwgYGNvbXBsZXRlKClgIG9uIHRoZSByZXF1ZXN0XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBwZW5kaW5nUmVxdWVzdHNba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgcmVxLmNhbGxiYWNrcy5jb21wbGV0ZT8uKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBUaGUgY29ubmVjdGlvbiB3YXMgY2xvc2VkIGVpdGhlciB1bmV4cGVjdGVkbHkgb3IgYmVjYXVzZSBvZiBhIHJlY29ubmVjdFxuICAgICAgICAgICAgICAgIGlmIChyZXEudHlwZSA9PT0gJ3N1YnNjcmlwdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU3Vic2NyaXB0aW9ucyB3aWxsIHJlc3VtZSBhZnRlciB3ZSd2ZSByZWNvbm5lY3RlZFxuICAgICAgICAgICAgICAgICAgICByZXN1bWVTdWJzY3JpcHRpb25PblJlY29ubmVjdChyZXEpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFF1ZXJpZXMgYW5kIG11dGF0aW9ucyB3aWxsIGVycm9yIGlmIGludGVycnVwdGVkXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBwZW5kaW5nUmVxdWVzdHNba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgcmVxLmNhbGxiYWNrcy5lcnJvcj8uKFRSUENDbGllbnRFcnJvci5UUlBDQ2xpZW50RXJyb3IuZnJvbShuZXcgVFJQQ1dlYlNvY2tldENsb3NlZEVycm9yKCdXZWJTb2NrZXQgY2xvc2VkIHByZW1hdHVyZWx5JykpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY29ubjtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVxdWVzdChvcCwgY2FsbGJhY2tzKSB7XG4gICAgICAgIGNvbnN0IHsgdHlwZSAsIGlucHV0ICwgcGF0aCAsIGlkICB9ID0gb3A7XG4gICAgICAgIGNvbnN0IGVudmVsb3BlID0ge1xuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBtZXRob2Q6IHR5cGUsXG4gICAgICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICBwYXRoXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHBlbmRpbmdSZXF1ZXN0c1tpZF0gPSB7XG4gICAgICAgICAgICB3czogYWN0aXZlQ29ubmVjdGlvbixcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICBjYWxsYmFja3MsXG4gICAgICAgICAgICBvcFxuICAgICAgICB9O1xuICAgICAgICAvLyBlbnF1ZXVlIG1lc3NhZ2VcbiAgICAgICAgb3V0Z29pbmcucHVzaChlbnZlbG9wZSk7XG4gICAgICAgIGRpc3BhdGNoKCk7XG4gICAgICAgIHJldHVybiAoKT0+e1xuICAgICAgICAgICAgY29uc3QgY2FsbGJhY2tzID0gcGVuZGluZ1JlcXVlc3RzW2lkXT8uY2FsbGJhY2tzO1xuICAgICAgICAgICAgZGVsZXRlIHBlbmRpbmdSZXF1ZXN0c1tpZF07XG4gICAgICAgICAgICBvdXRnb2luZyA9IG91dGdvaW5nLmZpbHRlcigobXNnKT0+bXNnLmlkICE9PSBpZCk7XG4gICAgICAgICAgICBjYWxsYmFja3M/LmNvbXBsZXRlPy4oKTtcbiAgICAgICAgICAgIGlmIChhY3RpdmVDb25uZWN0aW9uLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldEltcGwuT1BFTiAmJiBvcC50eXBlID09PSAnc3Vic2NyaXB0aW9uJykge1xuICAgICAgICAgICAgICAgIG91dGdvaW5nLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnc3Vic2NyaXB0aW9uLnN0b3AnXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2goKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY2xvc2U6ICgpPT57XG4gICAgICAgICAgICBzdGF0ZSA9ICdjbG9zZWQnO1xuICAgICAgICAgICAgb25DbG9zZT8uKCk7XG4gICAgICAgICAgICBjbG9zZUFjdGl2ZVN1YnNjcmlwdGlvbnMoKTtcbiAgICAgICAgICAgIGNsb3NlSWZOb1BlbmRpbmcoYWN0aXZlQ29ubmVjdGlvbik7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoY29ubmVjdFRpbWVyKTtcbiAgICAgICAgICAgIGNvbm5lY3RUaW1lciA9IG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIHJlcXVlc3QsXG4gICAgICAgIGdldENvbm5lY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGFjdGl2ZUNvbm5lY3Rpb247XG4gICAgICAgIH1cbiAgICB9O1xufVxuY2xhc3MgVFJQQ1dlYlNvY2tldENsb3NlZEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2Upe1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ1RSUENXZWJTb2NrZXRDbG9zZWRFcnJvcic7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBUUlBDV2ViU29ja2V0Q2xvc2VkRXJyb3IucHJvdG90eXBlKTtcbiAgICB9XG59XG4vKipcbiAqIEBzZWUgaHR0cHM6Ly90cnBjLmlvL2RvY3MvY2xpZW50L2xpbmtzL3dzTGlua1xuICovIGZ1bmN0aW9uIHdzTGluayhvcHRzKSB7XG4gICAgcmV0dXJuIChydW50aW1lKT0+e1xuICAgICAgICBjb25zdCB7IGNsaWVudCAgfSA9IG9wdHM7XG4gICAgICAgIHJldHVybiAoeyBvcCAgfSk9PntcbiAgICAgICAgICAgIHJldHVybiBvYnNlcnZhYmxlLm9ic2VydmFibGUoKG9ic2VydmVyKT0+e1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgdHlwZSAsIHBhdGggLCBpZCAsIGNvbnRleHQgIH0gPSBvcDtcbiAgICAgICAgICAgICAgICBjb25zdCBpbnB1dCA9IHJ1bnRpbWUudHJhbnNmb3JtZXIuc2VyaWFsaXplKG9wLmlucHV0KTtcbiAgICAgICAgICAgICAgICBjb25zdCB1bnN1YiA9IGNsaWVudC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0XG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICBlcnJvciAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5lcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdW5zdWIoKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgY29tcGxldGUgKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIuY29tcGxldGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgbmV4dCAobWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdHJhbnNmb3JtZWQgPSB0cmFuc2Zvcm1SZXN1bHQudHJhbnNmb3JtUmVzdWx0KG1lc3NhZ2UsIHJ1bnRpbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0cmFuc2Zvcm1lZC5vaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLmVycm9yKFRSUENDbGllbnRFcnJvci5UUlBDQ2xpZW50RXJyb3IuZnJvbSh0cmFuc2Zvcm1lZC5lcnJvcikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLm5leHQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDogdHJhbnNmb3JtZWQucmVzdWx0XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcC50eXBlICE9PSAnc3Vic2NyaXB0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIGl0IGlzbid0IGEgc3Vic2NyaXB0aW9uIHdlIGRvbid0IGNhcmUgYWJvdXQgbmV4dCByZXNwb25zZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuc3ViKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIuY29tcGxldGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiAoKT0+e1xuICAgICAgICAgICAgICAgICAgICB1bnN1YigpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICB9O1xufVxuXG5leHBvcnRzLmNyZWF0ZVdTQ2xpZW50ID0gY3JlYXRlV1NDbGllbnQ7XG5leHBvcnRzLndzTGluayA9IHdzTGluaztcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIG9ic2VydmFibGUgPSByZXF1aXJlKCdAdHJwYy9zZXJ2ZXIvb2JzZXJ2YWJsZScpO1xudmFyIGxpbmtzX3NwbGl0TGluayA9IHJlcXVpcmUoJy4vc3BsaXRMaW5rLWYyOWU4NGJlLmpzJyk7XG52YXIgVFJQQ0NsaWVudEVycm9yID0gcmVxdWlyZSgnLi9UUlBDQ2xpZW50RXJyb3ItN2UwYzMxZTcuanMnKTtcbnZhciBzaGFyZWQgPSByZXF1aXJlKCdAdHJwYy9zZXJ2ZXIvc2hhcmVkJyk7XG52YXIgaHR0cFV0aWxzID0gcmVxdWlyZSgnLi9odHRwVXRpbHMtNDQyOWYzNmUuanMnKTtcbnZhciBsaW5rc19odHRwQmF0Y2hMaW5rID0gcmVxdWlyZSgnLi9odHRwQmF0Y2hMaW5rLTZiNWJhNjM4LmpzJyk7XG52YXIgbGlua3NfaHR0cExpbmsgPSByZXF1aXJlKCcuL2xpbmtzL2h0dHBMaW5rLmpzJyk7XG52YXIgbGlua3NfbG9nZ2VyTGluayA9IHJlcXVpcmUoJy4vbGlua3MvbG9nZ2VyTGluay5qcycpO1xudmFyIGxpbmtzX3dzTGluayA9IHJlcXVpcmUoJy4vbGlua3Mvd3NMaW5rLmpzJyk7XG5yZXF1aXJlKCcuL3RyYW5zZm9ybVJlc3VsdC1kZmNlOGYxNS5qcycpO1xuXG5jbGFzcyBUUlBDVW50eXBlZENsaWVudCB7XG4gICAgJHJlcXVlc3QoeyB0eXBlICwgaW5wdXQgLCBwYXRoICwgY29udGV4dCA9e30gIH0pIHtcbiAgICAgICAgY29uc3QgY2hhaW4kID0gbGlua3Nfc3BsaXRMaW5rLmNyZWF0ZUNoYWluKHtcbiAgICAgICAgICAgIGxpbmtzOiB0aGlzLmxpbmtzLFxuICAgICAgICAgICAgb3A6IHtcbiAgICAgICAgICAgICAgICBpZDogKyt0aGlzLnJlcXVlc3RJZCxcbiAgICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgICAgY29udGV4dFxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNoYWluJC5waXBlKG9ic2VydmFibGUuc2hhcmUoKSk7XG4gICAgfVxuICAgIHJlcXVlc3RBc1Byb21pc2Uob3B0cykge1xuICAgICAgICBjb25zdCByZXEkID0gdGhpcy4kcmVxdWVzdChvcHRzKTtcbiAgICAgICAgY29uc3QgeyBwcm9taXNlICwgYWJvcnQgIH0gPSBvYnNlcnZhYmxlLm9ic2VydmFibGVUb1Byb21pc2UocmVxJCk7XG4gICAgICAgIGNvbnN0IGFib3J0YWJsZVByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KT0+e1xuICAgICAgICAgICAgb3B0cy5zaWduYWw/LmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnQpO1xuICAgICAgICAgICAgcHJvbWlzZS50aGVuKChlbnZlbG9wZSk9PntcbiAgICAgICAgICAgICAgICByZXNvbHZlKGVudmVsb3BlLnJlc3VsdC5kYXRhKTtcbiAgICAgICAgICAgIH0pLmNhdGNoKChlcnIpPT57XG4gICAgICAgICAgICAgICAgcmVqZWN0KFRSUENDbGllbnRFcnJvci5UUlBDQ2xpZW50RXJyb3IuZnJvbShlcnIpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGFib3J0YWJsZVByb21pc2U7XG4gICAgfVxuICAgIHF1ZXJ5KHBhdGgsIGlucHV0LCBvcHRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3RBc1Byb21pc2Uoe1xuICAgICAgICAgICAgdHlwZTogJ3F1ZXJ5JyxcbiAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgIGNvbnRleHQ6IG9wdHM/LmNvbnRleHQsXG4gICAgICAgICAgICBzaWduYWw6IG9wdHM/LnNpZ25hbFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbXV0YXRpb24ocGF0aCwgaW5wdXQsIG9wdHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdEFzUHJvbWlzZSh7XG4gICAgICAgICAgICB0eXBlOiAnbXV0YXRpb24nLFxuICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgY29udGV4dDogb3B0cz8uY29udGV4dCxcbiAgICAgICAgICAgIHNpZ25hbDogb3B0cz8uc2lnbmFsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdWJzY3JpcHRpb24ocGF0aCwgaW5wdXQsIG9wdHMpIHtcbiAgICAgICAgY29uc3Qgb2JzZXJ2YWJsZSQgPSB0aGlzLiRyZXF1ZXN0KHtcbiAgICAgICAgICAgIHR5cGU6ICdzdWJzY3JpcHRpb24nLFxuICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgY29udGV4dDogb3B0cz8uY29udGV4dFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG9ic2VydmFibGUkLnN1YnNjcmliZSh7XG4gICAgICAgICAgICBuZXh0IChlbnZlbG9wZSkge1xuICAgICAgICAgICAgICAgIGlmIChlbnZlbG9wZS5yZXN1bHQudHlwZSA9PT0gJ3N0YXJ0ZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdHMub25TdGFydGVkPy4oKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGVudmVsb3BlLnJlc3VsdC50eXBlID09PSAnc3RvcHBlZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0cy5vblN0b3BwZWQ/LigpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdHMub25EYXRhPy4oZW52ZWxvcGUucmVzdWx0LmRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlcnJvciAoZXJyKSB7XG4gICAgICAgICAgICAgICAgb3B0cy5vbkVycm9yPy4oZXJyKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb21wbGV0ZSAoKSB7XG4gICAgICAgICAgICAgICAgb3B0cy5vbkNvbXBsZXRlPy4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKG9wdHMpe1xuICAgICAgICB0aGlzLnJlcXVlc3RJZCA9IDA7XG4gICAgICAgIGNvbnN0IGNvbWJpbmVkVHJhbnNmb3JtZXIgPSAoKCk9PntcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zZm9ybWVyID0gb3B0cy50cmFuc2Zvcm1lcjtcbiAgICAgICAgICAgIGlmICghdHJhbnNmb3JtZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBpbnB1dDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWFsaXplOiAoZGF0YSk9PmRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXNlcmlhbGl6ZTogKGRhdGEpPT5kYXRhXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWFsaXplOiAoZGF0YSk9PmRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXNlcmlhbGl6ZTogKGRhdGEpPT5kYXRhXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCdpbnB1dCcgaW4gdHJhbnNmb3JtZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3B0cy50cmFuc2Zvcm1lcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaW5wdXQ6IHRyYW5zZm9ybWVyLFxuICAgICAgICAgICAgICAgIG91dHB1dDogdHJhbnNmb3JtZXJcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pKCk7XG4gICAgICAgIHRoaXMucnVudGltZSA9IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVyOiB7XG4gICAgICAgICAgICAgICAgc2VyaWFsaXplOiAoZGF0YSk9PmNvbWJpbmVkVHJhbnNmb3JtZXIuaW5wdXQuc2VyaWFsaXplKGRhdGEpLFxuICAgICAgICAgICAgICAgIGRlc2VyaWFsaXplOiAoZGF0YSk9PmNvbWJpbmVkVHJhbnNmb3JtZXIub3V0cHV0LmRlc2VyaWFsaXplKGRhdGEpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29tYmluZWRUcmFuc2Zvcm1lclxuICAgICAgICB9O1xuICAgICAgICAvLyBJbml0aWFsaXplIHRoZSBsaW5rc1xuICAgICAgICB0aGlzLmxpbmtzID0gb3B0cy5saW5rcy5tYXAoKGxpbmspPT5saW5rKHRoaXMucnVudGltZSkpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlVFJQQ1VudHlwZWRDbGllbnQob3B0cykge1xuICAgIHJldHVybiBuZXcgVFJQQ1VudHlwZWRDbGllbnQob3B0cyk7XG59XG5cbi8qKlxuICogQGRlcHJlY2F0ZWQgdXNlIGBjcmVhdGVUUlBDUHJveHlDbGllbnRgIGluc3RlYWRcbiAqLyBmdW5jdGlvbiBjcmVhdGVUUlBDQ2xpZW50KG9wdHMpIHtcbiAgICBjb25zdCBjbGllbnQgPSBuZXcgVFJQQ1VudHlwZWRDbGllbnQob3B0cyk7XG4gICAgcmV0dXJuIGNsaWVudDtcbn1cblxuY29uc3QgY2xpZW50Q2FsbFR5cGVNYXAgPSB7XG4gICAgcXVlcnk6ICdxdWVyeScsXG4gICAgbXV0YXRlOiAnbXV0YXRpb24nLFxuICAgIHN1YnNjcmliZTogJ3N1YnNjcmlwdGlvbidcbn07XG4vKiogQGludGVybmFsICovIGNvbnN0IGNsaWVudENhbGxUeXBlVG9Qcm9jZWR1cmVUeXBlID0gKGNsaWVudENhbGxUeXBlKT0+e1xuICAgIHJldHVybiBjbGllbnRDYWxsVHlwZU1hcFtjbGllbnRDYWxsVHlwZV07XG59O1xuLyoqXG4gKiBAZGVwcmVjYXRlZCB1c2UgYGNyZWF0ZVRSUENQcm94eUNsaWVudGAgaW5zdGVhZFxuICogQGludGVybmFsXG4gKi8gZnVuY3Rpb24gY3JlYXRlVFJQQ0NsaWVudFByb3h5KGNsaWVudCkge1xuICAgIHJldHVybiBzaGFyZWQuY3JlYXRlRmxhdFByb3h5KChrZXkpPT57XG4gICAgICAgIGlmIChjbGllbnQuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuIGNsaWVudFtrZXldO1xuICAgICAgICB9XG4gICAgICAgIGlmIChrZXkgPT09ICdfX3VudHlwZWRDbGllbnQnKSB7XG4gICAgICAgICAgICByZXR1cm4gY2xpZW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzaGFyZWQuY3JlYXRlUmVjdXJzaXZlUHJveHkoKHsgcGF0aCAsIGFyZ3MgIH0pPT57XG4gICAgICAgICAgICBjb25zdCBwYXRoQ29weSA9IFtcbiAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgLi4ucGF0aFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGNvbnN0IHByb2NlZHVyZVR5cGUgPSBjbGllbnRDYWxsVHlwZVRvUHJvY2VkdXJlVHlwZShwYXRoQ29weS5wb3AoKSk7XG4gICAgICAgICAgICBjb25zdCBmdWxsUGF0aCA9IHBhdGhDb3B5LmpvaW4oJy4nKTtcbiAgICAgICAgICAgIHJldHVybiBjbGllbnRbcHJvY2VkdXJlVHlwZV0oZnVsbFBhdGgsIC4uLmFyZ3MpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVRSUENQcm94eUNsaWVudChvcHRzKSB7XG4gICAgY29uc3QgY2xpZW50ID0gbmV3IFRSUENVbnR5cGVkQ2xpZW50KG9wdHMpO1xuICAgIGNvbnN0IHByb3h5ID0gY3JlYXRlVFJQQ0NsaWVudFByb3h5KGNsaWVudCk7XG4gICAgcmV0dXJuIHByb3h5O1xufVxuLyoqXG4gKiBHZXQgYW4gdW50eXBlZCBjbGllbnQgZnJvbSBhIHByb3h5IGNsaWVudFxuICogQGludGVybmFsXG4gKi8gZnVuY3Rpb24gZ2V0VW50eXBlZENsaWVudChjbGllbnQpIHtcbiAgICByZXR1cm4gY2xpZW50Ll9fdW50eXBlZENsaWVudDtcbn1cblxuZnVuY3Rpb24gZ2V0VGV4dERlY29kZXIoY3VzdG9tVGV4dERlY29kZXIpIHtcbiAgICBpZiAoY3VzdG9tVGV4dERlY29kZXIpIHtcbiAgICAgICAgcmV0dXJuIGN1c3RvbVRleHREZWNvZGVyO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3ByZWZlci1vcHRpb25hbC1jaGFpblxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuVGV4dERlY29kZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyB3aW5kb3cuVGV4dERlY29kZXIoKTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9wcmVmZXItb3B0aW9uYWwtY2hhaW5cbiAgICBpZiAodHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnICYmIGdsb2JhbFRoaXMuVGV4dERlY29kZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBnbG9iYWxUaGlzLlRleHREZWNvZGVyKCk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignTm8gVGV4dERlY29kZXIgaW1wbGVtZW50YXRpb24gZm91bmQnKTtcbn1cblxuLy8gU3RyZWFtIHBhcnNpbmcgYWRhcHRlZCBmcm9tIGh0dHBzOi8vd3d3LmxvZ2lucmFkaXVzLmNvbS9ibG9nL2VuZ2luZWVyaW5nL2d1ZXN0LXBvc3QvaHR0cC1zdHJlYW1pbmctd2l0aC1ub2RlanMtYW5kLWZldGNoLWFwaS9cbi8qKlxuICogQGludGVybmFsXG4gKiBAZGVzY3JpcHRpb24gVGFrZSBhIHN0cmVhbSBvZiBieXRlcyBhbmQgY2FsbCBgb25MaW5lYCB3aXRoXG4gKiBhIEpTT04gb2JqZWN0IGZvciBlYWNoIGxpbmUgaW4gdGhlIHN0cmVhbS4gRXhwZWN0ZWQgc3RyZWFtXG4gKiBmb3JtYXQgaXM6XG4gKiBgYGBqc29uXG4gKiB7XCIxXCI6IHsuLi59XG4gKiAsXCIwXCI6IHsuLi59XG4gKiB9XG4gKiBgYGBcbiAqLyBhc3luYyBmdW5jdGlvbiBwYXJzZUpTT05TdHJlYW0ob3B0cykge1xuICAgIGNvbnN0IHBhcnNlID0gb3B0cy5wYXJzZSA/PyBKU09OLnBhcnNlO1xuICAgIGNvbnN0IG9uTGluZSA9IChsaW5lKT0+e1xuICAgICAgICBpZiAob3B0cy5zaWduYWw/LmFib3J0ZWQpIHJldHVybjtcbiAgICAgICAgaWYgKCFsaW5lIHx8IGxpbmUgPT09ICd9Jykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAqIEF0IHRoaXMgcG9pbnQsIGBsaW5lYCBjYW4gYmUgb25lIG9mIHR3byB0aGluZ3M6XG4gICAgICogLSBUaGUgZmlyc3QgbGluZSBvZiB0aGUgc3RyZWFtIGB7XCIyXCI6ey4uLn1gXG4gICAgICogLSBBIGxpbmUgaW4gdGhlIG1pZGRsZSBvZiB0aGUgc3RyZWFtIGAsXCIyXCI6ey4uLn1gXG4gICAgICovIGNvbnN0IGluZGV4T2ZDb2xvbiA9IGxpbmUuaW5kZXhPZignOicpO1xuICAgICAgICBjb25zdCBpbmRleEFzU3RyID0gbGluZS5zdWJzdHJpbmcoMiwgaW5kZXhPZkNvbG9uIC0gMSk7XG4gICAgICAgIGNvbnN0IHRleHQgPSBsaW5lLnN1YnN0cmluZyhpbmRleE9mQ29sb24gKyAxKTtcbiAgICAgICAgb3B0cy5vblNpbmdsZShOdW1iZXIoaW5kZXhBc1N0ciksIHBhcnNlKHRleHQpKTtcbiAgICB9O1xuICAgIGF3YWl0IHJlYWRMaW5lcyhvcHRzLnJlYWRhYmxlU3RyZWFtLCBvbkxpbmUsIG9wdHMudGV4dERlY29kZXIpO1xufVxuLyoqXG4gKiBIYW5kbGUgdHJhbnNmb3JtaW5nIGEgc3RyZWFtIG9mIGJ5dGVzIGludG8gbGluZXMgb2YgdGV4dC5cbiAqIFRvIGF2b2lkIHVzaW5nIEFzeW5jSXRlcmF0b3JzIC8gQXN5bmNHZW5lcmF0b3JzLFxuICogd2UgdXNlIGEgY2FsbGJhY2sgZm9yIGVhY2ggbGluZS5cbiAqXG4gKiBAcGFyYW0gcmVhZGFibGVTdHJlYW0gY2FuIGJlIGEgTm9kZUpTIHN0cmVhbSBvciBhIFdlYkFQSSBzdHJlYW1cbiAqIEBwYXJhbSBvbkxpbmUgd2lsbCBiZSBjYWxsZWQgZm9yIGV2ZXJ5IGxpbmUgKCdcXG4nIGRlbGltaXRlZCkgaW4gdGhlIHN0cmVhbVxuICovIGFzeW5jIGZ1bmN0aW9uIHJlYWRMaW5lcyhyZWFkYWJsZVN0cmVhbSwgb25MaW5lLCB0ZXh0RGVjb2Rlcikge1xuICAgIGxldCBwYXJ0T2ZMaW5lID0gJyc7XG4gICAgY29uc3Qgb25DaHVuayA9IChjaHVuayk9PntcbiAgICAgICAgY29uc3QgY2h1bmtUZXh0ID0gdGV4dERlY29kZXIuZGVjb2RlKGNodW5rKTtcbiAgICAgICAgY29uc3QgY2h1bmtMaW5lcyA9IGNodW5rVGV4dC5zcGxpdCgnXFxuJyk7XG4gICAgICAgIGlmIChjaHVua0xpbmVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcGFydE9mTGluZSArPSBjaHVua0xpbmVzWzBdO1xuICAgICAgICB9IGVsc2UgaWYgKGNodW5rTGluZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb24gLS0gbGVuZ3RoIGNoZWNrZWQgb24gbGluZSBhYm92ZVxuICAgICAgICAgICAgb25MaW5lKHBhcnRPZkxpbmUgKyBjaHVua0xpbmVzWzBdKTtcbiAgICAgICAgICAgIGZvcihsZXQgaSA9IDE7IGkgPCBjaHVua0xpbmVzLmxlbmd0aCAtIDE7IGkrKyl7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb24gLS0gbGVuZ3RoIGNoZWNrZWQgb24gbGluZSBhYm92ZVxuICAgICAgICAgICAgICAgIG9uTGluZShjaHVua0xpbmVzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uIC0tIGxlbmd0aCBkb2Vzbid0IGNoYW5nZSwgc28gaXMgbmVjZXNzYXJpbHkgPiAxXG4gICAgICAgICAgICBwYXJ0T2ZMaW5lID0gY2h1bmtMaW5lc1tjaHVua0xpbmVzLmxlbmd0aCAtIDFdO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyB3ZSBoYW5kbGUgMiBkaWZmZXJlbnQgdHlwZXMgb2Ygc3RyZWFtcywgdGhpcyBpZiB3aGVyZSB3ZSBmaWd1cmUgb3V0IHdoaWNoIG9uZSB3ZSBoYXZlXG4gICAgaWYgKCdnZXRSZWFkZXInIGluIHJlYWRhYmxlU3RyZWFtKSB7XG4gICAgICAgIGF3YWl0IHJlYWRTdGFuZGFyZENodW5rcyhyZWFkYWJsZVN0cmVhbSwgb25DaHVuayk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYXdhaXQgcmVhZE5vZGVDaHVua3MocmVhZGFibGVTdHJlYW0sIG9uQ2h1bmspO1xuICAgIH1cbiAgICBvbkxpbmUocGFydE9mTGluZSk7XG59XG4vKipcbiAqIEhhbmRsZSBOb2RlSlMgc3RyZWFtXG4gKi8gZnVuY3Rpb24gcmVhZE5vZGVDaHVua3Moc3RyZWFtLCBvbkNodW5rKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKT0+e1xuICAgICAgICBzdHJlYW0ub24oJ2RhdGEnLCBvbkNodW5rKTtcbiAgICAgICAgc3RyZWFtLm9uKCdlbmQnLCByZXNvbHZlKTtcbiAgICB9KTtcbn1cbi8qKlxuICogSGFuZGxlIFdlYkFQSSBzdHJlYW1cbiAqLyBhc3luYyBmdW5jdGlvbiByZWFkU3RhbmRhcmRDaHVua3Moc3RyZWFtLCBvbkNodW5rKSB7XG4gICAgY29uc3QgcmVhZGVyID0gc3RyZWFtLmdldFJlYWRlcigpO1xuICAgIGxldCByZWFkUmVzdWx0ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICB3aGlsZSghcmVhZFJlc3VsdC5kb25lKXtcbiAgICAgICAgb25DaHVuayhyZWFkUmVzdWx0LnZhbHVlKTtcbiAgICAgICAgcmVhZFJlc3VsdCA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgfVxufVxuY29uc3Qgc3RyZWFtaW5nSnNvbkh0dHBSZXF1ZXN0ZXIgPSAob3B0cywgb25TaW5nbGUpPT57XG4gICAgY29uc3QgYWMgPSBvcHRzLkFib3J0Q29udHJvbGxlciA/IG5ldyBvcHRzLkFib3J0Q29udHJvbGxlcigpIDogbnVsbDtcbiAgICBjb25zdCByZXNwb25zZVByb21pc2UgPSBodHRwVXRpbHMuZmV0Y2hIVFRQUmVzcG9uc2Uoe1xuICAgICAgICAuLi5vcHRzLFxuICAgICAgICBjb250ZW50VHlwZUhlYWRlcjogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICBiYXRjaE1vZGVIZWFkZXI6ICdzdHJlYW0nLFxuICAgICAgICBnZXRVcmw6IGh0dHBVdGlscy5nZXRVcmwsXG4gICAgICAgIGdldEJvZHk6IGh0dHBVdGlscy5nZXRCb2R5XG4gICAgfSwgYWMpO1xuICAgIGNvbnN0IGNhbmNlbCA9ICgpPT5hYz8uYWJvcnQoKTtcbiAgICBjb25zdCBwcm9taXNlID0gcmVzcG9uc2VQcm9taXNlLnRoZW4oYXN5bmMgKHJlcyk9PntcbiAgICAgICAgaWYgKCFyZXMuYm9keSkgdGhyb3cgbmV3IEVycm9yKCdSZWNlaXZlZCByZXNwb25zZSB3aXRob3V0IGJvZHknKTtcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIHJlc3BvbnNlOiByZXNcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHBhcnNlSlNPTlN0cmVhbSh7XG4gICAgICAgICAgICByZWFkYWJsZVN0cmVhbTogcmVzLmJvZHksXG4gICAgICAgICAgICBvblNpbmdsZSxcbiAgICAgICAgICAgIHBhcnNlOiAoc3RyaW5nKT0+KHtcbiAgICAgICAgICAgICAgICAgICAganNvbjogSlNPTi5wYXJzZShzdHJpbmcpLFxuICAgICAgICAgICAgICAgICAgICBtZXRhXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBzaWduYWw6IGFjPy5zaWduYWwsXG4gICAgICAgICAgICB0ZXh0RGVjb2Rlcjogb3B0cy50ZXh0RGVjb2RlclxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBjYW5jZWwsXG4gICAgICAgIHByb21pc2VcbiAgICB9O1xufTtcblxuY29uc3Qgc3RyZWFtUmVxdWVzdGVyID0gKHJlcXVlc3Rlck9wdHMpPT57XG4gICAgY29uc3QgdGV4dERlY29kZXIgPSBnZXRUZXh0RGVjb2RlcihyZXF1ZXN0ZXJPcHRzLm9wdHMudGV4dERlY29kZXIpO1xuICAgIHJldHVybiAoYmF0Y2hPcHMsIHVuaXRSZXNvbHZlcik9PntcbiAgICAgICAgY29uc3QgcGF0aCA9IGJhdGNoT3BzLm1hcCgob3ApPT5vcC5wYXRoKS5qb2luKCcsJyk7XG4gICAgICAgIGNvbnN0IGlucHV0cyA9IGJhdGNoT3BzLm1hcCgob3ApPT5vcC5pbnB1dCk7XG4gICAgICAgIGNvbnN0IHsgY2FuY2VsICwgcHJvbWlzZSAgfSA9IHN0cmVhbWluZ0pzb25IdHRwUmVxdWVzdGVyKHtcbiAgICAgICAgICAgIC4uLnJlcXVlc3Rlck9wdHMsXG4gICAgICAgICAgICB0ZXh0RGVjb2RlcixcbiAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICBpbnB1dHMsXG4gICAgICAgICAgICBoZWFkZXJzICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXJlcXVlc3Rlck9wdHMub3B0cy5oZWFkZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZXF1ZXN0ZXJPcHRzLm9wdHMuaGVhZGVycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVxdWVzdGVyT3B0cy5vcHRzLmhlYWRlcnMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BMaXN0OiBiYXRjaE9wc1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3Rlck9wdHMub3B0cy5oZWFkZXJzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCAoaW5kZXgsIHJlcyk9PntcbiAgICAgICAgICAgIHVuaXRSZXNvbHZlcihpbmRleCwgcmVzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAqIHJldHVybiBhbiBlbXB0eSBhcnJheSBiZWNhdXNlIHRoZSBiYXRjaExvYWRlciBleHBlY3RzIGFuIGFycmF5IG9mIHJlc3VsdHNcbiAgICAgICAqIGJ1dCB3ZSd2ZSBhbHJlYWR5IGNhbGxlZCB0aGUgYHVuaXRSZXNvbHZlcmAgZm9yIGVhY2ggb2YgdGhlbSwgdGhlcmUnc1xuICAgICAgICogbm90aGluZyBsZWZ0IHRvIGRvIGhlcmUuXG4gICAgICAgKi8gcHJvbWlzZTogcHJvbWlzZS50aGVuKCgpPT5bXSksXG4gICAgICAgICAgICBjYW5jZWxcbiAgICAgICAgfTtcbiAgICB9O1xufTtcbmNvbnN0IHVuc3RhYmxlX2h0dHBCYXRjaFN0cmVhbUxpbmsgPSBsaW5rc19odHRwQmF0Y2hMaW5rLmNyZWF0ZUhUVFBCYXRjaExpbmsoc3RyZWFtUmVxdWVzdGVyKTtcblxuY29uc3QgZ2V0Qm9keSA9IChvcHRzKT0+e1xuICAgIGlmICghKCdpbnB1dCcgaW4gb3B0cykpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKCEob3B0cy5pbnB1dCBpbnN0YW5jZW9mIEZvcm1EYXRhKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IGlzIG5vdCBGb3JtRGF0YScpO1xuICAgIH1cbiAgICByZXR1cm4gb3B0cy5pbnB1dDtcbn07XG5jb25zdCBmb3JtRGF0YVJlcXVlc3RlciA9IChvcHRzKT0+e1xuICAgIGlmIChvcHRzLnR5cGUgIT09ICdtdXRhdGlvbicpIHtcbiAgICAgICAgLy8gVE9ETyg/KSBoYW5kbGUgZm9ybWRhdGEgcXVlcmllc1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlIG9ubHkgaGFuZGxlIG11dGF0aW9ucyB3aXRoIGZvcm1kYXRhJyk7XG4gICAgfVxuICAgIHJldHVybiBodHRwVXRpbHMuaHR0cFJlcXVlc3Qoe1xuICAgICAgICAuLi5vcHRzLFxuICAgICAgICBnZXRVcmwgKCkge1xuICAgICAgICAgICAgcmV0dXJuIGAke29wdHMudXJsfS8ke29wdHMucGF0aH1gO1xuICAgICAgICB9LFxuICAgICAgICBnZXRCb2R5XG4gICAgfSk7XG59O1xuY29uc3QgZXhwZXJpbWVudGFsX2Zvcm1EYXRhTGluayA9IGxpbmtzX2h0dHBMaW5rLmh0dHBMaW5rRmFjdG9yeSh7XG4gICAgcmVxdWVzdGVyOiBmb3JtRGF0YVJlcXVlc3RlclxufSk7XG5cbmV4cG9ydHMuc3BsaXRMaW5rID0gbGlua3Nfc3BsaXRMaW5rLnNwbGl0TGluaztcbmV4cG9ydHMuVFJQQ0NsaWVudEVycm9yID0gVFJQQ0NsaWVudEVycm9yLlRSUENDbGllbnRFcnJvcjtcbmV4cG9ydHMuZ2V0RmV0Y2ggPSBodHRwVXRpbHMuZ2V0RmV0Y2g7XG5leHBvcnRzLmh0dHBCYXRjaExpbmsgPSBsaW5rc19odHRwQmF0Y2hMaW5rLmh0dHBCYXRjaExpbms7XG5leHBvcnRzLmh0dHBMaW5rID0gbGlua3NfaHR0cExpbmsuaHR0cExpbms7XG5leHBvcnRzLmh0dHBMaW5rRmFjdG9yeSA9IGxpbmtzX2h0dHBMaW5rLmh0dHBMaW5rRmFjdG9yeTtcbmV4cG9ydHMubG9nZ2VyTGluayA9IGxpbmtzX2xvZ2dlckxpbmsubG9nZ2VyTGluaztcbmV4cG9ydHMuY3JlYXRlV1NDbGllbnQgPSBsaW5rc193c0xpbmsuY3JlYXRlV1NDbGllbnQ7XG5leHBvcnRzLndzTGluayA9IGxpbmtzX3dzTGluay53c0xpbms7XG5leHBvcnRzLlRSUENVbnR5cGVkQ2xpZW50ID0gVFJQQ1VudHlwZWRDbGllbnQ7XG5leHBvcnRzLmNsaWVudENhbGxUeXBlVG9Qcm9jZWR1cmVUeXBlID0gY2xpZW50Q2FsbFR5cGVUb1Byb2NlZHVyZVR5cGU7XG5leHBvcnRzLmNyZWF0ZVRSUENDbGllbnQgPSBjcmVhdGVUUlBDQ2xpZW50O1xuZXhwb3J0cy5jcmVhdGVUUlBDQ2xpZW50UHJveHkgPSBjcmVhdGVUUlBDQ2xpZW50UHJveHk7XG5leHBvcnRzLmNyZWF0ZVRSUENQcm94eUNsaWVudCA9IGNyZWF0ZVRSUENQcm94eUNsaWVudDtcbmV4cG9ydHMuY3JlYXRlVFJQQ1VudHlwZWRDbGllbnQgPSBjcmVhdGVUUlBDVW50eXBlZENsaWVudDtcbmV4cG9ydHMuZXhwZXJpbWVudGFsX2Zvcm1EYXRhTGluayA9IGV4cGVyaW1lbnRhbF9mb3JtRGF0YUxpbms7XG5leHBvcnRzLmdldFVudHlwZWRDbGllbnQgPSBnZXRVbnR5cGVkQ2xpZW50O1xuZXhwb3J0cy51bnN0YWJsZV9odHRwQmF0Y2hTdHJlYW1MaW5rID0gdW5zdGFibGVfaHR0cEJhdGNoU3RyZWFtTGluaztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jcmVhdGVCYXNlTGluayA9IHZvaWQgMDtcbmNvbnN0IGNsaWVudF8xID0gcmVxdWlyZShcIkB0cnBjL2NsaWVudFwiKTtcbmNvbnN0IG9ic2VydmFibGVfMSA9IHJlcXVpcmUoXCJAdHJwYy9zZXJ2ZXIvb2JzZXJ2YWJsZVwiKTtcbmNvbnN0IHRycGNNZXNzYWdlXzEgPSByZXF1aXJlKFwiLi4vLi4vc2hhcmVkL3RycGNNZXNzYWdlXCIpO1xuY29uc3QgY3JlYXRlQmFzZUxpbmsgPSAobWV0aG9kcykgPT4ge1xuICAgIHJldHVybiAocnVudGltZSkgPT4ge1xuICAgICAgICByZXR1cm4gKHsgb3AgfSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuICgwLCBvYnNlcnZhYmxlXzEub2JzZXJ2YWJsZSkoKG9ic2VydmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gW107XG4gICAgICAgICAgICAgICAgY29uc3QgeyBpZCwgdHlwZSwgcGF0aCB9ID0gb3A7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbnB1dCA9IHJ1bnRpbWUudHJhbnNmb3JtZXIuc2VyaWFsaXplKG9wLmlucHV0KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb25EaXNjb25uZWN0ID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIuZXJyb3IobmV3IGNsaWVudF8xLlRSUENDbGllbnRFcnJvcignUG9ydCBkaXNjb25uZWN0ZWQgcHJlbWF0dXJlbHknKSk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZHMuYWRkQ2xvc2VMaXN0ZW5lcihvbkRpc2Nvbm5lY3QpO1xuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnMucHVzaCgoKSA9PiBtZXRob2RzLnJlbW92ZUNsb3NlTGlzdGVuZXIob25EaXNjb25uZWN0KSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9uTWVzc2FnZSA9IChtZXNzYWdlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoISgwLCB0cnBjTWVzc2FnZV8xLmlzVFJQQ1Jlc3BvbnNlKShtZXNzYWdlKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHRycGMgfSA9IG1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaWQgIT09IHRycGMuaWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCdlcnJvcicgaW4gdHJwYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvYnNlcnZlci5lcnJvcihjbGllbnRfMS5UUlBDQ2xpZW50RXJyb3IuZnJvbSh0cnBjKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5uZXh0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdHJwYy5yZXN1bHQpLCAoKCF0cnBjLnJlc3VsdC50eXBlIHx8IHRycGMucmVzdWx0LnR5cGUgPT09ICdkYXRhJykgJiYge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZGF0YScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogcnVudGltZS50cmFuc2Zvcm1lci5kZXNlcmlhbGl6ZSh0cnBjLnJlc3VsdC5kYXRhKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSksXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlICE9PSAnc3Vic2NyaXB0aW9uJyB8fCB0cnBjLnJlc3VsdC50eXBlID09PSAnc3RvcHBlZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBtZXRob2RzLmFkZE1lc3NhZ2VMaXN0ZW5lcihvbk1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnMucHVzaCgoKSA9PiBtZXRob2RzLnJlbW92ZU1lc3NhZ2VMaXN0ZW5lcihvbk1lc3NhZ2UpKTtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kcy5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnBjOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAganNvbnJwYzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiB7IHBhdGgsIGlucHV0IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGNhdXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLmVycm9yKG5ldyBjbGllbnRfMS5UUlBDQ2xpZW50RXJyb3IoY2F1c2UgaW5zdGFuY2VvZiBFcnJvciA/IGNhdXNlLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcicpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdzdWJzY3JpcHRpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRob2RzLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnBjOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc29ucnBjOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ3N1YnNjcmlwdGlvbi5zdG9wJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzLmZvckVhY2goKHVuc3ViKSA9PiB1bnN1YigpKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgfTtcbn07XG5leHBvcnRzLmNyZWF0ZUJhc2VMaW5rID0gY3JlYXRlQmFzZUxpbms7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYXNlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jaHJvbWVMaW5rID0gdm9pZCAwO1xuY29uc3QgYmFzZV8xID0gcmVxdWlyZShcIi4vaW50ZXJuYWwvYmFzZVwiKTtcbmNvbnN0IGNocm9tZUxpbmsgPSAob3B0cykgPT4ge1xuICAgIHJldHVybiAoMCwgYmFzZV8xLmNyZWF0ZUJhc2VMaW5rKSh7XG4gICAgICAgIHBvc3RNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIG9wdHMucG9ydC5wb3N0TWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgfSxcbiAgICAgICAgYWRkTWVzc2FnZUxpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBvcHRzLnBvcnQub25NZXNzYWdlLmFkZExpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVtb3ZlTWVzc2FnZUxpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBvcHRzLnBvcnQub25NZXNzYWdlLnJlbW92ZUxpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICAgICAgfSxcbiAgICAgICAgYWRkQ2xvc2VMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgICAgICAgICAgb3B0cy5wb3J0Lm9uRGlzY29ubmVjdC5hZGRMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZUNsb3NlTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgICAgICAgICAgIG9wdHMucG9ydC5vbkRpc2Nvbm5lY3QucmVtb3ZlTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgICAgICB9LFxuICAgIH0pO1xufTtcbmV4cG9ydHMuY2hyb21lTGluayA9IGNocm9tZUxpbms7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaHJvbWUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLndpbmRvd0xpbmsgPSB2b2lkIDA7XG5jb25zdCBiYXNlXzEgPSByZXF1aXJlKFwiLi9pbnRlcm5hbC9iYXNlXCIpO1xuY29uc3Qgd2luZG93TGluayA9IChvcHRzKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGhhbmRsZXJNYXAgPSBuZXcgTWFwKCk7XG4gICAgY29uc3QgbGlzdGVuV2luZG93ID0gb3B0cy53aW5kb3c7XG4gICAgY29uc3QgcG9zdFdpbmRvdyA9IChfYSA9IG9wdHMucG9zdFdpbmRvdykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbGlzdGVuV2luZG93O1xuICAgIGNvbnN0IHNhZmVFdmVudExpc3RlbmVyID0gKGFjdGlvbiwgZXZlbnQsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxpc3RlbldpbmRvd1tgJHthY3Rpb259RXZlbnRMaXN0ZW5lcmBdKGV2ZW50LCBoYW5kbGVyKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBGYWlsZWQgdG8gJHthY3Rpb259ICR7ZXZlbnR9IGxpc3RlbmVyOmAsIGVycik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiAoMCwgYmFzZV8xLmNyZWF0ZUJhc2VMaW5rKSh7XG4gICAgICAgIHBvc3RNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHBvc3RXaW5kb3cucG9zdE1lc3NhZ2UobWVzc2FnZSwge1xuICAgICAgICAgICAgICAgIHRhcmdldE9yaWdpbjogb3B0cy5wb3N0T3JpZ2luLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGFkZE1lc3NhZ2VMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlciA9IChldikgPT4ge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyKGV2LmRhdGEpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGhhbmRsZXJNYXAuc2V0KGxpc3RlbmVyLCBoYW5kbGVyKTtcbiAgICAgICAgICAgIHNhZmVFdmVudExpc3RlbmVyKCdhZGQnLCAnbWVzc2FnZScsIGhhbmRsZXIpO1xuICAgICAgICB9LFxuICAgICAgICByZW1vdmVNZXNzYWdlTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZXIgPSBoYW5kbGVyTWFwLmdldChsaXN0ZW5lcik7XG4gICAgICAgICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICAgICAgICAgIHNhZmVFdmVudExpc3RlbmVyKCdyZW1vdmUnLCAnbWVzc2FnZScsIGhhbmRsZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBhZGRDbG9zZUxpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBzYWZlRXZlbnRMaXN0ZW5lcignYWRkJywgJ2JlZm9yZXVubG9hZCcsIGxpc3RlbmVyKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVtb3ZlQ2xvc2VMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgICAgICAgICAgc2FmZUV2ZW50TGlzdGVuZXIoJ3JlbW92ZScsICdiZWZvcmV1bmxvYWQnLCBsaXN0ZW5lcik7XG4gICAgICAgIH0sXG4gICAgfSk7XG59O1xuZXhwb3J0cy53aW5kb3dMaW5rID0gd2luZG93TGluaztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdpbmRvdy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucG9wdXBMaW5rID0gdm9pZCAwO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2NvbnN0YW50c1wiKTtcbmNvbnN0IGJhc2VfMSA9IHJlcXVpcmUoXCIuL2ludGVybmFsL2Jhc2VcIik7XG5jb25zdCBwb3B1cExpbmsgPSAob3B0cykgPT4ge1xuICAgIGNvbnN0IG1lc3NhZ2VIYW5kbGVyTWFwID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IGNsb3NlSGFuZGxlclNldCA9IG5ldyBTZXQoKTtcbiAgICBsZXQgcG9wdXBXaW5kb3cgPSBudWxsO1xuICAgIGFzeW5jIGZ1bmN0aW9uIGdldFBvcHVwKGxvYWRMaXN0ZW5XaW5kb3cpIHtcbiAgICAgICAgaWYgKCFwb3B1cFdpbmRvdyB8fCBwb3B1cFdpbmRvdy5jbG9zZWQpIHtcbiAgICAgICAgICAgIHBvcHVwV2luZG93ID0gb3B0cy5jcmVhdGVQb3B1cCgpO1xuICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5yYWNlKFtcbiAgICAgICAgICAgICAgICAvLyB3YWl0IHRpbCB3aW5kb3cgaXMgbG9hZGVkIChzYW1lIG9yaWdpbilcbiAgICAgICAgICAgICAgICBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAoX2EgPSBwb3B1cFdpbmRvdyA9PT0gbnVsbCB8fCBwb3B1cFdpbmRvdyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcG9wdXBXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwocG9wdXBXaW5kb3csICdsb2FkJywgcmVzb2x2ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKF9iKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGlzIHRocm93cywgaXQncyBhIGNyb3NzLW9yaWdpbiBwb3B1cCBhbmQgc2hvdWxkIHN0YXkgcGVuZGluZyAobmV2ZXIgcmVzb2x2ZSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgbmVlZGVkIGZvciBjcm9zcy1vcmlnaW4gcG9wdXBzIGFzIHRoZXkgZG9uJ3QgaGF2ZSBhIGxvYWQgZXZlbnRcbiAgICAgICAgICAgICAgICBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsb2FkTGlzdGVuV2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChldmVudC5kYXRhID09PSBjb25zdGFudHNfMS5UUlBDX0JST1dTRVJfTE9BREVEX0VWRU5UKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAvLyBleHBlY3QgdGhlIHBvcHVwIHRvIGxvYWQgYWZ0ZXIgMTVzIG1heCwgaW4gY2FzZSBub24gb2YgdGhlIGFib3ZlIGV2ZW50cyBmaXJlXG4gICAgICAgICAgICAgICAgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdDb3VsZCBub3QgZGV0ZWN0IGlmIHBvcHVwIGxvYWRpbmcgc3VjY2VlZGVkIGFmdGVyIDE1cyB0aW1lb3V0LCBjb250aW51aW5nIGFueXdheScpO1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KHJlc29sdmUsIDE1MDAwKTtcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgLy8gc3Vic2NyaWJlIHRvIHBvcHVwIGNsb3NpbmdcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKCFwb3B1cFdpbmRvdy5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncG9wdXBXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lciBpcyBub3QgYSBmdW5jdGlvbicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwb3B1cFdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdiZWZvcmV1bmxvYWQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHBvcHVwV2luZG93ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChfYSkge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgdGhyb3dzIG9uIGNyb3NzLW9yaWdpbiBwb3B1cHMsIGZhbGxiYWNrIHRvIHBvbGxpbmcgdG8gY2hlY2sgaWYgcG9wdXAgaXMgY2xvc2VkXG4gICAgICAgICAgICAgICAgY29uc3QgcGlkID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9wdXBXaW5kb3cgJiYgcG9wdXBXaW5kb3cuY2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3B1cFdpbmRvdyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbG9zZUhhbmRsZXJTZXQuZm9yRWFjaCgoaGFuZGxlcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChwaWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgMTAwMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBvcHVwV2luZG93O1xuICAgIH1cbiAgICByZXR1cm4gKDAsIGJhc2VfMS5jcmVhdGVCYXNlTGluaykoe1xuICAgICAgICBhc3luYyBwb3N0TWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgICAgICBjb25zdCBwb3B1cCA9IGF3YWl0IGdldFBvcHVwKG9wdHMubGlzdGVuV2luZG93KTtcbiAgICAgICAgICAgIHJldHVybiBwb3B1cC5wb3N0TWVzc2FnZShtZXNzYWdlLCB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0T3JpZ2luOiBvcHRzLnBvc3RPcmlnaW4sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgYWRkTWVzc2FnZUxpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBjb25zdCBoYW5kbGVyID0gKGV2KSA9PiB7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXIoZXYuZGF0YSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbWVzc2FnZUhhbmRsZXJNYXAuc2V0KGxpc3RlbmVyLCBoYW5kbGVyKTtcbiAgICAgICAgICAgIG9wdHMubGlzdGVuV2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBoYW5kbGVyKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVtb3ZlTWVzc2FnZUxpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBjb25zdCBoYW5kbGVyID0gbWVzc2FnZUhhbmRsZXJNYXAuZ2V0KGxpc3RlbmVyKTtcbiAgICAgICAgICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgb3B0cy5saXN0ZW5XaW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGhhbmRsZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBhZGRDbG9zZUxpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBvcHRzLmxpc3RlbldpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdiZWZvcmV1bmxvYWQnLCBsaXN0ZW5lcik7XG4gICAgICAgICAgICBjbG9zZUhhbmRsZXJTZXQuYWRkKGxpc3RlbmVyKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVtb3ZlQ2xvc2VMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgICAgICAgICAgb3B0cy5saXN0ZW5XaW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignYmVmb3JldW5sb2FkJywgbGlzdGVuZXIpO1xuICAgICAgICAgICAgY2xvc2VIYW5kbGVyU2V0LmRlbGV0ZShsaXN0ZW5lcik7XG4gICAgICAgIH0sXG4gICAgfSk7XG59O1xuZXhwb3J0cy5wb3B1cExpbmsgPSBwb3B1cExpbms7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wb3B1cC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2Nocm9tZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vd2luZG93XCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9wb3B1cFwiKSwgZXhwb3J0cyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJmdW5jdGlvbiBpZGVudGl0eSh4KSB7XG4gICAgcmV0dXJuIHg7XG59XG5cbi8qKiBAaW50ZXJuYWwgKi8gZnVuY3Rpb24gcGlwZUZyb21BcnJheShmbnMpIHtcbiAgICBpZiAoZm5zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gaWRlbnRpdHk7XG4gICAgfVxuICAgIGlmIChmbnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgIHJldHVybiBmbnNbMF07XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiBwaXBlZChpbnB1dCkge1xuICAgICAgICByZXR1cm4gZm5zLnJlZHVjZSgocHJldiwgZm4pPT5mbihwcmV2KSwgaW5wdXQpO1xuICAgIH07XG59XG5cbmZ1bmN0aW9uIGlzT2JzZXJ2YWJsZSh4KSB7XG4gICAgcmV0dXJuIHR5cGVvZiB4ID09PSAnb2JqZWN0JyAmJiB4ICE9PSBudWxsICYmICdzdWJzY3JpYmUnIGluIHg7XG59XG5mdW5jdGlvbiBvYnNlcnZhYmxlKHN1YnNjcmliZSkge1xuICAgIGNvbnN0IHNlbGYgPSB7XG4gICAgICAgIHN1YnNjcmliZSAob2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgIGxldCB0ZWFyZG93blJlZiA9IG51bGw7XG4gICAgICAgICAgICBsZXQgaXNEb25lID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgdW5zdWJzY3JpYmVkID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgdGVhcmRvd25JbW1lZGlhdGVseSA9IGZhbHNlO1xuICAgICAgICAgICAgZnVuY3Rpb24gdW5zdWJzY3JpYmUoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRlYXJkb3duUmVmID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRlYXJkb3duSW1tZWRpYXRlbHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh1bnN1YnNjcmliZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB1bnN1YnNjcmliZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGVhcmRvd25SZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgdGVhcmRvd25SZWYoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRlYXJkb3duUmVmKSB7XG4gICAgICAgICAgICAgICAgICAgIHRlYXJkb3duUmVmLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGVhcmRvd25SZWYgPSBzdWJzY3JpYmUoe1xuICAgICAgICAgICAgICAgIG5leHQgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0RvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5uZXh0Py4odmFsdWUpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZXJyb3IgKGVycikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNEb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaXNEb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIuZXJyb3I/LihlcnIpO1xuICAgICAgICAgICAgICAgICAgICB1bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY29tcGxldGUgKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNEb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaXNEb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIuY29tcGxldGU/LigpO1xuICAgICAgICAgICAgICAgICAgICB1bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHRlYXJkb3duSW1tZWRpYXRlbHkpIHtcbiAgICAgICAgICAgICAgICB1bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1bnN1YnNjcmliZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgcGlwZSAoLi4ub3BlcmF0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIHBpcGVGcm9tQXJyYXkob3BlcmF0aW9ucykoc2VsZik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBzZWxmO1xufVxuXG5leHBvcnQgeyBpc09ic2VydmFibGUgYXMgaSwgb2JzZXJ2YWJsZSBhcyBvIH07XG4iLCJleHBvcnQgeyBpIGFzIGlzT2JzZXJ2YWJsZSwgbyBhcyBvYnNlcnZhYmxlIH0gZnJvbSAnLi4vb2JzZXJ2YWJsZS1hZGUxYmFkOC5tanMnO1xuXG5mdW5jdGlvbiBzaGFyZShfb3B0cykge1xuICAgIHJldHVybiAob3JpZ2luYWxPYnNlcnZlcik9PntcbiAgICAgICAgbGV0IHJlZkNvdW50ID0gMDtcbiAgICAgICAgbGV0IHN1YnNjcmlwdGlvbiA9IG51bGw7XG4gICAgICAgIGNvbnN0IG9ic2VydmVycyA9IFtdO1xuICAgICAgICBmdW5jdGlvbiBzdGFydElmTmVlZGVkKCkge1xuICAgICAgICAgICAgaWYgKHN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbiA9IG9yaWdpbmFsT2JzZXJ2ZXIuc3Vic2NyaWJlKHtcbiAgICAgICAgICAgICAgICBuZXh0ICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG9ic2VydmVyIG9mIG9ic2VydmVycyl7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5uZXh0Py4odmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBlcnJvciAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBvYnNlcnZlciBvZiBvYnNlcnZlcnMpe1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIuZXJyb3I/LihlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGNvbXBsZXRlICgpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBvYnNlcnZlciBvZiBvYnNlcnZlcnMpe1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIuY29tcGxldGU/LigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcmVzZXRJZk5lZWRlZCgpIHtcbiAgICAgICAgICAgIC8vIFwicmVzZXRPblJlZkNvdW50WmVyb1wiXG4gICAgICAgICAgICBpZiAocmVmQ291bnQgPT09IDAgJiYgc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgX3N1YiA9IHN1YnNjcmlwdGlvbjtcbiAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb24gPSBudWxsO1xuICAgICAgICAgICAgICAgIF9zdWIudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3Vic2NyaWJlIChvYnNlcnZlcikge1xuICAgICAgICAgICAgICAgIHJlZkNvdW50Kys7XG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXJzLnB1c2gob2JzZXJ2ZXIpO1xuICAgICAgICAgICAgICAgIHN0YXJ0SWZOZWVkZWQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB1bnN1YnNjcmliZSAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWZDb3VudC0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzZXRJZk5lZWRlZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBvYnNlcnZlcnMuZmluZEluZGV4KCh2KT0+diA9PT0gb2JzZXJ2ZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYnNlcnZlcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gbWFwKHByb2plY3QpIHtcbiAgICByZXR1cm4gKG9yaWdpbmFsT2JzZXJ2ZXIpPT57XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdWJzY3JpYmUgKG9ic2VydmVyKSB7XG4gICAgICAgICAgICAgICAgbGV0IGluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBvcmlnaW5hbE9ic2VydmVyLnN1YnNjcmliZSh7XG4gICAgICAgICAgICAgICAgICAgIG5leHQgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5uZXh0Py4ocHJvamVjdCh2YWx1ZSwgaW5kZXgrKykpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBlcnJvciAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLmVycm9yPy4oZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZSAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5jb21wbGV0ZT8uKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3Vic2NyaXB0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG59XG5cbmZ1bmN0aW9uIHRhcChvYnNlcnZlcikge1xuICAgIHJldHVybiAob3JpZ2luYWxPYnNlcnZlcik9PntcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN1YnNjcmliZSAob2JzZXJ2ZXIyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsT2JzZXJ2ZXIuc3Vic2NyaWJlKHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCAodikge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dD8uKHYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIyLm5leHQ/Lih2KTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IgKHYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLmVycm9yPy4odik7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYnNlcnZlcjIuZXJyb3I/Lih2KTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgY29tcGxldGUgKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIuY29tcGxldGU/LigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIyLmNvbXBsZXRlPy4oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG59XG5cbmNsYXNzIE9ic2VydmFibGVBYm9ydEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2Upe1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ09ic2VydmFibGVBYm9ydEVycm9yJztcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIE9ic2VydmFibGVBYm9ydEVycm9yLnByb3RvdHlwZSk7XG4gICAgfVxufVxuLyoqIEBpbnRlcm5hbCAqLyBmdW5jdGlvbiBvYnNlcnZhYmxlVG9Qcm9taXNlKG9ic2VydmFibGUpIHtcbiAgICBsZXQgYWJvcnQ7XG4gICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpPT57XG4gICAgICAgIGxldCBpc0RvbmUgPSBmYWxzZTtcbiAgICAgICAgZnVuY3Rpb24gb25Eb25lKCkge1xuICAgICAgICAgICAgaWYgKGlzRG9uZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlzRG9uZSA9IHRydWU7XG4gICAgICAgICAgICByZWplY3QobmV3IE9ic2VydmFibGVBYm9ydEVycm9yKCdUaGlzIG9wZXJhdGlvbiB3YXMgYWJvcnRlZC4nKSk7XG4gICAgICAgICAgICBvYnMkLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb2JzJCA9IG9ic2VydmFibGUuc3Vic2NyaWJlKHtcbiAgICAgICAgICAgIG5leHQgKGRhdGEpIHtcbiAgICAgICAgICAgICAgICBpc0RvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJlc29sdmUoZGF0YSk7XG4gICAgICAgICAgICAgICAgb25Eb25lKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZXJyb3IgKGRhdGEpIHtcbiAgICAgICAgICAgICAgICBpc0RvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJlamVjdChkYXRhKTtcbiAgICAgICAgICAgICAgICBvbkRvbmUoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb21wbGV0ZSAoKSB7XG4gICAgICAgICAgICAgICAgaXNEb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBvbkRvbmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGFib3J0ID0gb25Eb25lO1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIHByb21pc2UsXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgIGFib3J0OiBhYm9ydFxuICAgIH07XG59XG5cbmV4cG9ydCB7IG1hcCwgb2JzZXJ2YWJsZVRvUHJvbWlzZSwgc2hhcmUsIHRhcCB9O1xuIiwiaW1wb3J0IHsgb2JzZXJ2YWJsZSB9IGZyb20gJ0B0cnBjL3NlcnZlci9vYnNlcnZhYmxlJztcblxuLyoqIEBpbnRlcm5hbCAqLyBmdW5jdGlvbiBjcmVhdGVDaGFpbihvcHRzKSB7XG4gICAgcmV0dXJuIG9ic2VydmFibGUoKG9ic2VydmVyKT0+e1xuICAgICAgICBmdW5jdGlvbiBleGVjdXRlKGluZGV4ID0gMCwgb3AgPSBvcHRzLm9wKSB7XG4gICAgICAgICAgICBjb25zdCBuZXh0ID0gb3B0cy5saW5rc1tpbmRleF07XG4gICAgICAgICAgICBpZiAoIW5leHQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIG1vcmUgbGlua3MgdG8gZXhlY3V0ZSAtIGRpZCB5b3UgZm9yZ2V0IHRvIGFkZCBhbiBlbmRpbmcgbGluaz8nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IG5leHQoe1xuICAgICAgICAgICAgICAgIG9wLFxuICAgICAgICAgICAgICAgIG5leHQgKG5leHRPcCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0T2JzZXJ2ZXIgPSBleGVjdXRlKGluZGV4ICsgMSwgbmV4dE9wKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5leHRPYnNlcnZlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBzdWJzY3JpcHRpb247XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb2JzJCA9IGV4ZWN1dGUoKTtcbiAgICAgICAgcmV0dXJuIG9icyQuc3Vic2NyaWJlKG9ic2VydmVyKTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gYXNBcnJheSh2YWx1ZSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW1xuICAgICAgICB2YWx1ZVxuICAgIF07XG59XG5mdW5jdGlvbiBzcGxpdExpbmsob3B0cykge1xuICAgIHJldHVybiAocnVudGltZSk9PntcbiAgICAgICAgY29uc3QgeWVzID0gYXNBcnJheShvcHRzLnRydWUpLm1hcCgobGluayk9PmxpbmsocnVudGltZSkpO1xuICAgICAgICBjb25zdCBubyA9IGFzQXJyYXkob3B0cy5mYWxzZSkubWFwKChsaW5rKT0+bGluayhydW50aW1lKSk7XG4gICAgICAgIHJldHVybiAocHJvcHMpPT57XG4gICAgICAgICAgICByZXR1cm4gb2JzZXJ2YWJsZSgob2JzZXJ2ZXIpPT57XG4gICAgICAgICAgICAgICAgY29uc3QgbGlua3MgPSBvcHRzLmNvbmRpdGlvbihwcm9wcy5vcCkgPyB5ZXMgOiBubztcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ2hhaW4oe1xuICAgICAgICAgICAgICAgICAgICBvcDogcHJvcHMub3AsXG4gICAgICAgICAgICAgICAgICAgIGxpbmtzXG4gICAgICAgICAgICAgICAgfSkuc3Vic2NyaWJlKG9ic2VydmVyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH07XG59XG5cbmV4cG9ydCB7IGNyZWF0ZUNoYWluIGFzIGMsIHNwbGl0TGluayBhcyBzIH07XG4iLCIvKipcbiAqIEBpbnRlcm5hbFxuICovIGZ1bmN0aW9uIGludmVydChvYmopIHtcbiAgICBjb25zdCBuZXdPYmogPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGZvcihjb25zdCBrZXkgaW4gb2JqKXtcbiAgICAgICAgY29uc3QgdiA9IG9ialtrZXldO1xuICAgICAgICBuZXdPYmpbdl0gPSBrZXk7XG4gICAgfVxuICAgIHJldHVybiBuZXdPYmo7XG59XG5cbi8vIHJlZmVyZW5jZTogaHR0cHM6Ly93d3cuanNvbnJwYy5vcmcvc3BlY2lmaWNhdGlvblxuLyoqXG4gKiBKU09OLVJQQyAyLjAgRXJyb3IgY29kZXNcbiAqXG4gKiBgLTMyMDAwYCB0byBgLTMyMDk5YCBhcmUgcmVzZXJ2ZWQgZm9yIGltcGxlbWVudGF0aW9uLWRlZmluZWQgc2VydmVyLWVycm9ycy5cbiAqIEZvciB0UlBDIHdlJ3JlIGNvcHlpbmcgdGhlIGxhc3QgZGlnaXRzIG9mIEhUVFAgNFhYIGVycm9ycy5cbiAqLyBjb25zdCBUUlBDX0VSUk9SX0NPREVTX0JZX0tFWSA9IHtcbiAgICAvKipcbiAgICogSW52YWxpZCBKU09OIHdhcyByZWNlaXZlZCBieSB0aGUgc2VydmVyLlxuICAgKiBBbiBlcnJvciBvY2N1cnJlZCBvbiB0aGUgc2VydmVyIHdoaWxlIHBhcnNpbmcgdGhlIEpTT04gdGV4dC5cbiAgICovIFBBUlNFX0VSUk9SOiAtMzI3MDAsXG4gICAgLyoqXG4gICAqIFRoZSBKU09OIHNlbnQgaXMgbm90IGEgdmFsaWQgUmVxdWVzdCBvYmplY3QuXG4gICAqLyBCQURfUkVRVUVTVDogLTMyNjAwLFxuICAgIC8vIEludGVybmFsIEpTT04tUlBDIGVycm9yXG4gICAgSU5URVJOQUxfU0VSVkVSX0VSUk9SOiAtMzI2MDMsXG4gICAgTk9UX0lNUExFTUVOVEVEOiAtMzI2MDMsXG4gICAgLy8gSW1wbGVtZW50YXRpb24gc3BlY2lmaWMgZXJyb3JzXG4gICAgVU5BVVRIT1JJWkVEOiAtMzIwMDEsXG4gICAgRk9SQklEREVOOiAtMzIwMDMsXG4gICAgTk9UX0ZPVU5EOiAtMzIwMDQsXG4gICAgTUVUSE9EX05PVF9TVVBQT1JURUQ6IC0zMjAwNSxcbiAgICBUSU1FT1VUOiAtMzIwMDgsXG4gICAgQ09ORkxJQ1Q6IC0zMjAwOSxcbiAgICBQUkVDT05ESVRJT05fRkFJTEVEOiAtMzIwMTIsXG4gICAgUEFZTE9BRF9UT09fTEFSR0U6IC0zMjAxMyxcbiAgICBVTlBST0NFU1NBQkxFX0NPTlRFTlQ6IC0zMjAyMixcbiAgICBUT09fTUFOWV9SRVFVRVNUUzogLTMyMDI5LFxuICAgIENMSUVOVF9DTE9TRURfUkVRVUVTVDogLTMyMDk5XG59O1xuY29uc3QgVFJQQ19FUlJPUl9DT0RFU19CWV9OVU1CRVIgPSBpbnZlcnQoVFJQQ19FUlJPUl9DT0RFU19CWV9LRVkpO1xuXG5leHBvcnQgeyBUUlBDX0VSUk9SX0NPREVTX0JZX0tFWSBhcyBULCBUUlBDX0VSUk9SX0NPREVTX0JZX05VTUJFUiBhcyBhLCBpbnZlcnQgYXMgaSB9O1xuIiwiaW1wb3J0IHsgaSBhcyBpbnZlcnQsIFQgYXMgVFJQQ19FUlJPUl9DT0RFU19CWV9LRVkgfSBmcm9tICcuL2NvZGVzLWM5MjRjM2RiLm1qcyc7XG5cbmNvbnN0IFRSUENfRVJST1JfQ09ERVNfQllfTlVNQkVSID0gaW52ZXJ0KFRSUENfRVJST1JfQ09ERVNfQllfS0VZKTtcbmNvbnN0IEpTT05SUEMyX1RPX0hUVFBfQ09ERSA9IHtcbiAgICBQQVJTRV9FUlJPUjogNDAwLFxuICAgIEJBRF9SRVFVRVNUOiA0MDAsXG4gICAgVU5BVVRIT1JJWkVEOiA0MDEsXG4gICAgTk9UX0ZPVU5EOiA0MDQsXG4gICAgRk9SQklEREVOOiA0MDMsXG4gICAgTUVUSE9EX05PVF9TVVBQT1JURUQ6IDQwNSxcbiAgICBUSU1FT1VUOiA0MDgsXG4gICAgQ09ORkxJQ1Q6IDQwOSxcbiAgICBQUkVDT05ESVRJT05fRkFJTEVEOiA0MTIsXG4gICAgUEFZTE9BRF9UT09fTEFSR0U6IDQxMyxcbiAgICBVTlBST0NFU1NBQkxFX0NPTlRFTlQ6IDQyMixcbiAgICBUT09fTUFOWV9SRVFVRVNUUzogNDI5LFxuICAgIENMSUVOVF9DTE9TRURfUkVRVUVTVDogNDk5LFxuICAgIElOVEVSTkFMX1NFUlZFUl9FUlJPUjogNTAwLFxuICAgIE5PVF9JTVBMRU1FTlRFRDogNTAxXG59O1xuZnVuY3Rpb24gZ2V0U3RhdHVzQ29kZUZyb21LZXkoY29kZSkge1xuICAgIHJldHVybiBKU09OUlBDMl9UT19IVFRQX0NPREVbY29kZV0gPz8gNTAwO1xufVxuZnVuY3Rpb24gZ2V0SFRUUFN0YXR1c0NvZGUoanNvbikge1xuICAgIGNvbnN0IGFyciA9IEFycmF5LmlzQXJyYXkoanNvbikgPyBqc29uIDogW1xuICAgICAgICBqc29uXG4gICAgXTtcbiAgICBjb25zdCBodHRwU3RhdHVzZXMgPSBuZXcgU2V0KGFyci5tYXAoKHJlcyk9PntcbiAgICAgICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gcmVzLmVycm9yLmRhdGE7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGRhdGEuaHR0cFN0YXR1cyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YS5odHRwU3RhdHVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY29kZSA9IFRSUENfRVJST1JfQ09ERVNfQllfTlVNQkVSW3Jlcy5lcnJvci5jb2RlXTtcbiAgICAgICAgICAgIHJldHVybiBnZXRTdGF0dXNDb2RlRnJvbUtleShjb2RlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMjAwO1xuICAgIH0pKTtcbiAgICBpZiAoaHR0cFN0YXR1c2VzLnNpemUgIT09IDEpIHtcbiAgICAgICAgcmV0dXJuIDIwNztcbiAgICB9XG4gICAgY29uc3QgaHR0cFN0YXR1cyA9IGh0dHBTdGF0dXNlcy52YWx1ZXMoKS5uZXh0KCkudmFsdWU7XG4gICAgcmV0dXJuIGh0dHBTdGF0dXM7XG59XG5mdW5jdGlvbiBnZXRIVFRQU3RhdHVzQ29kZUZyb21FcnJvcihlcnJvcikge1xuICAgIHJldHVybiBnZXRTdGF0dXNDb2RlRnJvbUtleShlcnJvci5jb2RlKTtcbn1cblxuY29uc3Qgbm9vcCA9ICgpPT57XG4vLyBub29wXG59O1xuZnVuY3Rpb24gY3JlYXRlSW5uZXJQcm94eShjYWxsYmFjaywgcGF0aCkge1xuICAgIGNvbnN0IHByb3h5ID0gbmV3IFByb3h5KG5vb3AsIHtcbiAgICAgICAgZ2V0IChfb2JqLCBrZXkpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJyB8fCBrZXkgPT09ICd0aGVuJykge1xuICAgICAgICAgICAgICAgIC8vIHNwZWNpYWwgY2FzZSBmb3IgaWYgdGhlIHByb3h5IGlzIGFjY2lkZW50YWxseSB0cmVhdGVkXG4gICAgICAgICAgICAgICAgLy8gbGlrZSBhIFByb21pc2VMaWtlIChsaWtlIGluIGBQcm9taXNlLnJlc29sdmUocHJveHkpYClcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUlubmVyUHJveHkoY2FsbGJhY2ssIFtcbiAgICAgICAgICAgICAgICAuLi5wYXRoLFxuICAgICAgICAgICAgICAgIGtleVxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH0sXG4gICAgICAgIGFwcGx5IChfMSwgXzIsIGFyZ3MpIHtcbiAgICAgICAgICAgIGNvbnN0IGlzQXBwbHkgPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV0gPT09ICdhcHBseSc7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soe1xuICAgICAgICAgICAgICAgIGFyZ3M6IGlzQXBwbHkgPyBhcmdzLmxlbmd0aCA+PSAyID8gYXJnc1sxXSA6IFtdIDogYXJncyxcbiAgICAgICAgICAgICAgICBwYXRoOiBpc0FwcGx5ID8gcGF0aC5zbGljZSgwLCAtMSkgOiBwYXRoXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBwcm94eTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIHByb3h5IHRoYXQgY2FsbHMgdGhlIGNhbGxiYWNrIHdpdGggdGhlIHBhdGggYW5kIGFyZ3VtZW50c1xuICpcbiAqIEBpbnRlcm5hbFxuICovIGNvbnN0IGNyZWF0ZVJlY3Vyc2l2ZVByb3h5ID0gKGNhbGxiYWNrKT0+Y3JlYXRlSW5uZXJQcm94eShjYWxsYmFjaywgW10pO1xuLyoqXG4gKiBVc2VkIGluIHBsYWNlIG9mIGBuZXcgUHJveHlgIHdoZXJlIGVhY2ggaGFuZGxlciB3aWxsIG1hcCAxIGxldmVsIGRlZXAgdG8gYW5vdGhlciB2YWx1ZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqLyBjb25zdCBjcmVhdGVGbGF0UHJveHkgPSAoY2FsbGJhY2spPT57XG4gICAgcmV0dXJuIG5ldyBQcm94eShub29wLCB7XG4gICAgICAgIGdldCAoX29iaiwgbmFtZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJyB8fCBuYW1lID09PSAndGhlbicpIHtcbiAgICAgICAgICAgICAgICAvLyBzcGVjaWFsIGNhc2UgZm9yIGlmIHRoZSBwcm94eSBpcyBhY2NpZGVudGFsbHkgdHJlYXRlZFxuICAgICAgICAgICAgICAgIC8vIGxpa2UgYSBQcm9taXNlTGlrZSAobGlrZSBpbiBgUHJvbWlzZS5yZXNvbHZlKHByb3h5KWApXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhuYW1lKTtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcblxuZXhwb3J0IHsgVFJQQ19FUlJPUl9DT0RFU19CWV9OVU1CRVIgYXMgVCwgY3JlYXRlUmVjdXJzaXZlUHJveHkgYXMgYSwgZ2V0SFRUUFN0YXR1c0NvZGUgYXMgYiwgY3JlYXRlRmxhdFByb3h5IGFzIGMsIGdldEhUVFBTdGF0dXNDb2RlRnJvbUVycm9yIGFzIGcgfTtcbiIsIi8qKlxuICogQGludGVybmFsXG4gKi8gZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgICAvLyBjaGVjayB0aGF0IHZhbHVlIGlzIG9iamVjdFxuICAgIHJldHVybiAhIXZhbHVlICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnO1xufVxuXG5jbGFzcyBVbmtub3duQ2F1c2VFcnJvciBleHRlbmRzIEVycm9yIHtcbn1cbmZ1bmN0aW9uIGdldENhdXNlRnJvbVVua25vd24oY2F1c2UpIHtcbiAgICBpZiAoY2F1c2UgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICByZXR1cm4gY2F1c2U7XG4gICAgfVxuICAgIGNvbnN0IHR5cGUgPSB0eXBlb2YgY2F1c2U7XG4gICAgaWYgKHR5cGUgPT09ICd1bmRlZmluZWQnIHx8IHR5cGUgPT09ICdmdW5jdGlvbicgfHwgY2F1c2UgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLy8gUHJpbWl0aXZlIHR5cGVzIGp1c3QgZ2V0IHdyYXBwZWQgaW4gYW4gZXJyb3JcbiAgICBpZiAodHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihTdHJpbmcoY2F1c2UpKTtcbiAgICB9XG4gICAgLy8gSWYgaXQncyBhbiBvYmplY3QsIHdlJ2xsIGNyZWF0ZSBhIHN5bnRoZXRpYyBlcnJvclxuICAgIGlmIChpc09iamVjdChjYXVzZSkpIHtcbiAgICAgICAgY29uc3QgZXJyID0gbmV3IFVua25vd25DYXVzZUVycm9yKCk7XG4gICAgICAgIGZvcihjb25zdCBrZXkgaW4gY2F1c2Upe1xuICAgICAgICAgICAgZXJyW2tleV0gPSBjYXVzZVtrZXldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlcnI7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydCB7IGdldENhdXNlRnJvbVVua25vd24gYXMgZyB9O1xuIiwiZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgICAvLyBjaGVjayB0aGF0IHZhbHVlIGlzIG9iamVjdFxuICAgIHJldHVybiAhIXZhbHVlICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnO1xufVxuXG4vLyBGSVhNRTpcbi8vIC0gdGhlIGdlbmVyaWNzIGhlcmUgYXJlIHByb2JhYmx5IHVubmVjZXNzYXJ5XG4vLyAtIHRoZSBSUEMtc3BlYyBjb3VsZCBwcm9iYWJseSBiZSBzaW1wbGlmaWVkIHRvIGNvbWJpbmUgSFRUUCArIFdTXG4vKiogQGludGVybmFsICovIGZ1bmN0aW9uIHRyYW5zZm9ybVJlc3VsdElubmVyKHJlc3BvbnNlLCBydW50aW1lKSB7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzcG9uc2UpIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBydW50aW1lLnRyYW5zZm9ybWVyLmRlc2VyaWFsaXplKHJlc3BvbnNlLmVycm9yKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG9rOiBmYWxzZSxcbiAgICAgICAgICAgIGVycm9yOiB7XG4gICAgICAgICAgICAgICAgLi4ucmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgZXJyb3JcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICAuLi5yZXNwb25zZS5yZXN1bHQsXG4gICAgICAgIC4uLighcmVzcG9uc2UucmVzdWx0LnR5cGUgfHwgcmVzcG9uc2UucmVzdWx0LnR5cGUgPT09ICdkYXRhJykgJiYge1xuICAgICAgICAgICAgdHlwZTogJ2RhdGEnLFxuICAgICAgICAgICAgZGF0YTogcnVudGltZS50cmFuc2Zvcm1lci5kZXNlcmlhbGl6ZShyZXNwb25zZS5yZXN1bHQuZGF0YSlcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgb2s6IHRydWUsXG4gICAgICAgIHJlc3VsdFxuICAgIH07XG59XG5jbGFzcyBUcmFuc2Zvcm1SZXN1bHRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICBzdXBlcignVW5hYmxlIHRvIHRyYW5zZm9ybSByZXNwb25zZSBmcm9tIHNlcnZlcicpO1xuICAgIH1cbn1cbi8qKlxuICogVHJhbnNmb3JtcyBhbmQgdmFsaWRhdGVzIHRoYXQgdGhlIHJlc3VsdCBpcyBhIHZhbGlkIFRSUENSZXNwb25zZVxuICogQGludGVybmFsXG4gKi8gZnVuY3Rpb24gdHJhbnNmb3JtUmVzdWx0KHJlc3BvbnNlLCBydW50aW1lKSB7XG4gICAgbGV0IHJlc3VsdDtcbiAgICB0cnkge1xuICAgICAgICAvLyBVc2UgdGhlIGRhdGEgdHJhbnNmb3JtZXJzIG9uIHRoZSBKU09OLXJlc3BvbnNlXG4gICAgICAgIHJlc3VsdCA9IHRyYW5zZm9ybVJlc3VsdElubmVyKHJlc3BvbnNlLCBydW50aW1lKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFRyYW5zZm9ybVJlc3VsdEVycm9yKCk7XG4gICAgfVxuICAgIC8vIGNoZWNrIHRoYXQgb3V0cHV0IG9mIHRoZSB0cmFuc2Zvcm1lcnMgaXMgYSB2YWxpZCBUUlBDUmVzcG9uc2VcbiAgICBpZiAoIXJlc3VsdC5vayAmJiAoIWlzT2JqZWN0KHJlc3VsdC5lcnJvci5lcnJvcikgfHwgdHlwZW9mIHJlc3VsdC5lcnJvci5lcnJvci5jb2RlICE9PSAnbnVtYmVyJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFRyYW5zZm9ybVJlc3VsdEVycm9yKCk7XG4gICAgfVxuICAgIGlmIChyZXN1bHQub2sgJiYgIWlzT2JqZWN0KHJlc3VsdC5yZXN1bHQpKSB7XG4gICAgICAgIHRocm93IG5ldyBUcmFuc2Zvcm1SZXN1bHRFcnJvcigpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgeyBpc09iamVjdCBhcyBpLCB0cmFuc2Zvcm1SZXN1bHQgYXMgdCB9O1xuIiwiaW1wb3J0IHsgZ2V0Q2F1c2VGcm9tVW5rbm93biB9IGZyb20gJ0B0cnBjL3NlcnZlci9zaGFyZWQnO1xuaW1wb3J0IHsgaSBhcyBpc09iamVjdCB9IGZyb20gJy4vdHJhbnNmb3JtUmVzdWx0LWFjZTg2NGI4Lm1qcyc7XG5cbmZ1bmN0aW9uIGlzVFJQQ0NsaWVudEVycm9yKGNhdXNlKSB7XG4gICAgcmV0dXJuIGNhdXNlIGluc3RhbmNlb2YgVFJQQ0NsaWVudEVycm9yIHx8IC8qKlxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICogRGVsZXRlIGluIG5leHQgbWFqb3JcbiAgICAgKi8gY2F1c2UgaW5zdGFuY2VvZiBFcnJvciAmJiBjYXVzZS5uYW1lID09PSAnVFJQQ0NsaWVudEVycm9yJztcbn1cbmZ1bmN0aW9uIGlzVFJQQ0Vycm9yUmVzcG9uc2Uob2JqKSB7XG4gICAgcmV0dXJuIGlzT2JqZWN0KG9iaikgJiYgaXNPYmplY3Qob2JqLmVycm9yKSAmJiB0eXBlb2Ygb2JqLmVycm9yLmNvZGUgPT09ICdudW1iZXInICYmIHR5cGVvZiBvYmouZXJyb3IubWVzc2FnZSA9PT0gJ3N0cmluZyc7XG59XG5jbGFzcyBUUlBDQ2xpZW50RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgc3RhdGljIGZyb20oX2NhdXNlLCBvcHRzID0ge30pIHtcbiAgICAgICAgY29uc3QgY2F1c2UgPSBfY2F1c2U7XG4gICAgICAgIGlmIChpc1RSUENDbGllbnRFcnJvcihjYXVzZSkpIHtcbiAgICAgICAgICAgIGlmIChvcHRzLm1ldGEpIHtcbiAgICAgICAgICAgICAgICAvLyBEZWNvcmF0ZSB3aXRoIG1ldGEgZXJyb3IgZGF0YVxuICAgICAgICAgICAgICAgIGNhdXNlLm1ldGEgPSB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmNhdXNlLm1ldGEsXG4gICAgICAgICAgICAgICAgICAgIC4uLm9wdHMubWV0YVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2F1c2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzVFJQQ0Vycm9yUmVzcG9uc2UoY2F1c2UpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFRSUENDbGllbnRFcnJvcihjYXVzZS5lcnJvci5tZXNzYWdlLCB7XG4gICAgICAgICAgICAgICAgLi4ub3B0cyxcbiAgICAgICAgICAgICAgICByZXN1bHQ6IGNhdXNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShjYXVzZSBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBUUlBDQ2xpZW50RXJyb3IoJ1Vua25vd24gZXJyb3InLCB7XG4gICAgICAgICAgICAgICAgLi4ub3B0cyxcbiAgICAgICAgICAgICAgICBjYXVzZTogY2F1c2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgVFJQQ0NsaWVudEVycm9yKGNhdXNlLm1lc3NhZ2UsIHtcbiAgICAgICAgICAgIC4uLm9wdHMsXG4gICAgICAgICAgICBjYXVzZTogZ2V0Q2F1c2VGcm9tVW5rbm93bihjYXVzZSlcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIG9wdHMpe1xuICAgICAgICBjb25zdCBjYXVzZSA9IG9wdHM/LmNhdXNlO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG4gICAgICAgIC8vIEB0cy1pZ25vcmUgaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtZXJyb3ItY2F1c2VcbiAgICAgICAgc3VwZXIobWVzc2FnZSwge1xuICAgICAgICAgICAgY2F1c2VcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubWV0YSA9IG9wdHM/Lm1ldGE7XG4gICAgICAgIHRoaXMuY2F1c2UgPSBjYXVzZTtcbiAgICAgICAgdGhpcy5zaGFwZSA9IG9wdHM/LnJlc3VsdD8uZXJyb3I7XG4gICAgICAgIHRoaXMuZGF0YSA9IG9wdHM/LnJlc3VsdD8uZXJyb3IuZGF0YTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ1RSUENDbGllbnRFcnJvcic7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBUUlBDQ2xpZW50RXJyb3IucHJvdG90eXBlKTtcbiAgICB9XG59XG5cbmV4cG9ydCB7IFRSUENDbGllbnRFcnJvciBhcyBUIH07XG4iLCJpbXBvcnQgeyBzaGFyZSwgb2JzZXJ2YWJsZVRvUHJvbWlzZSB9IGZyb20gJ0B0cnBjL3NlcnZlci9vYnNlcnZhYmxlJztcbmltcG9ydCB7IGMgYXMgY3JlYXRlQ2hhaW4gfSBmcm9tICcuL3NwbGl0TGluay00Yzc1ZjdiZS5tanMnO1xuZXhwb3J0IHsgcyBhcyBzcGxpdExpbmsgfSBmcm9tICcuL3NwbGl0TGluay00Yzc1ZjdiZS5tanMnO1xuaW1wb3J0IHsgVCBhcyBUUlBDQ2xpZW50RXJyb3IgfSBmcm9tICcuL1RSUENDbGllbnRFcnJvci0zOGY5YTMyYS5tanMnO1xuZXhwb3J0IHsgVCBhcyBUUlBDQ2xpZW50RXJyb3IgfSBmcm9tICcuL1RSUENDbGllbnRFcnJvci0zOGY5YTMyYS5tanMnO1xuaW1wb3J0IHsgY3JlYXRlRmxhdFByb3h5LCBjcmVhdGVSZWN1cnNpdmVQcm94eSB9IGZyb20gJ0B0cnBjL3NlcnZlci9zaGFyZWQnO1xuaW1wb3J0IHsgZiBhcyBmZXRjaEhUVFBSZXNwb25zZSwgZyBhcyBnZXRVcmwsIGEgYXMgZ2V0Qm9keSQxLCBoIGFzIGh0dHBSZXF1ZXN0IH0gZnJvbSAnLi9odHRwVXRpbHMtYjlkMGNiNDgubWpzJztcbmV4cG9ydCB7IGIgYXMgZ2V0RmV0Y2ggfSBmcm9tICcuL2h0dHBVdGlscy1iOWQwY2I0OC5tanMnO1xuaW1wb3J0IHsgYyBhcyBjcmVhdGVIVFRQQmF0Y2hMaW5rIH0gZnJvbSAnLi9odHRwQmF0Y2hMaW5rLWQwZjllYWM5Lm1qcyc7XG5leHBvcnQgeyBoIGFzIGh0dHBCYXRjaExpbmsgfSBmcm9tICcuL2h0dHBCYXRjaExpbmstZDBmOWVhYzkubWpzJztcbmltcG9ydCB7IGh0dHBMaW5rRmFjdG9yeSB9IGZyb20gJy4vbGlua3MvaHR0cExpbmsubWpzJztcbmV4cG9ydCB7IGh0dHBMaW5rLCBodHRwTGlua0ZhY3RvcnkgfSBmcm9tICcuL2xpbmtzL2h0dHBMaW5rLm1qcyc7XG5leHBvcnQgeyBsb2dnZXJMaW5rIH0gZnJvbSAnLi9saW5rcy9sb2dnZXJMaW5rLm1qcyc7XG5leHBvcnQgeyBjcmVhdGVXU0NsaWVudCwgd3NMaW5rIH0gZnJvbSAnLi9saW5rcy93c0xpbmsubWpzJztcbmltcG9ydCAnLi90cmFuc2Zvcm1SZXN1bHQtYWNlODY0YjgubWpzJztcblxuY2xhc3MgVFJQQ1VudHlwZWRDbGllbnQge1xuICAgICRyZXF1ZXN0KHsgdHlwZSAsIGlucHV0ICwgcGF0aCAsIGNvbnRleHQgPXt9ICB9KSB7XG4gICAgICAgIGNvbnN0IGNoYWluJCA9IGNyZWF0ZUNoYWluKHtcbiAgICAgICAgICAgIGxpbmtzOiB0aGlzLmxpbmtzLFxuICAgICAgICAgICAgb3A6IHtcbiAgICAgICAgICAgICAgICBpZDogKyt0aGlzLnJlcXVlc3RJZCxcbiAgICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgICAgY29udGV4dFxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNoYWluJC5waXBlKHNoYXJlKCkpO1xuICAgIH1cbiAgICByZXF1ZXN0QXNQcm9taXNlKG9wdHMpIHtcbiAgICAgICAgY29uc3QgcmVxJCA9IHRoaXMuJHJlcXVlc3Qob3B0cyk7XG4gICAgICAgIGNvbnN0IHsgcHJvbWlzZSAsIGFib3J0ICB9ID0gb2JzZXJ2YWJsZVRvUHJvbWlzZShyZXEkKTtcbiAgICAgICAgY29uc3QgYWJvcnRhYmxlUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpPT57XG4gICAgICAgICAgICBvcHRzLnNpZ25hbD8uYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydCk7XG4gICAgICAgICAgICBwcm9taXNlLnRoZW4oKGVudmVsb3BlKT0+e1xuICAgICAgICAgICAgICAgIHJlc29sdmUoZW52ZWxvcGUucmVzdWx0LmRhdGEpO1xuICAgICAgICAgICAgfSkuY2F0Y2goKGVycik9PntcbiAgICAgICAgICAgICAgICByZWplY3QoVFJQQ0NsaWVudEVycm9yLmZyb20oZXJyKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBhYm9ydGFibGVQcm9taXNlO1xuICAgIH1cbiAgICBxdWVyeShwYXRoLCBpbnB1dCwgb3B0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0QXNQcm9taXNlKHtcbiAgICAgICAgICAgIHR5cGU6ICdxdWVyeScsXG4gICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICBjb250ZXh0OiBvcHRzPy5jb250ZXh0LFxuICAgICAgICAgICAgc2lnbmFsOiBvcHRzPy5zaWduYWxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG11dGF0aW9uKHBhdGgsIGlucHV0LCBvcHRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3RBc1Byb21pc2Uoe1xuICAgICAgICAgICAgdHlwZTogJ211dGF0aW9uJyxcbiAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgIGNvbnRleHQ6IG9wdHM/LmNvbnRleHQsXG4gICAgICAgICAgICBzaWduYWw6IG9wdHM/LnNpZ25hbFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3Vic2NyaXB0aW9uKHBhdGgsIGlucHV0LCBvcHRzKSB7XG4gICAgICAgIGNvbnN0IG9ic2VydmFibGUkID0gdGhpcy4kcmVxdWVzdCh7XG4gICAgICAgICAgICB0eXBlOiAnc3Vic2NyaXB0aW9uJyxcbiAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgIGNvbnRleHQ6IG9wdHM/LmNvbnRleHRcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBvYnNlcnZhYmxlJC5zdWJzY3JpYmUoe1xuICAgICAgICAgICAgbmV4dCAoZW52ZWxvcGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoZW52ZWxvcGUucmVzdWx0LnR5cGUgPT09ICdzdGFydGVkJykge1xuICAgICAgICAgICAgICAgICAgICBvcHRzLm9uU3RhcnRlZD8uKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlbnZlbG9wZS5yZXN1bHQudHlwZSA9PT0gJ3N0b3BwZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdHMub25TdG9wcGVkPy4oKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvcHRzLm9uRGF0YT8uKGVudmVsb3BlLnJlc3VsdC5kYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZXJyb3IgKGVycikge1xuICAgICAgICAgICAgICAgIG9wdHMub25FcnJvcj8uKGVycik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29tcGxldGUgKCkge1xuICAgICAgICAgICAgICAgIG9wdHMub25Db21wbGV0ZT8uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihvcHRzKXtcbiAgICAgICAgdGhpcy5yZXF1ZXN0SWQgPSAwO1xuICAgICAgICBjb25zdCBjb21iaW5lZFRyYW5zZm9ybWVyID0gKCgpPT57XG4gICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm1lciA9IG9wdHMudHJhbnNmb3JtZXI7XG4gICAgICAgICAgICBpZiAoIXRyYW5zZm9ybWVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcmlhbGl6ZTogKGRhdGEpPT5kYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVzZXJpYWxpemU6IChkYXRhKT0+ZGF0YVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcmlhbGl6ZTogKGRhdGEpPT5kYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVzZXJpYWxpemU6IChkYXRhKT0+ZGF0YVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgnaW5wdXQnIGluIHRyYW5zZm9ybWVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9wdHMudHJhbnNmb3JtZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGlucHV0OiB0cmFuc2Zvcm1lcixcbiAgICAgICAgICAgICAgICBvdXRwdXQ6IHRyYW5zZm9ybWVyXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSgpO1xuICAgICAgICB0aGlzLnJ1bnRpbWUgPSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lcjoge1xuICAgICAgICAgICAgICAgIHNlcmlhbGl6ZTogKGRhdGEpPT5jb21iaW5lZFRyYW5zZm9ybWVyLmlucHV0LnNlcmlhbGl6ZShkYXRhKSxcbiAgICAgICAgICAgICAgICBkZXNlcmlhbGl6ZTogKGRhdGEpPT5jb21iaW5lZFRyYW5zZm9ybWVyLm91dHB1dC5kZXNlcmlhbGl6ZShkYXRhKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbWJpbmVkVHJhbnNmb3JtZXJcbiAgICAgICAgfTtcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSB0aGUgbGlua3NcbiAgICAgICAgdGhpcy5saW5rcyA9IG9wdHMubGlua3MubWFwKChsaW5rKT0+bGluayh0aGlzLnJ1bnRpbWUpKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRSUENVbnR5cGVkQ2xpZW50KG9wdHMpIHtcbiAgICByZXR1cm4gbmV3IFRSUENVbnR5cGVkQ2xpZW50KG9wdHMpO1xufVxuXG4vKipcbiAqIEBkZXByZWNhdGVkIHVzZSBgY3JlYXRlVFJQQ1Byb3h5Q2xpZW50YCBpbnN0ZWFkXG4gKi8gZnVuY3Rpb24gY3JlYXRlVFJQQ0NsaWVudChvcHRzKSB7XG4gICAgY29uc3QgY2xpZW50ID0gbmV3IFRSUENVbnR5cGVkQ2xpZW50KG9wdHMpO1xuICAgIHJldHVybiBjbGllbnQ7XG59XG5cbmNvbnN0IGNsaWVudENhbGxUeXBlTWFwID0ge1xuICAgIHF1ZXJ5OiAncXVlcnknLFxuICAgIG11dGF0ZTogJ211dGF0aW9uJyxcbiAgICBzdWJzY3JpYmU6ICdzdWJzY3JpcHRpb24nXG59O1xuLyoqIEBpbnRlcm5hbCAqLyBjb25zdCBjbGllbnRDYWxsVHlwZVRvUHJvY2VkdXJlVHlwZSA9IChjbGllbnRDYWxsVHlwZSk9PntcbiAgICByZXR1cm4gY2xpZW50Q2FsbFR5cGVNYXBbY2xpZW50Q2FsbFR5cGVdO1xufTtcbi8qKlxuICogQGRlcHJlY2F0ZWQgdXNlIGBjcmVhdGVUUlBDUHJveHlDbGllbnRgIGluc3RlYWRcbiAqIEBpbnRlcm5hbFxuICovIGZ1bmN0aW9uIGNyZWF0ZVRSUENDbGllbnRQcm94eShjbGllbnQpIHtcbiAgICByZXR1cm4gY3JlYXRlRmxhdFByb3h5KChrZXkpPT57XG4gICAgICAgIGlmIChjbGllbnQuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuIGNsaWVudFtrZXldO1xuICAgICAgICB9XG4gICAgICAgIGlmIChrZXkgPT09ICdfX3VudHlwZWRDbGllbnQnKSB7XG4gICAgICAgICAgICByZXR1cm4gY2xpZW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjcmVhdGVSZWN1cnNpdmVQcm94eSgoeyBwYXRoICwgYXJncyAgfSk9PntcbiAgICAgICAgICAgIGNvbnN0IHBhdGhDb3B5ID0gW1xuICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAuLi5wYXRoXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgY29uc3QgcHJvY2VkdXJlVHlwZSA9IGNsaWVudENhbGxUeXBlVG9Qcm9jZWR1cmVUeXBlKHBhdGhDb3B5LnBvcCgpKTtcbiAgICAgICAgICAgIGNvbnN0IGZ1bGxQYXRoID0gcGF0aENvcHkuam9pbignLicpO1xuICAgICAgICAgICAgcmV0dXJuIGNsaWVudFtwcm9jZWR1cmVUeXBlXShmdWxsUGF0aCwgLi4uYXJncyk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlVFJQQ1Byb3h5Q2xpZW50KG9wdHMpIHtcbiAgICBjb25zdCBjbGllbnQgPSBuZXcgVFJQQ1VudHlwZWRDbGllbnQob3B0cyk7XG4gICAgY29uc3QgcHJveHkgPSBjcmVhdGVUUlBDQ2xpZW50UHJveHkoY2xpZW50KTtcbiAgICByZXR1cm4gcHJveHk7XG59XG4vKipcbiAqIEdldCBhbiB1bnR5cGVkIGNsaWVudCBmcm9tIGEgcHJveHkgY2xpZW50XG4gKiBAaW50ZXJuYWxcbiAqLyBmdW5jdGlvbiBnZXRVbnR5cGVkQ2xpZW50KGNsaWVudCkge1xuICAgIHJldHVybiBjbGllbnQuX191bnR5cGVkQ2xpZW50O1xufVxuXG5mdW5jdGlvbiBnZXRUZXh0RGVjb2RlcihjdXN0b21UZXh0RGVjb2Rlcikge1xuICAgIGlmIChjdXN0b21UZXh0RGVjb2Rlcikge1xuICAgICAgICByZXR1cm4gY3VzdG9tVGV4dERlY29kZXI7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvcHJlZmVyLW9wdGlvbmFsLWNoYWluXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5UZXh0RGVjb2Rlcikge1xuICAgICAgICByZXR1cm4gbmV3IHdpbmRvdy5UZXh0RGVjb2RlcigpO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3ByZWZlci1vcHRpb25hbC1jaGFpblxuICAgIGlmICh0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgJiYgZ2xvYmFsVGhpcy5UZXh0RGVjb2Rlcikge1xuICAgICAgICByZXR1cm4gbmV3IGdsb2JhbFRoaXMuVGV4dERlY29kZXIoKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyBUZXh0RGVjb2RlciBpbXBsZW1lbnRhdGlvbiBmb3VuZCcpO1xufVxuXG4vLyBTdHJlYW0gcGFyc2luZyBhZGFwdGVkIGZyb20gaHR0cHM6Ly93d3cubG9naW5yYWRpdXMuY29tL2Jsb2cvZW5naW5lZXJpbmcvZ3Vlc3QtcG9zdC9odHRwLXN0cmVhbWluZy13aXRoLW5vZGVqcy1hbmQtZmV0Y2gtYXBpL1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqIEBkZXNjcmlwdGlvbiBUYWtlIGEgc3RyZWFtIG9mIGJ5dGVzIGFuZCBjYWxsIGBvbkxpbmVgIHdpdGhcbiAqIGEgSlNPTiBvYmplY3QgZm9yIGVhY2ggbGluZSBpbiB0aGUgc3RyZWFtLiBFeHBlY3RlZCBzdHJlYW1cbiAqIGZvcm1hdCBpczpcbiAqIGBgYGpzb25cbiAqIHtcIjFcIjogey4uLn1cbiAqICxcIjBcIjogey4uLn1cbiAqIH1cbiAqIGBgYFxuICovIGFzeW5jIGZ1bmN0aW9uIHBhcnNlSlNPTlN0cmVhbShvcHRzKSB7XG4gICAgY29uc3QgcGFyc2UgPSBvcHRzLnBhcnNlID8/IEpTT04ucGFyc2U7XG4gICAgY29uc3Qgb25MaW5lID0gKGxpbmUpPT57XG4gICAgICAgIGlmIChvcHRzLnNpZ25hbD8uYWJvcnRlZCkgcmV0dXJuO1xuICAgICAgICBpZiAoIWxpbmUgfHwgbGluZSA9PT0gJ30nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICogQXQgdGhpcyBwb2ludCwgYGxpbmVgIGNhbiBiZSBvbmUgb2YgdHdvIHRoaW5nczpcbiAgICAgKiAtIFRoZSBmaXJzdCBsaW5lIG9mIHRoZSBzdHJlYW0gYHtcIjJcIjp7Li4ufWBcbiAgICAgKiAtIEEgbGluZSBpbiB0aGUgbWlkZGxlIG9mIHRoZSBzdHJlYW0gYCxcIjJcIjp7Li4ufWBcbiAgICAgKi8gY29uc3QgaW5kZXhPZkNvbG9uID0gbGluZS5pbmRleE9mKCc6Jyk7XG4gICAgICAgIGNvbnN0IGluZGV4QXNTdHIgPSBsaW5lLnN1YnN0cmluZygyLCBpbmRleE9mQ29sb24gLSAxKTtcbiAgICAgICAgY29uc3QgdGV4dCA9IGxpbmUuc3Vic3RyaW5nKGluZGV4T2ZDb2xvbiArIDEpO1xuICAgICAgICBvcHRzLm9uU2luZ2xlKE51bWJlcihpbmRleEFzU3RyKSwgcGFyc2UodGV4dCkpO1xuICAgIH07XG4gICAgYXdhaXQgcmVhZExpbmVzKG9wdHMucmVhZGFibGVTdHJlYW0sIG9uTGluZSwgb3B0cy50ZXh0RGVjb2Rlcik7XG59XG4vKipcbiAqIEhhbmRsZSB0cmFuc2Zvcm1pbmcgYSBzdHJlYW0gb2YgYnl0ZXMgaW50byBsaW5lcyBvZiB0ZXh0LlxuICogVG8gYXZvaWQgdXNpbmcgQXN5bmNJdGVyYXRvcnMgLyBBc3luY0dlbmVyYXRvcnMsXG4gKiB3ZSB1c2UgYSBjYWxsYmFjayBmb3IgZWFjaCBsaW5lLlxuICpcbiAqIEBwYXJhbSByZWFkYWJsZVN0cmVhbSBjYW4gYmUgYSBOb2RlSlMgc3RyZWFtIG9yIGEgV2ViQVBJIHN0cmVhbVxuICogQHBhcmFtIG9uTGluZSB3aWxsIGJlIGNhbGxlZCBmb3IgZXZlcnkgbGluZSAoJ1xcbicgZGVsaW1pdGVkKSBpbiB0aGUgc3RyZWFtXG4gKi8gYXN5bmMgZnVuY3Rpb24gcmVhZExpbmVzKHJlYWRhYmxlU3RyZWFtLCBvbkxpbmUsIHRleHREZWNvZGVyKSB7XG4gICAgbGV0IHBhcnRPZkxpbmUgPSAnJztcbiAgICBjb25zdCBvbkNodW5rID0gKGNodW5rKT0+e1xuICAgICAgICBjb25zdCBjaHVua1RleHQgPSB0ZXh0RGVjb2Rlci5kZWNvZGUoY2h1bmspO1xuICAgICAgICBjb25zdCBjaHVua0xpbmVzID0gY2h1bmtUZXh0LnNwbGl0KCdcXG4nKTtcbiAgICAgICAgaWYgKGNodW5rTGluZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBwYXJ0T2ZMaW5lICs9IGNodW5rTGluZXNbMF07XG4gICAgICAgIH0gZWxzZSBpZiAoY2h1bmtMaW5lcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvbiAtLSBsZW5ndGggY2hlY2tlZCBvbiBsaW5lIGFib3ZlXG4gICAgICAgICAgICBvbkxpbmUocGFydE9mTGluZSArIGNodW5rTGluZXNbMF0pO1xuICAgICAgICAgICAgZm9yKGxldCBpID0gMTsgaSA8IGNodW5rTGluZXMubGVuZ3RoIC0gMTsgaSsrKXtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvbiAtLSBsZW5ndGggY2hlY2tlZCBvbiBsaW5lIGFib3ZlXG4gICAgICAgICAgICAgICAgb25MaW5lKGNodW5rTGluZXNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb24gLS0gbGVuZ3RoIGRvZXNuJ3QgY2hhbmdlLCBzbyBpcyBuZWNlc3NhcmlseSA+IDFcbiAgICAgICAgICAgIHBhcnRPZkxpbmUgPSBjaHVua0xpbmVzW2NodW5rTGluZXMubGVuZ3RoIC0gMV07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIHdlIGhhbmRsZSAyIGRpZmZlcmVudCB0eXBlcyBvZiBzdHJlYW1zLCB0aGlzIGlmIHdoZXJlIHdlIGZpZ3VyZSBvdXQgd2hpY2ggb25lIHdlIGhhdmVcbiAgICBpZiAoJ2dldFJlYWRlcicgaW4gcmVhZGFibGVTdHJlYW0pIHtcbiAgICAgICAgYXdhaXQgcmVhZFN0YW5kYXJkQ2h1bmtzKHJlYWRhYmxlU3RyZWFtLCBvbkNodW5rKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBhd2FpdCByZWFkTm9kZUNodW5rcyhyZWFkYWJsZVN0cmVhbSwgb25DaHVuayk7XG4gICAgfVxuICAgIG9uTGluZShwYXJ0T2ZMaW5lKTtcbn1cbi8qKlxuICogSGFuZGxlIE5vZGVKUyBzdHJlYW1cbiAqLyBmdW5jdGlvbiByZWFkTm9kZUNodW5rcyhzdHJlYW0sIG9uQ2h1bmspIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpPT57XG4gICAgICAgIHN0cmVhbS5vbignZGF0YScsIG9uQ2h1bmspO1xuICAgICAgICBzdHJlYW0ub24oJ2VuZCcsIHJlc29sdmUpO1xuICAgIH0pO1xufVxuLyoqXG4gKiBIYW5kbGUgV2ViQVBJIHN0cmVhbVxuICovIGFzeW5jIGZ1bmN0aW9uIHJlYWRTdGFuZGFyZENodW5rcyhzdHJlYW0sIG9uQ2h1bmspIHtcbiAgICBjb25zdCByZWFkZXIgPSBzdHJlYW0uZ2V0UmVhZGVyKCk7XG4gICAgbGV0IHJlYWRSZXN1bHQgPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgIHdoaWxlKCFyZWFkUmVzdWx0LmRvbmUpe1xuICAgICAgICBvbkNodW5rKHJlYWRSZXN1bHQudmFsdWUpO1xuICAgICAgICByZWFkUmVzdWx0ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICB9XG59XG5jb25zdCBzdHJlYW1pbmdKc29uSHR0cFJlcXVlc3RlciA9IChvcHRzLCBvblNpbmdsZSk9PntcbiAgICBjb25zdCBhYyA9IG9wdHMuQWJvcnRDb250cm9sbGVyID8gbmV3IG9wdHMuQWJvcnRDb250cm9sbGVyKCkgOiBudWxsO1xuICAgIGNvbnN0IHJlc3BvbnNlUHJvbWlzZSA9IGZldGNoSFRUUFJlc3BvbnNlKHtcbiAgICAgICAgLi4ub3B0cyxcbiAgICAgICAgY29udGVudFR5cGVIZWFkZXI6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgYmF0Y2hNb2RlSGVhZGVyOiAnc3RyZWFtJyxcbiAgICAgICAgZ2V0VXJsLFxuICAgICAgICBnZXRCb2R5OiBnZXRCb2R5JDFcbiAgICB9LCBhYyk7XG4gICAgY29uc3QgY2FuY2VsID0gKCk9PmFjPy5hYm9ydCgpO1xuICAgIGNvbnN0IHByb21pc2UgPSByZXNwb25zZVByb21pc2UudGhlbihhc3luYyAocmVzKT0+e1xuICAgICAgICBpZiAoIXJlcy5ib2R5KSB0aHJvdyBuZXcgRXJyb3IoJ1JlY2VpdmVkIHJlc3BvbnNlIHdpdGhvdXQgYm9keScpO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgcmVzcG9uc2U6IHJlc1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcGFyc2VKU09OU3RyZWFtKHtcbiAgICAgICAgICAgIHJlYWRhYmxlU3RyZWFtOiByZXMuYm9keSxcbiAgICAgICAgICAgIG9uU2luZ2xlLFxuICAgICAgICAgICAgcGFyc2U6IChzdHJpbmcpPT4oe1xuICAgICAgICAgICAgICAgICAgICBqc29uOiBKU09OLnBhcnNlKHN0cmluZyksXG4gICAgICAgICAgICAgICAgICAgIG1ldGFcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHNpZ25hbDogYWM/LnNpZ25hbCxcbiAgICAgICAgICAgIHRleHREZWNvZGVyOiBvcHRzLnRleHREZWNvZGVyXG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIGNhbmNlbCxcbiAgICAgICAgcHJvbWlzZVxuICAgIH07XG59O1xuXG5jb25zdCBzdHJlYW1SZXF1ZXN0ZXIgPSAocmVxdWVzdGVyT3B0cyk9PntcbiAgICBjb25zdCB0ZXh0RGVjb2RlciA9IGdldFRleHREZWNvZGVyKHJlcXVlc3Rlck9wdHMub3B0cy50ZXh0RGVjb2Rlcik7XG4gICAgcmV0dXJuIChiYXRjaE9wcywgdW5pdFJlc29sdmVyKT0+e1xuICAgICAgICBjb25zdCBwYXRoID0gYmF0Y2hPcHMubWFwKChvcCk9Pm9wLnBhdGgpLmpvaW4oJywnKTtcbiAgICAgICAgY29uc3QgaW5wdXRzID0gYmF0Y2hPcHMubWFwKChvcCk9Pm9wLmlucHV0KTtcbiAgICAgICAgY29uc3QgeyBjYW5jZWwgLCBwcm9taXNlICB9ID0gc3RyZWFtaW5nSnNvbkh0dHBSZXF1ZXN0ZXIoe1xuICAgICAgICAgICAgLi4ucmVxdWVzdGVyT3B0cyxcbiAgICAgICAgICAgIHRleHREZWNvZGVyLFxuICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgIGlucHV0cyxcbiAgICAgICAgICAgIGhlYWRlcnMgKCkge1xuICAgICAgICAgICAgICAgIGlmICghcmVxdWVzdGVyT3B0cy5vcHRzLmhlYWRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJlcXVlc3Rlck9wdHMub3B0cy5oZWFkZXJzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXF1ZXN0ZXJPcHRzLm9wdHMuaGVhZGVycyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcExpc3Q6IGJhdGNoT3BzXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVxdWVzdGVyT3B0cy5vcHRzLmhlYWRlcnM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIChpbmRleCwgcmVzKT0+e1xuICAgICAgICAgICAgdW5pdFJlc29sdmVyKGluZGV4LCByZXMpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICogcmV0dXJuIGFuIGVtcHR5IGFycmF5IGJlY2F1c2UgdGhlIGJhdGNoTG9hZGVyIGV4cGVjdHMgYW4gYXJyYXkgb2YgcmVzdWx0c1xuICAgICAgICogYnV0IHdlJ3ZlIGFscmVhZHkgY2FsbGVkIHRoZSBgdW5pdFJlc29sdmVyYCBmb3IgZWFjaCBvZiB0aGVtLCB0aGVyZSdzXG4gICAgICAgKiBub3RoaW5nIGxlZnQgdG8gZG8gaGVyZS5cbiAgICAgICAqLyBwcm9taXNlOiBwcm9taXNlLnRoZW4oKCk9PltdKSxcbiAgICAgICAgICAgIGNhbmNlbFxuICAgICAgICB9O1xuICAgIH07XG59O1xuY29uc3QgdW5zdGFibGVfaHR0cEJhdGNoU3RyZWFtTGluayA9IGNyZWF0ZUhUVFBCYXRjaExpbmsoc3RyZWFtUmVxdWVzdGVyKTtcblxuY29uc3QgZ2V0Qm9keSA9IChvcHRzKT0+e1xuICAgIGlmICghKCdpbnB1dCcgaW4gb3B0cykpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKCEob3B0cy5pbnB1dCBpbnN0YW5jZW9mIEZvcm1EYXRhKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IGlzIG5vdCBGb3JtRGF0YScpO1xuICAgIH1cbiAgICByZXR1cm4gb3B0cy5pbnB1dDtcbn07XG5jb25zdCBmb3JtRGF0YVJlcXVlc3RlciA9IChvcHRzKT0+e1xuICAgIGlmIChvcHRzLnR5cGUgIT09ICdtdXRhdGlvbicpIHtcbiAgICAgICAgLy8gVE9ETyg/KSBoYW5kbGUgZm9ybWRhdGEgcXVlcmllc1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlIG9ubHkgaGFuZGxlIG11dGF0aW9ucyB3aXRoIGZvcm1kYXRhJyk7XG4gICAgfVxuICAgIHJldHVybiBodHRwUmVxdWVzdCh7XG4gICAgICAgIC4uLm9wdHMsXG4gICAgICAgIGdldFVybCAoKSB7XG4gICAgICAgICAgICByZXR1cm4gYCR7b3B0cy51cmx9LyR7b3B0cy5wYXRofWA7XG4gICAgICAgIH0sXG4gICAgICAgIGdldEJvZHlcbiAgICB9KTtcbn07XG5jb25zdCBleHBlcmltZW50YWxfZm9ybURhdGFMaW5rID0gaHR0cExpbmtGYWN0b3J5KHtcbiAgICByZXF1ZXN0ZXI6IGZvcm1EYXRhUmVxdWVzdGVyXG59KTtcblxuZXhwb3J0IHsgVFJQQ1VudHlwZWRDbGllbnQsIGNsaWVudENhbGxUeXBlVG9Qcm9jZWR1cmVUeXBlLCBjcmVhdGVUUlBDQ2xpZW50LCBjcmVhdGVUUlBDQ2xpZW50UHJveHksIGNyZWF0ZVRSUENQcm94eUNsaWVudCwgY3JlYXRlVFJQQ1VudHlwZWRDbGllbnQsIGV4cGVyaW1lbnRhbF9mb3JtRGF0YUxpbmssIGdldFVudHlwZWRDbGllbnQsIHVuc3RhYmxlX2h0dHBCYXRjaFN0cmVhbUxpbmsgfTtcbiIsImltcG9ydCB7IGcgYXMgZ2V0Q2F1c2VGcm9tVW5rbm93biB9IGZyb20gJy4vZ2V0Q2F1c2VGcm9tVW5rbm93bi0yZDY2NDE0YS5tanMnO1xuXG5mdW5jdGlvbiBnZXRUUlBDRXJyb3JGcm9tVW5rbm93bihjYXVzZSkge1xuICAgIGlmIChjYXVzZSBpbnN0YW5jZW9mIFRSUENFcnJvcikge1xuICAgICAgICByZXR1cm4gY2F1c2U7XG4gICAgfVxuICAgIGlmIChjYXVzZSBpbnN0YW5jZW9mIEVycm9yICYmIGNhdXNlLm5hbWUgPT09ICdUUlBDRXJyb3InKSB7XG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS90cnBjL3RycGMvcHVsbC80ODQ4XG4gICAgICAgIHJldHVybiBjYXVzZTtcbiAgICB9XG4gICAgY29uc3QgdHJwY0Vycm9yID0gbmV3IFRSUENFcnJvcih7XG4gICAgICAgIGNvZGU6ICdJTlRFUk5BTF9TRVJWRVJfRVJST1InLFxuICAgICAgICBjYXVzZVxuICAgIH0pO1xuICAgIC8vIEluaGVyaXQgc3RhY2sgZnJvbSBlcnJvclxuICAgIGlmIChjYXVzZSBpbnN0YW5jZW9mIEVycm9yICYmIGNhdXNlLnN0YWNrKSB7XG4gICAgICAgIHRycGNFcnJvci5zdGFjayA9IGNhdXNlLnN0YWNrO1xuICAgIH1cbiAgICByZXR1cm4gdHJwY0Vycm9yO1xufVxuY2xhc3MgVFJQQ0Vycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG9wdHMpe1xuICAgICAgICBjb25zdCBjYXVzZSA9IGdldENhdXNlRnJvbVVua25vd24ob3B0cy5jYXVzZSk7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBvcHRzLm1lc3NhZ2UgPz8gY2F1c2U/Lm1lc3NhZ2UgPz8gb3B0cy5jb2RlO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG4gICAgICAgIC8vIEB0cy1pZ25vcmUgaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtZXJyb3ItY2F1c2VcbiAgICAgICAgc3VwZXIobWVzc2FnZSwge1xuICAgICAgICAgICAgY2F1c2VcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY29kZSA9IG9wdHMuY29kZTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ1RSUENFcnJvcic7XG4gICAgICAgIGlmICghdGhpcy5jYXVzZSkge1xuICAgICAgICAgICAgLy8gPCBFUzIwMjIgLyA8IE5vZGUgMTYuOS4wIGNvbXBhdGFiaWxpdHlcbiAgICAgICAgICAgIHRoaXMuY2F1c2UgPSBjYXVzZTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IHsgVFJQQ0Vycm9yIGFzIFQsIGdldFRSUENFcnJvckZyb21Vbmtub3duIGFzIGcgfTtcbiIsImltcG9ydCB7IFQgYXMgVFJQQ0Vycm9yIH0gZnJvbSAnLi9UUlBDRXJyb3ItOThkNDQ3NTgubWpzJztcbmltcG9ydCB7IGEgYXMgY3JlYXRlUmVjdXJzaXZlUHJveHksIGcgYXMgZ2V0SFRUUFN0YXR1c0NvZGVGcm9tRXJyb3IgfSBmcm9tICcuL2luZGV4LWY5MWQ3MjBjLm1qcyc7XG5pbXBvcnQgeyBUIGFzIFRSUENfRVJST1JfQ09ERVNfQllfS0VZIH0gZnJvbSAnLi9jb2Rlcy1jOTI0YzNkYi5tanMnO1xuXG4vKipcbiAqIEBwdWJsaWNcbiAqLyAvKipcbiAqIEBpbnRlcm5hbFxuICovIGZ1bmN0aW9uIGdldERhdGFUcmFuc2Zvcm1lcih0cmFuc2Zvcm1lcikge1xuICAgIGlmICgnaW5wdXQnIGluIHRyYW5zZm9ybWVyKSB7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1lcjtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaW5wdXQ6IHRyYW5zZm9ybWVyLFxuICAgICAgICBvdXRwdXQ6IHRyYW5zZm9ybWVyXG4gICAgfTtcbn1cbi8qKlxuICogQGludGVybmFsXG4gKi8gY29uc3QgZGVmYXVsdFRyYW5zZm9ybWVyID0ge1xuICAgIF9kZWZhdWx0OiB0cnVlLFxuICAgIGlucHV0OiB7XG4gICAgICAgIHNlcmlhbGl6ZTogKG9iaik9Pm9iaixcbiAgICAgICAgZGVzZXJpYWxpemU6IChvYmopPT5vYmpcbiAgICB9LFxuICAgIG91dHB1dDoge1xuICAgICAgICBzZXJpYWxpemU6IChvYmopPT5vYmosXG4gICAgICAgIGRlc2VyaWFsaXplOiAob2JqKT0+b2JqXG4gICAgfVxufTtcblxuY29uc3QgZGVmYXVsdEZvcm1hdHRlciA9ICh7IHNoYXBlICB9KT0+e1xuICAgIHJldHVybiBzaGFwZTtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGFuIG9iamVjdCB3aXRob3V0IGluaGVyaXRpbmcgYW55dGhpbmcgZnJvbSBgT2JqZWN0LnByb3RvdHlwZWBcbiAqIEBpbnRlcm5hbFxuICovIGZ1bmN0aW9uIG9taXRQcm90b3R5cGUob2JqKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShudWxsKSwgb2JqKTtcbn1cblxuY29uc3QgcHJvY2VkdXJlVHlwZXMgPSBbXG4gICAgJ3F1ZXJ5JyxcbiAgICAnbXV0YXRpb24nLFxuICAgICdzdWJzY3JpcHRpb24nXG5dO1xuXG5mdW5jdGlvbiBpc1JvdXRlcihwcm9jZWR1cmVPclJvdXRlcikge1xuICAgIHJldHVybiAncm91dGVyJyBpbiBwcm9jZWR1cmVPclJvdXRlci5fZGVmO1xufVxuY29uc3QgZW1wdHlSb3V0ZXIgPSB7XG4gICAgX2N0eDogbnVsbCxcbiAgICBfZXJyb3JTaGFwZTogbnVsbCxcbiAgICBfbWV0YTogbnVsbCxcbiAgICBxdWVyaWVzOiB7fSxcbiAgICBtdXRhdGlvbnM6IHt9LFxuICAgIHN1YnNjcmlwdGlvbnM6IHt9LFxuICAgIGVycm9yRm9ybWF0dGVyOiBkZWZhdWx0Rm9ybWF0dGVyLFxuICAgIHRyYW5zZm9ybWVyOiBkZWZhdWx0VHJhbnNmb3JtZXJcbn07XG4vKipcbiAqIFJlc2VydmVkIHdvcmRzIHRoYXQgY2FuJ3QgYmUgdXNlZCBhcyByb3V0ZXIgb3IgcHJvY2VkdXJlIG5hbWVzXG4gKi8gY29uc3QgcmVzZXJ2ZWRXb3JkcyA9IFtcbiAgICAvKipcbiAgICogVGhlbiBpcyBhIHJlc2VydmVkIHdvcmQgYmVjYXVzZSBvdGhlcndpc2Ugd2UgY2FuJ3QgcmV0dXJuIGEgcHJvbWlzZSB0aGF0IHJldHVybnMgYSBQcm94eVxuICAgKiBzaW5jZSBKUyB3aWxsIHRoaW5rIHRoYXQgYC50aGVuYCBpcyBzb21ldGhpbmcgdGhhdCBleGlzdHNcbiAgICovICd0aGVuJ1xuXTtcbi8qKlxuICogQGludGVybmFsXG4gKi8gZnVuY3Rpb24gY3JlYXRlUm91dGVyRmFjdG9yeShjb25maWcpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlUm91dGVySW5uZXIocHJvY2VkdXJlcykge1xuICAgICAgICBjb25zdCByZXNlcnZlZFdvcmRzVXNlZCA9IG5ldyBTZXQoT2JqZWN0LmtleXMocHJvY2VkdXJlcykuZmlsdGVyKCh2KT0+cmVzZXJ2ZWRXb3Jkcy5pbmNsdWRlcyh2KSkpO1xuICAgICAgICBpZiAocmVzZXJ2ZWRXb3Jkc1VzZWQuc2l6ZSA+IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUmVzZXJ2ZWQgd29yZHMgdXNlZCBpbiBgcm91dGVyKHt9KWAgY2FsbDogJyArIEFycmF5LmZyb20ocmVzZXJ2ZWRXb3Jkc1VzZWQpLmpvaW4oJywgJykpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJvdXRlclByb2NlZHVyZXMgPSBvbWl0UHJvdG90eXBlKHt9KTtcbiAgICAgICAgZnVuY3Rpb24gcmVjdXJzaXZlR2V0UGF0aHMocHJvY2VkdXJlcywgcGF0aCA9ICcnKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHByb2NlZHVyZU9yUm91dGVyXSBvZiBPYmplY3QuZW50cmllcyhwcm9jZWR1cmVzID8/IHt9KSl7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3UGF0aCA9IGAke3BhdGh9JHtrZXl9YDtcbiAgICAgICAgICAgICAgICBpZiAoaXNSb3V0ZXIocHJvY2VkdXJlT3JSb3V0ZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlY3Vyc2l2ZUdldFBhdGhzKHByb2NlZHVyZU9yUm91dGVyLl9kZWYucHJvY2VkdXJlcywgYCR7bmV3UGF0aH0uYCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocm91dGVyUHJvY2VkdXJlc1tuZXdQYXRoXSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYER1cGxpY2F0ZSBrZXk6ICR7bmV3UGF0aH1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcm91dGVyUHJvY2VkdXJlc1tuZXdQYXRoXSA9IHByb2NlZHVyZU9yUm91dGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlY3Vyc2l2ZUdldFBhdGhzKHByb2NlZHVyZXMpO1xuICAgICAgICBjb25zdCBfZGVmID0ge1xuICAgICAgICAgICAgX2NvbmZpZzogY29uZmlnLFxuICAgICAgICAgICAgcm91dGVyOiB0cnVlLFxuICAgICAgICAgICAgcHJvY2VkdXJlczogcm91dGVyUHJvY2VkdXJlcyxcbiAgICAgICAgICAgIC4uLmVtcHR5Um91dGVyLFxuICAgICAgICAgICAgcmVjb3JkOiBwcm9jZWR1cmVzLFxuICAgICAgICAgICAgcXVlcmllczogT2JqZWN0LmVudHJpZXMocm91dGVyUHJvY2VkdXJlcykuZmlsdGVyKChwYWlyKT0+cGFpclsxXS5fZGVmLnF1ZXJ5KS5yZWR1Y2UoKGFjYywgW2tleSwgdmFsXSk9Pih7XG4gICAgICAgICAgICAgICAgICAgIC4uLmFjYyxcbiAgICAgICAgICAgICAgICAgICAgW2tleV06IHZhbFxuICAgICAgICAgICAgICAgIH0pLCB7fSksXG4gICAgICAgICAgICBtdXRhdGlvbnM6IE9iamVjdC5lbnRyaWVzKHJvdXRlclByb2NlZHVyZXMpLmZpbHRlcigocGFpcik9PnBhaXJbMV0uX2RlZi5tdXRhdGlvbikucmVkdWNlKChhY2MsIFtrZXksIHZhbF0pPT4oe1xuICAgICAgICAgICAgICAgICAgICAuLi5hY2MsXG4gICAgICAgICAgICAgICAgICAgIFtrZXldOiB2YWxcbiAgICAgICAgICAgICAgICB9KSwge30pLFxuICAgICAgICAgICAgc3Vic2NyaXB0aW9uczogT2JqZWN0LmVudHJpZXMocm91dGVyUHJvY2VkdXJlcykuZmlsdGVyKChwYWlyKT0+cGFpclsxXS5fZGVmLnN1YnNjcmlwdGlvbikucmVkdWNlKChhY2MsIFtrZXksIHZhbF0pPT4oe1xuICAgICAgICAgICAgICAgICAgICAuLi5hY2MsXG4gICAgICAgICAgICAgICAgICAgIFtrZXldOiB2YWxcbiAgICAgICAgICAgICAgICB9KSwge30pXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJvdXRlciA9IHtcbiAgICAgICAgICAgIC4uLnByb2NlZHVyZXMsXG4gICAgICAgICAgICBfZGVmLFxuICAgICAgICAgICAgY3JlYXRlQ2FsbGVyIChjdHgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ2FsbGVyRmFjdG9yeSgpKHJvdXRlcikoY3R4KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRFcnJvclNoYXBlIChvcHRzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBwYXRoICwgZXJyb3IgIH0gPSBvcHRzO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgY29kZSAgfSA9IG9wdHMuZXJyb3I7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2hhcGUgPSB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFRSUENfRVJST1JfQ09ERVNfQllfS0VZW2NvZGVdLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaHR0cFN0YXR1czogZ2V0SFRUUFN0YXR1c0NvZGVGcm9tRXJyb3IoZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmIChjb25maWcuaXNEZXYgJiYgdHlwZW9mIG9wdHMuZXJyb3Iuc3RhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHNoYXBlLmRhdGEuc3RhY2sgPSBvcHRzLmVycm9yLnN0YWNrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHBhdGggPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHNoYXBlLmRhdGEucGF0aCA9IHBhdGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZWYuX2NvbmZpZy5lcnJvckZvcm1hdHRlcih7XG4gICAgICAgICAgICAgICAgICAgIC4uLm9wdHMsXG4gICAgICAgICAgICAgICAgICAgIHNoYXBlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiByb3V0ZXI7XG4gICAgfTtcbn1cbi8qKlxuICogQGludGVybmFsXG4gKi8gZnVuY3Rpb24gY2FsbFByb2NlZHVyZShvcHRzKSB7XG4gICAgY29uc3QgeyB0eXBlICwgcGF0aCAgfSA9IG9wdHM7XG4gICAgaWYgKCEocGF0aCBpbiBvcHRzLnByb2NlZHVyZXMpIHx8ICFvcHRzLnByb2NlZHVyZXNbcGF0aF0/Ll9kZWZbdHlwZV0pIHtcbiAgICAgICAgdGhyb3cgbmV3IFRSUENFcnJvcih7XG4gICAgICAgICAgICBjb2RlOiAnTk9UX0ZPVU5EJyxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGBObyBcIiR7dHlwZX1cIi1wcm9jZWR1cmUgb24gcGF0aCBcIiR7cGF0aH1cImBcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IHByb2NlZHVyZSA9IG9wdHMucHJvY2VkdXJlc1twYXRoXTtcbiAgICByZXR1cm4gcHJvY2VkdXJlKG9wdHMpO1xufVxuZnVuY3Rpb24gY3JlYXRlQ2FsbGVyRmFjdG9yeSgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlQ2FsbGVySW5uZXIocm91dGVyKSB7XG4gICAgICAgIGNvbnN0IGRlZiA9IHJvdXRlci5fZGVmO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlQ2FsbGVyKGN0eCkge1xuICAgICAgICAgICAgY29uc3QgcHJveHkgPSBjcmVhdGVSZWN1cnNpdmVQcm94eSgoeyBwYXRoICwgYXJncyAgfSk9PntcbiAgICAgICAgICAgICAgICAvLyBpbnRlcm9wIG1vZGVcbiAgICAgICAgICAgICAgICBpZiAocGF0aC5sZW5ndGggPT09IDEgJiYgcHJvY2VkdXJlVHlwZXMuaW5jbHVkZXMocGF0aFswXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxQcm9jZWR1cmUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvY2VkdXJlczogZGVmLnByb2NlZHVyZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiBhcmdzWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmF3SW5wdXQ6IGFyZ3NbMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBwYXRoWzBdXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBmdWxsUGF0aCA9IHBhdGguam9pbignLicpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb2NlZHVyZSA9IGRlZi5wcm9jZWR1cmVzW2Z1bGxQYXRoXTtcbiAgICAgICAgICAgICAgICBsZXQgdHlwZSA9ICdxdWVyeSc7XG4gICAgICAgICAgICAgICAgaWYgKHByb2NlZHVyZS5fZGVmLm11dGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGUgPSAnbXV0YXRpb24nO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocHJvY2VkdXJlLl9kZWYuc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGUgPSAnc3Vic2NyaXB0aW9uJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb2NlZHVyZSh7XG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGZ1bGxQYXRoLFxuICAgICAgICAgICAgICAgICAgICByYXdJbnB1dDogYXJnc1swXSxcbiAgICAgICAgICAgICAgICAgICAgY3R4LFxuICAgICAgICAgICAgICAgICAgICB0eXBlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBwcm94eTtcbiAgICAgICAgfTtcbiAgICB9O1xufVxuXG4vKipcbiAqIFRoZSBkZWZhdWx0IGNoZWNrIHRvIHNlZSBpZiB3ZSdyZSBpbiBhIHNlcnZlclxuICovIGNvbnN0IGlzU2VydmVyRGVmYXVsdCA9IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8ICdEZW5vJyBpbiB3aW5kb3cgfHwgZ2xvYmFsVGhpcy5wcm9jZXNzPy5lbnY/Lk5PREVfRU5WID09PSAndGVzdCcgfHwgISFnbG9iYWxUaGlzLnByb2Nlc3M/LmVudj8uSkVTVF9XT1JLRVJfSUQgfHwgISFnbG9iYWxUaGlzLnByb2Nlc3M/LmVudj8uVklURVNUX1dPUktFUl9JRDtcblxuZXhwb3J0IHsgZGVmYXVsdFRyYW5zZm9ybWVyIGFzIGEsIGNyZWF0ZUNhbGxlckZhY3RvcnkgYXMgYiwgY3JlYXRlUm91dGVyRmFjdG9yeSBhcyBjLCBkZWZhdWx0Rm9ybWF0dGVyIGFzIGQsIGNhbGxQcm9jZWR1cmUgYXMgZSwgZ2V0RGF0YVRyYW5zZm9ybWVyIGFzIGcsIGlzU2VydmVyRGVmYXVsdCBhcyBpLCBwcm9jZWR1cmVUeXBlcyBhcyBwIH07XG4iLCJpbXBvcnQgeyBjIGFzIGNyZWF0ZVJvdXRlckZhY3RvcnksIGQgYXMgZGVmYXVsdEZvcm1hdHRlciwgYSBhcyBkZWZhdWx0VHJhbnNmb3JtZXIsIGcgYXMgZ2V0RGF0YVRyYW5zZm9ybWVyJDEsIGkgYXMgaXNTZXJ2ZXJEZWZhdWx0LCBiIGFzIGNyZWF0ZUNhbGxlckZhY3RvcnkgfSBmcm9tICcuL2NvbmZpZy1kNWZkYmQzOS5tanMnO1xuZXhwb3J0IHsgZSBhcyBjYWxsUHJvY2VkdXJlLCBiIGFzIGNyZWF0ZUNhbGxlckZhY3RvcnksIGEgYXMgZGVmYXVsdFRyYW5zZm9ybWVyLCBnIGFzIGdldERhdGFUcmFuc2Zvcm1lciwgcCBhcyBwcm9jZWR1cmVUeXBlcyB9IGZyb20gJy4vY29uZmlnLWQ1ZmRiZDM5Lm1qcyc7XG5pbXBvcnQgeyBUIGFzIFRSUENFcnJvciwgZyBhcyBnZXRUUlBDRXJyb3JGcm9tVW5rbm93biB9IGZyb20gJy4vVFJQQ0Vycm9yLTk4ZDQ0NzU4Lm1qcyc7XG5leHBvcnQgeyBUIGFzIFRSUENFcnJvciwgZyBhcyBnZXRUUlBDRXJyb3JGcm9tVW5rbm93biB9IGZyb20gJy4vVFJQQ0Vycm9yLTk4ZDQ0NzU4Lm1qcyc7XG5pbXBvcnQgeyBnIGFzIGdldEhUVFBTdGF0dXNDb2RlRnJvbUVycm9yLCBjIGFzIGNyZWF0ZUZsYXRQcm94eSB9IGZyb20gJy4vaW5kZXgtZjkxZDcyMGMubWpzJztcbmltcG9ydCB7IFQgYXMgVFJQQ19FUlJPUl9DT0RFU19CWV9LRVkgfSBmcm9tICcuL2NvZGVzLWM5MjRjM2RiLm1qcyc7XG5pbXBvcnQgJy4vZ2V0Q2F1c2VGcm9tVW5rbm93bi0yZDY2NDE0YS5tanMnO1xuXG4vKipcbiAqIEBkZXByZWNhdGVkXG4gKi8gY29uc3QgbWlkZGxld2FyZU1hcmtlciQxID0gJ21pZGRsZXdhcmVNYXJrZXInO1xuXG5mdW5jdGlvbiBnZXRQYXJzZUZuJDEocHJvY2VkdXJlUGFyc2VyKSB7XG4gICAgY29uc3QgcGFyc2VyID0gcHJvY2VkdXJlUGFyc2VyO1xuICAgIGlmICh0eXBlb2YgcGFyc2VyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIFByb2NlZHVyZVBhcnNlckN1c3RvbVZhbGlkYXRvckVzcXVlXG4gICAgICAgIHJldHVybiBwYXJzZXI7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcGFyc2VyLnBhcnNlQXN5bmMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gUHJvY2VkdXJlUGFyc2VyWm9kRXNxdWVcbiAgICAgICAgcmV0dXJuIHBhcnNlci5wYXJzZUFzeW5jLmJpbmQocGFyc2VyKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBwYXJzZXIucGFyc2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gUHJvY2VkdXJlUGFyc2VyWm9kRXNxdWVcbiAgICAgICAgcmV0dXJuIHBhcnNlci5wYXJzZS5iaW5kKHBhcnNlcik7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcGFyc2VyLnZhbGlkYXRlU3luYyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBQcm9jZWR1cmVQYXJzZXJZdXBFc3F1ZVxuICAgICAgICByZXR1cm4gcGFyc2VyLnZhbGlkYXRlU3luYy5iaW5kKHBhcnNlcik7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcGFyc2VyLmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBQcm9jZWR1cmVQYXJzZXJTdXBlcnN0cnVjdEVzcXVlXG4gICAgICAgIHJldHVybiBwYXJzZXIuY3JlYXRlLmJpbmQocGFyc2VyKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZmluZCBhIHZhbGlkYXRvciBmbicpO1xufVxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqIEBkZXByZWNhdGVkXG4gKi8gY2xhc3MgUHJvY2VkdXJlIHtcbiAgICBfZGVmKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWlkZGxld2FyZXM6IHRoaXMubWlkZGxld2FyZXMsXG4gICAgICAgICAgICByZXNvbHZlcjogdGhpcy5yZXNvbHZlcixcbiAgICAgICAgICAgIGlucHV0UGFyc2VyOiB0aGlzLmlucHV0UGFyc2VyLFxuICAgICAgICAgICAgb3V0cHV0UGFyc2VyOiB0aGlzLm91dHB1dFBhcnNlcixcbiAgICAgICAgICAgIG1ldGE6IHRoaXMubWV0YVxuICAgICAgICB9O1xuICAgIH1cbiAgICBhc3luYyBwYXJzZUlucHV0KHJhd0lucHV0KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wYXJzZUlucHV0Rm4ocmF3SW5wdXQpO1xuICAgICAgICB9IGNhdGNoIChjYXVzZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFRSUENFcnJvcih7XG4gICAgICAgICAgICAgICAgY29kZTogJ0JBRF9SRVFVRVNUJyxcbiAgICAgICAgICAgICAgICBjYXVzZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgcGFyc2VPdXRwdXQocmF3T3V0cHV0KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wYXJzZU91dHB1dEZuKHJhd091dHB1dCk7XG4gICAgICAgIH0gY2F0Y2ggKGNhdXNlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVFJQQ0Vycm9yKHtcbiAgICAgICAgICAgICAgICBjb2RlOiAnSU5URVJOQUxfU0VSVkVSX0VSUk9SJyxcbiAgICAgICAgICAgICAgICBjYXVzZSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnT3V0cHV0IHZhbGlkYXRpb24gZmFpbGVkJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAqIFRyaWdnZXIgbWlkZGxld2FyZXMgaW4gb3JkZXIsIHBhcnNlIHJhdyBpbnB1dCwgY2FsbCByZXNvbHZlciAmIHBhcnNlIHJhdyBvdXRwdXRcbiAgICogQGludGVybmFsXG4gICAqLyBhc3luYyBjYWxsKG9wdHMpIHtcbiAgICAgICAgLy8gd3JhcCB0aGUgYWN0dWFsIHJlc29sdmVyIGFuZCB0cmVhdCBhcyB0aGUgbGFzdCBcIm1pZGRsZXdhcmVcIlxuICAgICAgICBjb25zdCBtaWRkbGV3YXJlc1dpdGhSZXNvbHZlciA9IHRoaXMubWlkZGxld2FyZXMuY29uY2F0KFtcbiAgICAgICAgICAgIGFzeW5jICh7IGN0eCAgfSk9PntcbiAgICAgICAgICAgICAgICBjb25zdCBpbnB1dCA9IGF3YWl0IHRoaXMucGFyc2VJbnB1dChvcHRzLnJhd0lucHV0KTtcbiAgICAgICAgICAgICAgICBjb25zdCByYXdPdXRwdXQgPSBhd2FpdCB0aGlzLnJlc29sdmVyKHtcbiAgICAgICAgICAgICAgICAgICAgLi4ub3B0cyxcbiAgICAgICAgICAgICAgICAgICAgY3R4LFxuICAgICAgICAgICAgICAgICAgICBpbnB1dFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLnBhcnNlT3V0cHV0KHJhd091dHB1dCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbWFya2VyOiBtaWRkbGV3YXJlTWFya2VyJDEsXG4gICAgICAgICAgICAgICAgICAgIG9rOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgICAgICAgICBjdHhcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICBdKTtcbiAgICAgICAgLy8gcnVuIHRoZSBtaWRkbGV3YXJlcyByZWN1cnNpdmVseSB3aXRoIHRoZSByZXNvbHZlciBhcyB0aGUgbGFzdCBvbmVcbiAgICAgICAgY29uc3QgY2FsbFJlY3Vyc2l2ZSA9IGFzeW5jIChjYWxsT3B0cyA9IHtcbiAgICAgICAgICAgIGluZGV4OiAwLFxuICAgICAgICAgICAgY3R4OiBvcHRzLmN0eFxuICAgICAgICB9KT0+e1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IG1pZGRsZXdhcmVzV2l0aFJlc29sdmVyW2NhbGxPcHRzLmluZGV4XSh7XG4gICAgICAgICAgICAgICAgICAgIGN0eDogY2FsbE9wdHMuY3R4LFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBvcHRzLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IG9wdHMucGF0aCxcbiAgICAgICAgICAgICAgICAgICAgcmF3SW5wdXQ6IG9wdHMucmF3SW5wdXQsXG4gICAgICAgICAgICAgICAgICAgIG1ldGE6IHRoaXMubWV0YSxcbiAgICAgICAgICAgICAgICAgICAgbmV4dDogYXN5bmMgKG5leHRPcHRzKT0+e1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGNhbGxSZWN1cnNpdmUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBjYWxsT3B0cy5pbmRleCArIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4OiBuZXh0T3B0cyA/IG5leHRPcHRzLmN0eCA6IGNhbGxPcHRzLmN0eFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfSBjYXRjaCAoY2F1c2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBjdHg6IGNhbGxPcHRzLmN0eCxcbiAgICAgICAgICAgICAgICAgICAgb2s6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogZ2V0VFJQQ0Vycm9yRnJvbVVua25vd24oY2F1c2UpLFxuICAgICAgICAgICAgICAgICAgICBtYXJrZXI6IG1pZGRsZXdhcmVNYXJrZXIkMVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8vIHRoZXJlJ3MgYWx3YXlzIGF0IGxlYXN0IG9uZSBcIm5leHRcIiBzaW5jZSB3ZSB3cmFwIHRoaXMucmVzb2x2ZXIgaW4gYSBtaWRkbGV3YXJlXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNhbGxSZWN1cnNpdmUoKTtcbiAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUUlBDRXJyb3Ioe1xuICAgICAgICAgICAgICAgIGNvZGU6ICdJTlRFUk5BTF9TRVJWRVJfRVJST1InLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdObyByZXN1bHQgZnJvbSBtaWRkbGV3YXJlcyAtIGRpZCB5b3UgZm9yZ2V0IHRvIGByZXR1cm4gbmV4dCgpYD8nXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJlc3VsdC5vaykge1xuICAgICAgICAgICAgLy8gcmUtdGhyb3cgb3JpZ2luYWwgZXJyb3JcbiAgICAgICAgICAgIHRocm93IHJlc3VsdC5lcnJvcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0LmRhdGE7XG4gICAgfVxuICAgIC8qKlxuICAgKiBDcmVhdGUgbmV3IHByb2NlZHVyZSB3aXRoIHBhc3NlZCBtaWRkbGV3YXJlc1xuICAgKiBAcGFyYW0gbWlkZGxld2FyZXNcbiAgICovIGluaGVyaXRNaWRkbGV3YXJlcyhtaWRkbGV3YXJlcykge1xuICAgICAgICBjb25zdCBDb25zdHJ1Y3RvciA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gbmV3IENvbnN0cnVjdG9yKHtcbiAgICAgICAgICAgIG1pZGRsZXdhcmVzOiBbXG4gICAgICAgICAgICAgICAgLi4ubWlkZGxld2FyZXMsXG4gICAgICAgICAgICAgICAgLi4udGhpcy5taWRkbGV3YXJlc1xuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIHJlc29sdmVyOiB0aGlzLnJlc29sdmVyLFxuICAgICAgICAgICAgaW5wdXRQYXJzZXI6IHRoaXMuaW5wdXRQYXJzZXIsXG4gICAgICAgICAgICBvdXRwdXRQYXJzZXI6IHRoaXMub3V0cHV0UGFyc2VyLFxuICAgICAgICAgICAgbWV0YTogdGhpcy5tZXRhXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKG9wdHMpe1xuICAgICAgICB0aGlzLm1pZGRsZXdhcmVzID0gb3B0cy5taWRkbGV3YXJlcztcbiAgICAgICAgdGhpcy5yZXNvbHZlciA9IG9wdHMucmVzb2x2ZXI7XG4gICAgICAgIHRoaXMuaW5wdXRQYXJzZXIgPSBvcHRzLmlucHV0UGFyc2VyO1xuICAgICAgICB0aGlzLnBhcnNlSW5wdXRGbiA9IGdldFBhcnNlRm4kMSh0aGlzLmlucHV0UGFyc2VyKTtcbiAgICAgICAgdGhpcy5vdXRwdXRQYXJzZXIgPSBvcHRzLm91dHB1dFBhcnNlcjtcbiAgICAgICAgdGhpcy5wYXJzZU91dHB1dEZuID0gZ2V0UGFyc2VGbiQxKHRoaXMub3V0cHV0UGFyc2VyKTtcbiAgICAgICAgdGhpcy5tZXRhID0gb3B0cy5tZXRhO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZVByb2NlZHVyZShvcHRzKSB7XG4gICAgY29uc3QgaW5wdXRQYXJzZXIgPSAnaW5wdXQnIGluIG9wdHMgPyBvcHRzLmlucHV0IDogKGlucHV0KT0+e1xuICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFRSUENFcnJvcih7XG4gICAgICAgICAgICAgICAgY29kZTogJ0JBRF9SRVFVRVNUJyxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnTm8gaW5wdXQgZXhwZWN0ZWQnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH07XG4gICAgY29uc3Qgb3V0cHV0UGFyc2VyID0gJ291dHB1dCcgaW4gb3B0cyAmJiBvcHRzLm91dHB1dCA/IG9wdHMub3V0cHV0IDogKG91dHB1dCk9Pm91dHB1dDtcbiAgICByZXR1cm4gbmV3IFByb2NlZHVyZSh7XG4gICAgICAgIGlucHV0UGFyc2VyOiBpbnB1dFBhcnNlcixcbiAgICAgICAgcmVzb2x2ZXI6IG9wdHMucmVzb2x2ZSxcbiAgICAgICAgbWlkZGxld2FyZXM6IFtdLFxuICAgICAgICBvdXRwdXRQYXJzZXI6IG91dHB1dFBhcnNlcixcbiAgICAgICAgbWV0YTogb3B0cy5tZXRhXG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldFBhcnNlRm4ocHJvY2VkdXJlUGFyc2VyKSB7XG4gICAgY29uc3QgcGFyc2VyID0gcHJvY2VkdXJlUGFyc2VyO1xuICAgIGlmICh0eXBlb2YgcGFyc2VyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIFBhcnNlckN1c3RvbVZhbGlkYXRvckVzcXVlXG4gICAgICAgIHJldHVybiBwYXJzZXI7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcGFyc2VyLnBhcnNlQXN5bmMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gUGFyc2VyWm9kRXNxdWVcbiAgICAgICAgcmV0dXJuIHBhcnNlci5wYXJzZUFzeW5jLmJpbmQocGFyc2VyKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBwYXJzZXIucGFyc2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gUGFyc2VyWm9kRXNxdWVcbiAgICAgICAgLy8gUGFyc2VyVmFsaWJvdEVzcXVlICg8PSB2MC4xMi5YKVxuICAgICAgICByZXR1cm4gcGFyc2VyLnBhcnNlLmJpbmQocGFyc2VyKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBwYXJzZXIudmFsaWRhdGVTeW5jID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIFBhcnNlcll1cEVzcXVlXG4gICAgICAgIHJldHVybiBwYXJzZXIudmFsaWRhdGVTeW5jLmJpbmQocGFyc2VyKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBwYXJzZXIuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIFBhcnNlclN1cGVyc3RydWN0RXNxdWVcbiAgICAgICAgcmV0dXJuIHBhcnNlci5jcmVhdGUuYmluZChwYXJzZXIpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHBhcnNlci5hc3NlcnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gUGFyc2VyU2NhbGVFc3F1ZVxuICAgICAgICByZXR1cm4gKHZhbHVlKT0+e1xuICAgICAgICAgICAgcGFyc2VyLmFzc2VydCh2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGZpbmQgYSB2YWxpZGF0b3IgZm4nKTtcbn1cbi8qKlxuICogQGRlcHJlY2F0ZWQgb25seSBmb3IgYmFja3dhcmRzIGNvbXBhdFxuICogQGludGVybmFsXG4gKi8gZnVuY3Rpb24gZ2V0UGFyc2VGbk9yUGFzc1Rocm91Z2gocHJvY2VkdXJlUGFyc2VyKSB7XG4gICAgaWYgKCFwcm9jZWR1cmVQYXJzZXIpIHtcbiAgICAgICAgcmV0dXJuICh2KT0+djtcbiAgICB9XG4gICAgcmV0dXJuIGdldFBhcnNlRm4ocHJvY2VkdXJlUGFyc2VyKTtcbn1cblxuLyoqXG4gKiBFbnN1cmVzIHRoZXJlIGFyZSBubyBkdXBsaWNhdGUga2V5cyB3aGVuIGJ1aWxkaW5nIGEgcHJvY2VkdXJlLlxuICovIGZ1bmN0aW9uIG1lcmdlV2l0aG91dE92ZXJyaWRlcyhvYmoxLCAuLi5vYmpzKSB7XG4gICAgY29uc3QgbmV3T2JqID0gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG51bGwpLCBvYmoxKTtcbiAgICBmb3IgKGNvbnN0IG92ZXJyaWRlcyBvZiBvYmpzKXtcbiAgICAgICAgZm9yKGNvbnN0IGtleSBpbiBvdmVycmlkZXMpe1xuICAgICAgICAgICAgaWYgKGtleSBpbiBuZXdPYmogJiYgbmV3T2JqW2tleV0gIT09IG92ZXJyaWRlc1trZXldKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEdXBsaWNhdGUga2V5ICR7a2V5fWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3T2JqW2tleV0gPSBvdmVycmlkZXNba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3T2JqO1xufVxuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovIGZ1bmN0aW9uIGNyZWF0ZU1pZGRsZXdhcmVGYWN0b3J5KCkge1xuICAgIGZ1bmN0aW9uIGNyZWF0ZU1pZGRsZXdhcmVJbm5lcihtaWRkbGV3YXJlcykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgX21pZGRsZXdhcmVzOiBtaWRkbGV3YXJlcyxcbiAgICAgICAgICAgIHVuc3RhYmxlX3BpcGUgKG1pZGRsZXdhcmVCdWlsZGVyT3JGbikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBpcGVkTWlkZGxld2FyZSA9ICdfbWlkZGxld2FyZXMnIGluIG1pZGRsZXdhcmVCdWlsZGVyT3JGbiA/IG1pZGRsZXdhcmVCdWlsZGVyT3JGbi5fbWlkZGxld2FyZXMgOiBbXG4gICAgICAgICAgICAgICAgICAgIG1pZGRsZXdhcmVCdWlsZGVyT3JGblxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZU1pZGRsZXdhcmVJbm5lcihbXG4gICAgICAgICAgICAgICAgICAgIC4uLm1pZGRsZXdhcmVzLFxuICAgICAgICAgICAgICAgICAgICAuLi5waXBlZE1pZGRsZXdhcmVcbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlTWlkZGxld2FyZShmbikge1xuICAgICAgICByZXR1cm4gY3JlYXRlTWlkZGxld2FyZUlubmVyKFtcbiAgICAgICAgICAgIGZuXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlTWlkZGxld2FyZTtcbn1cbmNvbnN0IGV4cGVyaW1lbnRhbF9zdGFuZGFsb25lTWlkZGxld2FyZSA9ICgpPT4oe1xuICAgICAgICBjcmVhdGU6IGNyZWF0ZU1pZGRsZXdhcmVGYWN0b3J5KClcbiAgICB9KTtcbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3Qob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShvYmopO1xufVxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqIFBsZWFzZSBub3RlLCBgdHJwYy1vcGVuYXBpYCB1c2VzIHRoaXMgZnVuY3Rpb24uXG4gKi8gZnVuY3Rpb24gY3JlYXRlSW5wdXRNaWRkbGV3YXJlKHBhcnNlKSB7XG4gICAgY29uc3QgaW5wdXRNaWRkbGV3YXJlID0gYXN5bmMgKHsgbmV4dCAsIHJhd0lucHV0ICwgaW5wdXQgLCAgfSk9PntcbiAgICAgICAgbGV0IHBhcnNlZElucHV0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcGFyc2VkSW5wdXQgPSBhd2FpdCBwYXJzZShyYXdJbnB1dCk7XG4gICAgICAgIH0gY2F0Y2ggKGNhdXNlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVFJQQ0Vycm9yKHtcbiAgICAgICAgICAgICAgICBjb2RlOiAnQkFEX1JFUVVFU1QnLFxuICAgICAgICAgICAgICAgIGNhdXNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBNdWx0aXBsZSBpbnB1dCBwYXJzZXJzXG4gICAgICAgIGNvbnN0IGNvbWJpbmVkSW5wdXQgPSBpc1BsYWluT2JqZWN0KGlucHV0KSAmJiBpc1BsYWluT2JqZWN0KHBhcnNlZElucHV0KSA/IHtcbiAgICAgICAgICAgIC4uLmlucHV0LFxuICAgICAgICAgICAgLi4ucGFyc2VkSW5wdXRcbiAgICAgICAgfSA6IHBhcnNlZElucHV0O1xuICAgICAgICAvLyBUT0RPIGZpeCB0aGlzIHR5cGluZz9cbiAgICAgICAgcmV0dXJuIG5leHQoe1xuICAgICAgICAgICAgaW5wdXQ6IGNvbWJpbmVkSW5wdXRcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBpbnB1dE1pZGRsZXdhcmUuX3R5cGUgPSAnaW5wdXQnO1xuICAgIHJldHVybiBpbnB1dE1pZGRsZXdhcmU7XG59XG4vKipcbiAqIEBpbnRlcm5hbFxuICovIGZ1bmN0aW9uIGNyZWF0ZU91dHB1dE1pZGRsZXdhcmUocGFyc2UpIHtcbiAgICBjb25zdCBvdXRwdXRNaWRkbGV3YXJlID0gYXN5bmMgKHsgbmV4dCAgfSk9PntcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbmV4dCgpO1xuICAgICAgICBpZiAoIXJlc3VsdC5vaykge1xuICAgICAgICAgICAgLy8gcGFzcyB0aHJvdWdoIGZhaWx1cmVzIHdpdGhvdXQgdmFsaWRhdGluZ1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHBhcnNlKHJlc3VsdC5kYXRhKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLi4ucmVzdWx0LFxuICAgICAgICAgICAgICAgIGRhdGFcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gY2F0Y2ggKGNhdXNlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVFJQQ0Vycm9yKHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnT3V0cHV0IHZhbGlkYXRpb24gZmFpbGVkJyxcbiAgICAgICAgICAgICAgICBjb2RlOiAnSU5URVJOQUxfU0VSVkVSX0VSUk9SJyxcbiAgICAgICAgICAgICAgICBjYXVzZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIG91dHB1dE1pZGRsZXdhcmUuX3R5cGUgPSAnb3V0cHV0JztcbiAgICByZXR1cm4gb3V0cHV0TWlkZGxld2FyZTtcbn1cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqLyBjb25zdCBtaWRkbGV3YXJlTWFya2VyID0gJ21pZGRsZXdhcmVNYXJrZXInO1xuXG5mdW5jdGlvbiBjcmVhdGVOZXdCdWlsZGVyKGRlZjEsIGRlZjIpIHtcbiAgICBjb25zdCB7IG1pZGRsZXdhcmVzID1bXSAsIGlucHV0cyAsIG1ldGEgLCAuLi5yZXN0IH0gPSBkZWYyO1xuICAgIC8vIFRPRE86IG1heWJlIGhhdmUgYSBmbiBoZXJlIHRvIHdhcm4gYWJvdXQgY2FsbHNcbiAgICByZXR1cm4gY3JlYXRlQnVpbGRlcih7XG4gICAgICAgIC4uLm1lcmdlV2l0aG91dE92ZXJyaWRlcyhkZWYxLCByZXN0KSxcbiAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICAuLi5kZWYxLmlucHV0cyxcbiAgICAgICAgICAgIC4uLmlucHV0cyA/PyBbXVxuICAgICAgICBdLFxuICAgICAgICBtaWRkbGV3YXJlczogW1xuICAgICAgICAgICAgLi4uZGVmMS5taWRkbGV3YXJlcyxcbiAgICAgICAgICAgIC4uLm1pZGRsZXdhcmVzXG4gICAgICAgIF0sXG4gICAgICAgIG1ldGE6IGRlZjEubWV0YSAmJiBtZXRhID8ge1xuICAgICAgICAgICAgLi4uZGVmMS5tZXRhLFxuICAgICAgICAgICAgLi4ubWV0YVxuICAgICAgICB9IDogbWV0YSA/PyBkZWYxLm1ldGFcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUJ1aWxkZXIoaW5pdERlZiA9IHt9KSB7XG4gICAgY29uc3QgX2RlZiA9IHtcbiAgICAgICAgaW5wdXRzOiBbXSxcbiAgICAgICAgbWlkZGxld2FyZXM6IFtdLFxuICAgICAgICAuLi5pbml0RGVmXG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgICBfZGVmLFxuICAgICAgICBpbnB1dCAoaW5wdXQpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlciA9IGdldFBhcnNlRm4oaW5wdXQpO1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZU5ld0J1aWxkZXIoX2RlZiwge1xuICAgICAgICAgICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAgICAgICAgICBpbnB1dFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgbWlkZGxld2FyZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlSW5wdXRNaWRkbGV3YXJlKHBhcnNlcilcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgb3V0cHV0IChvdXRwdXQpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlT3V0cHV0ID0gZ2V0UGFyc2VGbihvdXRwdXQpO1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZU5ld0J1aWxkZXIoX2RlZiwge1xuICAgICAgICAgICAgICAgIG91dHB1dCxcbiAgICAgICAgICAgICAgICBtaWRkbGV3YXJlczogW1xuICAgICAgICAgICAgICAgICAgICBjcmVhdGVPdXRwdXRNaWRkbGV3YXJlKHBhcnNlT3V0cHV0KVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBtZXRhIChtZXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlTmV3QnVpbGRlcihfZGVmLCB7XG4gICAgICAgICAgICAgICAgbWV0YTogbWV0YVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICogVGhpcyBmdW5jdGlvbmFsaXR5IGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uLlxuICAgICAqLyB1bnN0YWJsZV9jb25jYXQgKGJ1aWxkZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVOZXdCdWlsZGVyKF9kZWYsIGJ1aWxkZXIuX2RlZik7XG4gICAgICAgIH0sXG4gICAgICAgIHVzZSAobWlkZGxld2FyZUJ1aWxkZXJPckZuKSB7XG4gICAgICAgICAgICAvLyBEaXN0aW5ndWlzaCBiZXR3ZWVuIGEgbWlkZGxld2FyZSBidWlsZGVyIGFuZCBhIG1pZGRsZXdhcmUgZnVuY3Rpb25cbiAgICAgICAgICAgIGNvbnN0IG1pZGRsZXdhcmVzID0gJ19taWRkbGV3YXJlcycgaW4gbWlkZGxld2FyZUJ1aWxkZXJPckZuID8gbWlkZGxld2FyZUJ1aWxkZXJPckZuLl9taWRkbGV3YXJlcyA6IFtcbiAgICAgICAgICAgICAgICBtaWRkbGV3YXJlQnVpbGRlck9yRm5cbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlTmV3QnVpbGRlcihfZGVmLCB7XG4gICAgICAgICAgICAgICAgbWlkZGxld2FyZXM6IG1pZGRsZXdhcmVzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgcXVlcnkgKHJlc29sdmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlUmVzb2x2ZXIoe1xuICAgICAgICAgICAgICAgIC4uLl9kZWYsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHRydWVcbiAgICAgICAgICAgIH0sIHJlc29sdmVyKTtcbiAgICAgICAgfSxcbiAgICAgICAgbXV0YXRpb24gKHJlc29sdmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlUmVzb2x2ZXIoe1xuICAgICAgICAgICAgICAgIC4uLl9kZWYsXG4gICAgICAgICAgICAgICAgbXV0YXRpb246IHRydWVcbiAgICAgICAgICAgIH0sIHJlc29sdmVyKTtcbiAgICAgICAgfSxcbiAgICAgICAgc3Vic2NyaXB0aW9uIChyZXNvbHZlcikge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVJlc29sdmVyKHtcbiAgICAgICAgICAgICAgICAuLi5fZGVmLFxuICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbjogdHJ1ZVxuICAgICAgICAgICAgfSwgcmVzb2x2ZXIpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJlc29sdmVyKF9kZWYsIHJlc29sdmVyKSB7XG4gICAgY29uc3QgZmluYWxCdWlsZGVyID0gY3JlYXRlTmV3QnVpbGRlcihfZGVmLCB7XG4gICAgICAgIHJlc29sdmVyLFxuICAgICAgICBtaWRkbGV3YXJlczogW1xuICAgICAgICAgICAgYXN5bmMgZnVuY3Rpb24gcmVzb2x2ZU1pZGRsZXdhcmUob3B0cykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNvbHZlcihvcHRzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBtYXJrZXI6IG1pZGRsZXdhcmVNYXJrZXIsXG4gICAgICAgICAgICAgICAgICAgIG9rOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgICAgICAgICBjdHg6IG9wdHMuY3R4XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgIH0pO1xuICAgIHJldHVybiBjcmVhdGVQcm9jZWR1cmVDYWxsZXIoZmluYWxCdWlsZGVyLl9kZWYpO1xufVxuY29uc3QgY29kZWJsb2NrID0gYFxuVGhpcyBpcyBhIGNsaWVudC1vbmx5IGZ1bmN0aW9uLlxuSWYgeW91IHdhbnQgdG8gY2FsbCB0aGlzIGZ1bmN0aW9uIG9uIHRoZSBzZXJ2ZXIsIHNlZSBodHRwczovL3RycGMuaW8vZG9jcy9zZXJ2ZXIvc2VydmVyLXNpZGUtY2FsbHNcbmAudHJpbSgpO1xuZnVuY3Rpb24gY3JlYXRlUHJvY2VkdXJlQ2FsbGVyKF9kZWYpIHtcbiAgICBjb25zdCBwcm9jZWR1cmUgPSBhc3luYyBmdW5jdGlvbiByZXNvbHZlKG9wdHMpIHtcbiAgICAgICAgLy8gaXMgZGlyZWN0IHNlcnZlci1zaWRlIGNhbGxcbiAgICAgICAgaWYgKCFvcHRzIHx8ICEoJ3Jhd0lucHV0JyBpbiBvcHRzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGNvZGVibG9jayk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcnVuIHRoZSBtaWRkbGV3YXJlcyByZWN1cnNpdmVseSB3aXRoIHRoZSByZXNvbHZlciBhcyB0aGUgbGFzdCBvbmVcbiAgICAgICAgY29uc3QgY2FsbFJlY3Vyc2l2ZSA9IGFzeW5jIChjYWxsT3B0cyA9IHtcbiAgICAgICAgICAgIGluZGV4OiAwLFxuICAgICAgICAgICAgY3R4OiBvcHRzLmN0eFxuICAgICAgICB9KT0+e1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgICAgIGNvbnN0IG1pZGRsZXdhcmUgPSBfZGVmLm1pZGRsZXdhcmVzW2NhbGxPcHRzLmluZGV4XTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBtaWRkbGV3YXJlKHtcbiAgICAgICAgICAgICAgICAgICAgY3R4OiBjYWxsT3B0cy5jdHgsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IG9wdHMudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogb3B0cy5wYXRoLFxuICAgICAgICAgICAgICAgICAgICByYXdJbnB1dDogY2FsbE9wdHMucmF3SW5wdXQgPz8gb3B0cy5yYXdJbnB1dCxcbiAgICAgICAgICAgICAgICAgICAgbWV0YTogX2RlZi5tZXRhLFxuICAgICAgICAgICAgICAgICAgICBpbnB1dDogY2FsbE9wdHMuaW5wdXQsXG4gICAgICAgICAgICAgICAgICAgIG5leHQgKF9uZXh0T3B0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV4dE9wdHMgPSBfbmV4dE9wdHM7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbFJlY3Vyc2l2ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGNhbGxPcHRzLmluZGV4ICsgMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHg6IG5leHRPcHRzICYmICdjdHgnIGluIG5leHRPcHRzID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5jYWxsT3B0cy5jdHgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLm5leHRPcHRzLmN0eFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gOiBjYWxsT3B0cy5jdHgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQ6IG5leHRPcHRzICYmICdpbnB1dCcgaW4gbmV4dE9wdHMgPyBuZXh0T3B0cy5pbnB1dCA6IGNhbGxPcHRzLmlucHV0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhd0lucHV0OiBuZXh0T3B0cyAmJiAncmF3SW5wdXQnIGluIG5leHRPcHRzID8gbmV4dE9wdHMucmF3SW5wdXQgOiBjYWxsT3B0cy5yYXdJbnB1dFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfSBjYXRjaCAoY2F1c2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBvazogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBnZXRUUlBDRXJyb3JGcm9tVW5rbm93bihjYXVzZSksXG4gICAgICAgICAgICAgICAgICAgIG1hcmtlcjogbWlkZGxld2FyZU1hcmtlclxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8vIHRoZXJlJ3MgYWx3YXlzIGF0IGxlYXN0IG9uZSBcIm5leHRcIiBzaW5jZSB3ZSB3cmFwIHRoaXMucmVzb2x2ZXIgaW4gYSBtaWRkbGV3YXJlXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNhbGxSZWN1cnNpdmUoKTtcbiAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUUlBDRXJyb3Ioe1xuICAgICAgICAgICAgICAgIGNvZGU6ICdJTlRFUk5BTF9TRVJWRVJfRVJST1InLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdObyByZXN1bHQgZnJvbSBtaWRkbGV3YXJlcyAtIGRpZCB5b3UgZm9yZ2V0IHRvIGByZXR1cm4gbmV4dCgpYD8nXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJlc3VsdC5vaykge1xuICAgICAgICAgICAgLy8gcmUtdGhyb3cgb3JpZ2luYWwgZXJyb3JcbiAgICAgICAgICAgIHRocm93IHJlc3VsdC5lcnJvcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0LmRhdGE7XG4gICAgfTtcbiAgICBwcm9jZWR1cmUuX2RlZiA9IF9kZWY7XG4gICAgcHJvY2VkdXJlLm1ldGEgPSBfZGVmLm1ldGE7XG4gICAgcmV0dXJuIHByb2NlZHVyZTtcbn1cblxuZnVuY3Rpb24gbWlncmF0ZVByb2NlZHVyZShvbGRQcm9jLCB0eXBlKSB7XG4gICAgY29uc3QgZGVmID0gb2xkUHJvYy5fZGVmKCk7XG4gICAgY29uc3QgaW5wdXRQYXJzZXIgPSBnZXRQYXJzZUZuT3JQYXNzVGhyb3VnaChkZWYuaW5wdXRQYXJzZXIpO1xuICAgIGNvbnN0IG91dHB1dFBhcnNlciA9IGdldFBhcnNlRm5PclBhc3NUaHJvdWdoKGRlZi5vdXRwdXRQYXJzZXIpO1xuICAgIGNvbnN0IGlucHV0TWlkZGxld2FyZSA9IGNyZWF0ZUlucHV0TWlkZGxld2FyZShpbnB1dFBhcnNlcik7XG4gICAgY29uc3QgYnVpbGRlciA9IGNyZWF0ZUJ1aWxkZXIoe1xuICAgICAgICBpbnB1dHM6IFtcbiAgICAgICAgICAgIGRlZi5pbnB1dFBhcnNlclxuICAgICAgICBdLFxuICAgICAgICBtaWRkbGV3YXJlczogW1xuICAgICAgICAgICAgLi4uZGVmLm1pZGRsZXdhcmVzLFxuICAgICAgICAgICAgaW5wdXRNaWRkbGV3YXJlLFxuICAgICAgICAgICAgY3JlYXRlT3V0cHV0TWlkZGxld2FyZShvdXRwdXRQYXJzZXIpXG4gICAgICAgIF0sXG4gICAgICAgIG1ldGE6IGRlZi5tZXRhLFxuICAgICAgICBvdXRwdXQ6IGRlZi5vdXRwdXRQYXJzZXIsXG4gICAgICAgIG11dGF0aW9uOiB0eXBlID09PSAnbXV0YXRpb24nLFxuICAgICAgICBxdWVyeTogdHlwZSA9PT0gJ3F1ZXJ5JyxcbiAgICAgICAgc3Vic2NyaXB0aW9uOiB0eXBlID09PSAnc3Vic2NyaXB0aW9uJ1xuICAgIH0pO1xuICAgIGNvbnN0IHByb2MgPSBidWlsZGVyW3R5cGVdKChvcHRzKT0+ZGVmLnJlc29sdmVyKG9wdHMpKTtcbiAgICByZXR1cm4gcHJvYztcbn1cbmZ1bmN0aW9uIG1pZ3JhdGVSb3V0ZXIob2xkUm91dGVyKSB7XG4gICAgY29uc3QgZXJyb3JGb3JtYXR0ZXIgPSBvbGRSb3V0ZXIuX2RlZi5lcnJvckZvcm1hdHRlcjtcbiAgICBjb25zdCB0cmFuc2Zvcm1lciA9IG9sZFJvdXRlci5fZGVmLnRyYW5zZm9ybWVyO1xuICAgIGNvbnN0IHF1ZXJpZXMgPSB7fTtcbiAgICBjb25zdCBtdXRhdGlvbnMgPSB7fTtcbiAgICBjb25zdCBzdWJzY3JpcHRpb25zID0ge307XG4gICAgZm9yIChjb25zdCBbbmFtZSwgcHJvY2VkdXJlXSBvZiBPYmplY3QuZW50cmllcyhvbGRSb3V0ZXIuX2RlZi5xdWVyaWVzKSl7XG4gICAgICAgIHF1ZXJpZXNbbmFtZV0gPSBtaWdyYXRlUHJvY2VkdXJlKHByb2NlZHVyZSwgJ3F1ZXJ5Jyk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgW25hbWUxLCBwcm9jZWR1cmUxXSBvZiBPYmplY3QuZW50cmllcyhvbGRSb3V0ZXIuX2RlZi5tdXRhdGlvbnMpKXtcbiAgICAgICAgbXV0YXRpb25zW25hbWUxXSA9IG1pZ3JhdGVQcm9jZWR1cmUocHJvY2VkdXJlMSwgJ211dGF0aW9uJyk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgW25hbWUyLCBwcm9jZWR1cmUyXSBvZiBPYmplY3QuZW50cmllcyhvbGRSb3V0ZXIuX2RlZi5zdWJzY3JpcHRpb25zKSl7XG4gICAgICAgIHN1YnNjcmlwdGlvbnNbbmFtZTJdID0gbWlncmF0ZVByb2NlZHVyZShwcm9jZWR1cmUyLCAnc3Vic2NyaXB0aW9uJyk7XG4gICAgfVxuICAgIGNvbnN0IHByb2NlZHVyZXMgPSBtZXJnZVdpdGhvdXRPdmVycmlkZXMocXVlcmllcywgbXV0YXRpb25zLCBzdWJzY3JpcHRpb25zKTtcbiAgICBjb25zdCBuZXdSb3V0ZXIgPSBjcmVhdGVSb3V0ZXJGYWN0b3J5KHtcbiAgICAgICAgdHJhbnNmb3JtZXIsXG4gICAgICAgIGVycm9yRm9ybWF0dGVyLFxuICAgICAgICBpc0RldjogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJ1xuICAgIH0pKHByb2NlZHVyZXMpO1xuICAgIHJldHVybiBuZXdSb3V0ZXI7XG59XG5cbmZ1bmN0aW9uIGdldERhdGFUcmFuc2Zvcm1lcih0cmFuc2Zvcm1lcikge1xuICAgIGlmICgnaW5wdXQnIGluIHRyYW5zZm9ybWVyKSB7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1lcjtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaW5wdXQ6IHRyYW5zZm9ybWVyLFxuICAgICAgICBvdXRwdXQ6IHRyYW5zZm9ybWVyXG4gICAgfTtcbn1cbmNvbnN0IFBST0NFRFVSRV9ERUZJTklUSU9OX01BUCA9IHtcbiAgICBxdWVyeTogJ3F1ZXJpZXMnLFxuICAgIG11dGF0aW9uOiAnbXV0YXRpb25zJyxcbiAgICBzdWJzY3JpcHRpb246ICdzdWJzY3JpcHRpb25zJ1xufTtcbmZ1bmN0aW9uIHNhZmVPYmplY3QoLi4uYXJncykge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUobnVsbCksIC4uLmFyZ3MpO1xufVxuLyoqXG4gKiBAaW50ZXJuYWwgVGhlIHR5cGUgc2lnbmF0dXJlIG9mIHRoaXMgY2xhc3MgbWF5IGNoYW5nZSB3aXRob3V0IHdhcm5pbmcuXG4gKiBAZGVwcmVjYXRlZFxuICovIGNsYXNzIFJvdXRlciB7XG4gICAgc3RhdGljIHByZWZpeFByb2NlZHVyZXMocHJvY2VkdXJlcywgcHJlZml4KSB7XG4gICAgICAgIGNvbnN0IGVwcyA9IHNhZmVPYmplY3QoKTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCBwcm9jZWR1cmVdIG9mIE9iamVjdC5lbnRyaWVzKHByb2NlZHVyZXMpKXtcbiAgICAgICAgICAgIGVwc1twcmVmaXggKyBrZXldID0gcHJvY2VkdXJlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlcHM7XG4gICAgfVxuICAgIHF1ZXJ5KHBhdGgsIHByb2NlZHVyZSkge1xuICAgICAgICBjb25zdCByb3V0ZXIgPSBuZXcgUm91dGVyKHtcbiAgICAgICAgICAgIHF1ZXJpZXM6IHNhZmVPYmplY3Qoe1xuICAgICAgICAgICAgICAgIFtwYXRoXTogY3JlYXRlUHJvY2VkdXJlKHByb2NlZHVyZSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5tZXJnZShyb3V0ZXIpO1xuICAgIH1cbiAgICBtdXRhdGlvbihwYXRoLCBwcm9jZWR1cmUpIHtcbiAgICAgICAgY29uc3Qgcm91dGVyID0gbmV3IFJvdXRlcih7XG4gICAgICAgICAgICBtdXRhdGlvbnM6IHNhZmVPYmplY3Qoe1xuICAgICAgICAgICAgICAgIFtwYXRoXTogY3JlYXRlUHJvY2VkdXJlKHByb2NlZHVyZSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5tZXJnZShyb3V0ZXIpO1xuICAgIH1cbiAgICBzdWJzY3JpcHRpb24ocGF0aCwgcHJvY2VkdXJlKSB7XG4gICAgICAgIGNvbnN0IHJvdXRlciA9IG5ldyBSb3V0ZXIoe1xuICAgICAgICAgICAgc3Vic2NyaXB0aW9uczogc2FmZU9iamVjdCh7XG4gICAgICAgICAgICAgICAgW3BhdGhdOiBjcmVhdGVQcm9jZWR1cmUocHJvY2VkdXJlKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLm1lcmdlKHJvdXRlcik7XG4gICAgfVxuICAgIG1lcmdlKHByZWZpeE9yUm91dGVyLCBtYXliZVJvdXRlcikge1xuICAgICAgICBsZXQgcHJlZml4ID0gJyc7XG4gICAgICAgIGxldCBjaGlsZFJvdXRlcjtcbiAgICAgICAgaWYgKHR5cGVvZiBwcmVmaXhPclJvdXRlciA9PT0gJ3N0cmluZycgJiYgbWF5YmVSb3V0ZXIgaW5zdGFuY2VvZiBSb3V0ZXIpIHtcbiAgICAgICAgICAgIHByZWZpeCA9IHByZWZpeE9yUm91dGVyO1xuICAgICAgICAgICAgY2hpbGRSb3V0ZXIgPSBtYXliZVJvdXRlcjtcbiAgICAgICAgfSBlbHNlIGlmIChwcmVmaXhPclJvdXRlciBpbnN0YW5jZW9mIFJvdXRlcikge1xuICAgICAgICAgICAgY2hpbGRSb3V0ZXIgPSBwcmVmaXhPclJvdXRlcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhcmdzJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZHVwbGljYXRlUXVlcmllcyA9IE9iamVjdC5rZXlzKGNoaWxkUm91dGVyLl9kZWYucXVlcmllcykuZmlsdGVyKChrZXkpPT4hIXRoaXMuX2RlZi5xdWVyaWVzW3ByZWZpeCArIGtleV0pO1xuICAgICAgICBjb25zdCBkdXBsaWNhdGVNdXRhdGlvbnMgPSBPYmplY3Qua2V5cyhjaGlsZFJvdXRlci5fZGVmLm11dGF0aW9ucykuZmlsdGVyKChrZXkpPT4hIXRoaXMuX2RlZi5tdXRhdGlvbnNbcHJlZml4ICsga2V5XSk7XG4gICAgICAgIGNvbnN0IGR1cGxpY2F0ZVN1YnNjcmlwdGlvbnMgPSBPYmplY3Qua2V5cyhjaGlsZFJvdXRlci5fZGVmLnN1YnNjcmlwdGlvbnMpLmZpbHRlcigoa2V5KT0+ISF0aGlzLl9kZWYuc3Vic2NyaXB0aW9uc1twcmVmaXggKyBrZXldKTtcbiAgICAgICAgY29uc3QgZHVwbGljYXRlcyA9IFtcbiAgICAgICAgICAgIC4uLmR1cGxpY2F0ZVF1ZXJpZXMsXG4gICAgICAgICAgICAuLi5kdXBsaWNhdGVNdXRhdGlvbnMsXG4gICAgICAgICAgICAuLi5kdXBsaWNhdGVTdWJzY3JpcHRpb25zXG4gICAgICAgIF07XG4gICAgICAgIGlmIChkdXBsaWNhdGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEdXBsaWNhdGUgZW5kcG9pbnQocyk6ICR7ZHVwbGljYXRlcy5qb2luKCcsICcpfWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1lcmdlUHJvY2VkdXJlcyA9IChkZWZzKT0+e1xuICAgICAgICAgICAgY29uc3QgbmV3RGVmcyA9IHNhZmVPYmplY3QoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgcHJvY2VkdXJlXSBvZiBPYmplY3QuZW50cmllcyhkZWZzKSl7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3UHJvY2VkdXJlID0gcHJvY2VkdXJlLmluaGVyaXRNaWRkbGV3YXJlcyh0aGlzLl9kZWYubWlkZGxld2FyZXMpO1xuICAgICAgICAgICAgICAgIG5ld0RlZnNba2V5XSA9IG5ld1Byb2NlZHVyZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBSb3V0ZXIucHJlZml4UHJvY2VkdXJlcyhuZXdEZWZzLCBwcmVmaXgpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbmV3IFJvdXRlcih7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBxdWVyaWVzOiBzYWZlT2JqZWN0KHRoaXMuX2RlZi5xdWVyaWVzLCBtZXJnZVByb2NlZHVyZXMoY2hpbGRSb3V0ZXIuX2RlZi5xdWVyaWVzKSksXG4gICAgICAgICAgICBtdXRhdGlvbnM6IHNhZmVPYmplY3QodGhpcy5fZGVmLm11dGF0aW9ucywgbWVyZ2VQcm9jZWR1cmVzKGNoaWxkUm91dGVyLl9kZWYubXV0YXRpb25zKSksXG4gICAgICAgICAgICBzdWJzY3JpcHRpb25zOiBzYWZlT2JqZWN0KHRoaXMuX2RlZi5zdWJzY3JpcHRpb25zLCBtZXJnZVByb2NlZHVyZXMoY2hpbGRSb3V0ZXIuX2RlZi5zdWJzY3JpcHRpb25zKSlcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBJbnZva2UgcHJvY2VkdXJlLiBPbmx5IGZvciBpbnRlcm5hbCB1c2Ugd2l0aGluIGxpYnJhcnkuXG4gICAqLyBhc3luYyBjYWxsKG9wdHMpIHtcbiAgICAgICAgY29uc3QgeyB0eXBlICwgcGF0aCAgfSA9IG9wdHM7XG4gICAgICAgIGNvbnN0IGRlZlRhcmdldCA9IFBST0NFRFVSRV9ERUZJTklUSU9OX01BUFt0eXBlXTtcbiAgICAgICAgY29uc3QgZGVmcyA9IHRoaXMuX2RlZltkZWZUYXJnZXRdO1xuICAgICAgICBjb25zdCBwcm9jZWR1cmUgPSBkZWZzW3BhdGhdO1xuICAgICAgICBpZiAoIXByb2NlZHVyZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFRSUENFcnJvcih7XG4gICAgICAgICAgICAgICAgY29kZTogJ05PVF9GT1VORCcsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogYE5vIFwiJHt0eXBlfVwiLXByb2NlZHVyZSBvbiBwYXRoIFwiJHtwYXRofVwiYFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb2NlZHVyZS5jYWxsKG9wdHMpO1xuICAgIH1cbiAgICBjcmVhdGVDYWxsZXIoY3R4KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBxdWVyeTogKHBhdGgsIC4uLmFyZ3MpPT57XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FsbCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdxdWVyeScsXG4gICAgICAgICAgICAgICAgICAgIGN0eCxcbiAgICAgICAgICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgICAgICAgICAgcmF3SW5wdXQ6IGFyZ3NbMF1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtdXRhdGlvbjogKHBhdGgsIC4uLmFyZ3MpPT57XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FsbCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdtdXRhdGlvbicsXG4gICAgICAgICAgICAgICAgICAgIGN0eCxcbiAgICAgICAgICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgICAgICAgICAgcmF3SW5wdXQ6IGFyZ3NbMF1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdWJzY3JpcHRpb246IChwYXRoLCAuLi5hcmdzKT0+e1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNhbGwoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnc3Vic2NyaXB0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgY3R4LFxuICAgICAgICAgICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgICAgICAgICByYXdJbnB1dDogYXJnc1swXVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICogRnVuY3Rpb24gdG8gYmUgY2FsbGVkIGJlZm9yZSBhbnkgcHJvY2VkdXJlIGlzIGludm9rZWRcbiAgICogQGxpbmsgaHR0cHM6Ly90cnBjLmlvL2RvY3MvbWlkZGxld2FyZXNcbiAgICovIG1pZGRsZXdhcmUobWlkZGxld2FyZSkge1xuICAgICAgICByZXR1cm4gbmV3IFJvdXRlcih7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBtaWRkbGV3YXJlczogW1xuICAgICAgICAgICAgICAgIC4uLnRoaXMuX2RlZi5taWRkbGV3YXJlcyxcbiAgICAgICAgICAgICAgICBtaWRkbGV3YXJlXG4gICAgICAgICAgICBdXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICogRm9ybWF0IGVycm9yc1xuICAgKiBAbGluayBodHRwczovL3RycGMuaW8vZG9jcy9lcnJvci1mb3JtYXR0aW5nXG4gICAqLyBmb3JtYXRFcnJvcihlcnJvckZvcm1hdHRlcikge1xuICAgICAgICBpZiAodGhpcy5fZGVmLmVycm9yRm9ybWF0dGVyICE9PSBkZWZhdWx0Rm9ybWF0dGVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBzZWVtIHRvIGhhdmUgZG91YmxlIGBmb3JtYXRFcnJvcigpYC1jYWxscyBpbiB5b3VyIHJvdXRlciB0cmVlJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBSb3V0ZXIoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgZXJyb3JGb3JtYXR0ZXI6IGVycm9yRm9ybWF0dGVyXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRFcnJvclNoYXBlKG9wdHMpIHtcbiAgICAgICAgY29uc3QgeyBwYXRoICwgZXJyb3IgIH0gPSBvcHRzO1xuICAgICAgICBjb25zdCB7IGNvZGUgIH0gPSBvcHRzLmVycm9yO1xuICAgICAgICBjb25zdCBzaGFwZSA9IHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UsXG4gICAgICAgICAgICBjb2RlOiBUUlBDX0VSUk9SX0NPREVTX0JZX0tFWVtjb2RlXSxcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICBjb2RlLFxuICAgICAgICAgICAgICAgIGh0dHBTdGF0dXM6IGdldEhUVFBTdGF0dXNDb2RlRnJvbUVycm9yKGVycm9yKVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBpZiAoZ2xvYmFsVGhpcy5wcm9jZXNzPy5lbnY/Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgdHlwZW9mIG9wdHMuZXJyb3Iuc3RhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBzaGFwZS5kYXRhLnN0YWNrID0gb3B0cy5lcnJvci5zdGFjaztcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHBhdGggPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBzaGFwZS5kYXRhLnBhdGggPSBwYXRoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuZXJyb3JGb3JtYXR0ZXIoe1xuICAgICAgICAgICAgLi4ub3B0cyxcbiAgICAgICAgICAgIHNoYXBlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICogQWRkIGRhdGEgdHJhbnNmb3JtZXIgdG8gc2VyaWFsaXplL2Rlc2VyaWFsaXplIGlucHV0IGFyZ3MgKyBvdXRwdXRcbiAgICogQGxpbmsgaHR0cHM6Ly90cnBjLmlvL2RvY3MvZGF0YS10cmFuc2Zvcm1lcnNcbiAgICovIHRyYW5zZm9ybWVyKF90cmFuc2Zvcm1lcikge1xuICAgICAgICBjb25zdCB0cmFuc2Zvcm1lciA9IGdldERhdGFUcmFuc2Zvcm1lcihfdHJhbnNmb3JtZXIpO1xuICAgICAgICBpZiAodGhpcy5fZGVmLnRyYW5zZm9ybWVyICE9PSBkZWZhdWx0VHJhbnNmb3JtZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IHNlZW0gdG8gaGF2ZSBkb3VibGUgYHRyYW5zZm9ybWVyKClgLWNhbGxzIGluIHlvdXIgcm91dGVyIHRyZWUnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFJvdXRlcih7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICB0cmFuc2Zvcm1lclxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAqIEZsYXR0ZW5zIHRoZSBnZW5lcmljcyBvZiBUUXVlcmllcy9UTXV0YXRpb25zL1RTdWJzY3JpcHRpb25zLlxuICAgKiDimqDvuI8gRXhwZXJpbWVudGFsIC0gbWlnaHQgZGlzYXBwZWFyLiDimqDvuI9cbiAgICpcbiAgICogQGFscGhhXG4gICAqLyBmbGF0KCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAqIEludGVyb3AgbW9kZSBmb3IgdjkueCAtPiB2MTAueFxuICAgKi8gaW50ZXJvcCgpIHtcbiAgICAgICAgcmV0dXJuIG1pZ3JhdGVSb3V0ZXIodGhpcyk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGRlZil7XG4gICAgICAgIHRoaXMuX2RlZiA9IHtcbiAgICAgICAgICAgIHF1ZXJpZXM6IGRlZj8ucXVlcmllcyA/PyBzYWZlT2JqZWN0KCksXG4gICAgICAgICAgICBtdXRhdGlvbnM6IGRlZj8ubXV0YXRpb25zID8/IHNhZmVPYmplY3QoKSxcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbnM6IGRlZj8uc3Vic2NyaXB0aW9ucyA/PyBzYWZlT2JqZWN0KCksXG4gICAgICAgICAgICBtaWRkbGV3YXJlczogZGVmPy5taWRkbGV3YXJlcyA/PyBbXSxcbiAgICAgICAgICAgIGVycm9yRm9ybWF0dGVyOiBkZWY/LmVycm9yRm9ybWF0dGVyID8/IGRlZmF1bHRGb3JtYXR0ZXIsXG4gICAgICAgICAgICB0cmFuc2Zvcm1lcjogZGVmPy50cmFuc2Zvcm1lciA/PyBkZWZhdWx0VHJhbnNmb3JtZXJcbiAgICAgICAgfTtcbiAgICB9XG59XG4vKipcbiAqIEBkZXByZWNhdGVkXG4gKi8gZnVuY3Rpb24gcm91dGVyKCkge1xuICAgIHJldHVybiBuZXcgUm91dGVyKCk7XG59XG5cbmZ1bmN0aW9uIG1lcmdlUm91dGVycyguLi5yb3V0ZXJMaXN0KSB7XG4gICAgY29uc3QgcmVjb3JkID0gbWVyZ2VXaXRob3V0T3ZlcnJpZGVzKHt9LCAuLi5yb3V0ZXJMaXN0Lm1hcCgocik9PnIuX2RlZi5yZWNvcmQpKTtcbiAgICBjb25zdCBlcnJvckZvcm1hdHRlciA9IHJvdXRlckxpc3QucmVkdWNlKChjdXJyZW50RXJyb3JGb3JtYXR0ZXIsIG5leHRSb3V0ZXIpPT57XG4gICAgICAgIGlmIChuZXh0Um91dGVyLl9kZWYuX2NvbmZpZy5lcnJvckZvcm1hdHRlciAmJiBuZXh0Um91dGVyLl9kZWYuX2NvbmZpZy5lcnJvckZvcm1hdHRlciAhPT0gZGVmYXVsdEZvcm1hdHRlcikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRFcnJvckZvcm1hdHRlciAhPT0gZGVmYXVsdEZvcm1hdHRlciAmJiBjdXJyZW50RXJyb3JGb3JtYXR0ZXIgIT09IG5leHRSb3V0ZXIuX2RlZi5fY29uZmlnLmVycm9yRm9ybWF0dGVyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3Ugc2VlbSB0byBoYXZlIHNldmVyYWwgZXJyb3IgZm9ybWF0dGVycycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5leHRSb3V0ZXIuX2RlZi5fY29uZmlnLmVycm9yRm9ybWF0dGVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjdXJyZW50RXJyb3JGb3JtYXR0ZXI7XG4gICAgfSwgZGVmYXVsdEZvcm1hdHRlcik7XG4gICAgY29uc3QgdHJhbnNmb3JtZXIgPSByb3V0ZXJMaXN0LnJlZHVjZSgocHJldiwgY3VycmVudCk9PntcbiAgICAgICAgaWYgKGN1cnJlbnQuX2RlZi5fY29uZmlnLnRyYW5zZm9ybWVyICYmIGN1cnJlbnQuX2RlZi5fY29uZmlnLnRyYW5zZm9ybWVyICE9PSBkZWZhdWx0VHJhbnNmb3JtZXIpIHtcbiAgICAgICAgICAgIGlmIChwcmV2ICE9PSBkZWZhdWx0VHJhbnNmb3JtZXIgJiYgcHJldiAhPT0gY3VycmVudC5fZGVmLl9jb25maWcudHJhbnNmb3JtZXIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBzZWVtIHRvIGhhdmUgc2V2ZXJhbCB0cmFuc2Zvcm1lcnMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50Ll9kZWYuX2NvbmZpZy50cmFuc2Zvcm1lcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJldjtcbiAgICB9LCBkZWZhdWx0VHJhbnNmb3JtZXIpO1xuICAgIGNvbnN0IHJvdXRlciA9IGNyZWF0ZVJvdXRlckZhY3Rvcnkoe1xuICAgICAgICBlcnJvckZvcm1hdHRlcixcbiAgICAgICAgdHJhbnNmb3JtZXIsXG4gICAgICAgIGlzRGV2OiByb3V0ZXJMaXN0LnNvbWUoKHIpPT5yLl9kZWYuX2NvbmZpZy5pc0RldiksXG4gICAgICAgIGFsbG93T3V0c2lkZU9mU2VydmVyOiByb3V0ZXJMaXN0LnNvbWUoKHIpPT5yLl9kZWYuX2NvbmZpZy5hbGxvd091dHNpZGVPZlNlcnZlciksXG4gICAgICAgIGlzU2VydmVyOiByb3V0ZXJMaXN0LnNvbWUoKHIpPT5yLl9kZWYuX2NvbmZpZy5pc1NlcnZlciksXG4gICAgICAgICR0eXBlczogcm91dGVyTGlzdFswXT8uX2RlZi5fY29uZmlnLiR0eXBlc1xuICAgIH0pKHJlY29yZCk7XG4gICAgcmV0dXJuIHJvdXRlcjtcbn1cblxuLyoqXG4gKiBUT0RPOiBUaGlzIGNhbiBiZSBpbXByb3ZlZDpcbiAqIC0gV2Ugc2hvdWxkIGJlIGFibGUgdG8gY2hhaW4gYC5tZXRhKClgL2AuY29udGV4dCgpYCBvbmx5IG9uY2VcbiAqIC0gU2ltcGxpZnkgdHlwaW5nc1xuICogLSBEb2Vzbid0IG5lZWQgdG8gYmUgYSBjbGFzcyBidXQgaXQgZG9lc24ndCByZWFsbHkgaHVydCBlaXRoZXJcbiAqLyBjbGFzcyBUUlBDQnVpbGRlciB7XG4gICAgY29udGV4dCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUUlBDQnVpbGRlcigpO1xuICAgIH1cbiAgICBtZXRhKCkge1xuICAgICAgICByZXR1cm4gbmV3IFRSUENCdWlsZGVyKCk7XG4gICAgfVxuICAgIGNyZWF0ZShvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVUUlBDSW5uZXIoKShvcHRpb25zKTtcbiAgICB9XG59XG4vKipcbiAqIEluaXRpYWxpemUgdFJQQyAtIGRvbmUgZXhhY3RseSBvbmNlIHBlciBiYWNrZW5kXG4gKi8gY29uc3QgaW5pdFRSUEMgPSBuZXcgVFJQQ0J1aWxkZXIoKTtcbmZ1bmN0aW9uIGNyZWF0ZVRSUENJbm5lcigpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gaW5pdFRSUENJbm5lcihydW50aW1lKSB7XG4gICAgICAgIGNvbnN0IGVycm9yRm9ybWF0dGVyID0gcnVudGltZT8uZXJyb3JGb3JtYXR0ZXIgPz8gZGVmYXVsdEZvcm1hdHRlcjtcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtZXIgPSBnZXREYXRhVHJhbnNmb3JtZXIkMShydW50aW1lPy50cmFuc2Zvcm1lciA/PyBkZWZhdWx0VHJhbnNmb3JtZXIpO1xuICAgICAgICBjb25zdCBjb25maWcgPSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lcixcbiAgICAgICAgICAgIGlzRGV2OiBydW50aW1lPy5pc0RldiA/PyBnbG9iYWxUaGlzLnByb2Nlc3M/LmVudj8uTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyxcbiAgICAgICAgICAgIGFsbG93T3V0c2lkZU9mU2VydmVyOiBydW50aW1lPy5hbGxvd091dHNpZGVPZlNlcnZlciA/PyBmYWxzZSxcbiAgICAgICAgICAgIGVycm9yRm9ybWF0dGVyLFxuICAgICAgICAgICAgaXNTZXJ2ZXI6IHJ1bnRpbWU/LmlzU2VydmVyID8/IGlzU2VydmVyRGVmYXVsdCxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICogQGludGVybmFsXG4gICAgICAgKi8gJHR5cGVzOiBjcmVhdGVGbGF0UHJveHkoKGtleSk9PntcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRyaWVkIHRvIGFjY2VzcyBcIiR0eXBlcy4ke2tleX1cIiB3aGljaCBpcyBub3QgYXZhaWxhYmxlIGF0IHJ1bnRpbWVgKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH07XG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIFNlcnZlciBjaGVja1xuICAgICAgICAgICAgY29uc3QgaXNTZXJ2ZXIgPSBydW50aW1lPy5pc1NlcnZlciA/PyBpc1NlcnZlckRlZmF1bHQ7XG4gICAgICAgICAgICBpZiAoIWlzU2VydmVyICYmIHJ1bnRpbWU/LmFsbG93T3V0c2lkZU9mU2VydmVyICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBZb3UncmUgdHJ5aW5nIHRvIHVzZSBAdHJwYy9zZXJ2ZXIgaW4gYSBub24tc2VydmVyIGVudmlyb25tZW50LiBUaGlzIGlzIG5vdCBzdXBwb3J0ZWQgYnkgZGVmYXVsdC5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgKiBUaGVzZSBhcmUganVzdCB0eXBlcywgdGhleSBjYW4ndCBiZSB1c2VkXG4gICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAqLyBfY29uZmlnOiBjb25maWcsXG4gICAgICAgICAgICAvKipcbiAgICAgICAqIEJ1aWxkZXIgb2JqZWN0IGZvciBjcmVhdGluZyBwcm9jZWR1cmVzXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdHJwYy5pby9kb2NzL3NlcnZlci9wcm9jZWR1cmVzXG4gICAgICAgKi8gcHJvY2VkdXJlOiBjcmVhdGVCdWlsZGVyKHtcbiAgICAgICAgICAgICAgICBtZXRhOiBydW50aW1lPy5kZWZhdWx0TWV0YVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAvKipcbiAgICAgICAqIENyZWF0ZSByZXVzYWJsZSBtaWRkbGV3YXJlc1xuICAgICAgICogQHNlZSBodHRwczovL3RycGMuaW8vZG9jcy9zZXJ2ZXIvbWlkZGxld2FyZXNcbiAgICAgICAqLyBtaWRkbGV3YXJlOiBjcmVhdGVNaWRkbGV3YXJlRmFjdG9yeSgpLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgKiBDcmVhdGUgYSByb3V0ZXJcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90cnBjLmlvL2RvY3Mvc2VydmVyL3JvdXRlcnNcbiAgICAgICAqLyByb3V0ZXI6IGNyZWF0ZVJvdXRlckZhY3RvcnkoY29uZmlnKSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICogTWVyZ2UgUm91dGVyc1xuICAgICAgICogQHNlZSBodHRwczovL3RycGMuaW8vZG9jcy9zZXJ2ZXIvbWVyZ2luZy1yb3V0ZXJzXG4gICAgICAgKi8gbWVyZ2VSb3V0ZXJzLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgKiBDcmVhdGUgYSBzZXJ2ZXItc2lkZSBjYWxsZXIgZm9yIGEgcm91dGVyXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdHJwYy5pby9kb2NzL3NlcnZlci9zZXJ2ZXItc2lkZS1jYWxsc1xuICAgICAgICovIGNyZWF0ZUNhbGxlckZhY3Rvcnk6IGNyZWF0ZUNhbGxlckZhY3RvcnkoKVxuICAgICAgICB9O1xuICAgIH07XG59XG5cbmV4cG9ydCB7IGNyZWF0ZUlucHV0TWlkZGxld2FyZSwgY3JlYXRlT3V0cHV0TWlkZGxld2FyZSwgZXhwZXJpbWVudGFsX3N0YW5kYWxvbmVNaWRkbGV3YXJlLCBpbml0VFJQQywgcm91dGVyIH07XG4iLCJleHBvcnQgdmFyIHV0aWw7XG4oZnVuY3Rpb24gKHV0aWwpIHtcbiAgICB1dGlsLmFzc2VydEVxdWFsID0gKF8pID0+IHsgfTtcbiAgICBmdW5jdGlvbiBhc3NlcnRJcyhfYXJnKSB7IH1cbiAgICB1dGlsLmFzc2VydElzID0gYXNzZXJ0SXM7XG4gICAgZnVuY3Rpb24gYXNzZXJ0TmV2ZXIoX3gpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgfVxuICAgIHV0aWwuYXNzZXJ0TmV2ZXIgPSBhc3NlcnROZXZlcjtcbiAgICB1dGlsLmFycmF5VG9FbnVtID0gKGl0ZW1zKSA9PiB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgaXRlbXMpIHtcbiAgICAgICAgICAgIG9ialtpdGVtXSA9IGl0ZW07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9O1xuICAgIHV0aWwuZ2V0VmFsaWRFbnVtVmFsdWVzID0gKG9iaikgPT4ge1xuICAgICAgICBjb25zdCB2YWxpZEtleXMgPSB1dGlsLm9iamVjdEtleXMob2JqKS5maWx0ZXIoKGspID0+IHR5cGVvZiBvYmpbb2JqW2tdXSAhPT0gXCJudW1iZXJcIik7XG4gICAgICAgIGNvbnN0IGZpbHRlcmVkID0ge307XG4gICAgICAgIGZvciAoY29uc3QgayBvZiB2YWxpZEtleXMpIHtcbiAgICAgICAgICAgIGZpbHRlcmVkW2tdID0gb2JqW2tdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1dGlsLm9iamVjdFZhbHVlcyhmaWx0ZXJlZCk7XG4gICAgfTtcbiAgICB1dGlsLm9iamVjdFZhbHVlcyA9IChvYmopID0+IHtcbiAgICAgICAgcmV0dXJuIHV0aWwub2JqZWN0S2V5cyhvYmopLm1hcChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIG9ialtlXTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICB1dGlsLm9iamVjdEtleXMgPSB0eXBlb2YgT2JqZWN0LmtleXMgPT09IFwiZnVuY3Rpb25cIiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGJhbi9iYW5cbiAgICAgICAgPyAob2JqKSA9PiBPYmplY3Qua2V5cyhvYmopIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgYmFuL2JhblxuICAgICAgICA6IChvYmplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGtleXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIG9iamVjdCkge1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBrZXlzO1xuICAgICAgICB9O1xuICAgIHV0aWwuZmluZCA9IChhcnIsIGNoZWNrZXIpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGFycikge1xuICAgICAgICAgICAgaWYgKGNoZWNrZXIoaXRlbSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIHV0aWwuaXNJbnRlZ2VyID0gdHlwZW9mIE51bWJlci5pc0ludGVnZXIgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICA/ICh2YWwpID0+IE51bWJlci5pc0ludGVnZXIodmFsKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGJhbi9iYW5cbiAgICAgICAgOiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSBcIm51bWJlclwiICYmIE51bWJlci5pc0Zpbml0ZSh2YWwpICYmIE1hdGguZmxvb3IodmFsKSA9PT0gdmFsO1xuICAgIGZ1bmN0aW9uIGpvaW5WYWx1ZXMoYXJyYXksIHNlcGFyYXRvciA9IFwiIHwgXCIpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5Lm1hcCgodmFsKSA9PiAodHlwZW9mIHZhbCA9PT0gXCJzdHJpbmdcIiA/IGAnJHt2YWx9J2AgOiB2YWwpKS5qb2luKHNlcGFyYXRvcik7XG4gICAgfVxuICAgIHV0aWwuam9pblZhbHVlcyA9IGpvaW5WYWx1ZXM7XG4gICAgdXRpbC5qc29uU3RyaW5naWZ5UmVwbGFjZXIgPSAoXywgdmFsdWUpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJiaWdpbnRcIikge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG59KSh1dGlsIHx8ICh1dGlsID0ge30pKTtcbmV4cG9ydCB2YXIgb2JqZWN0VXRpbDtcbihmdW5jdGlvbiAob2JqZWN0VXRpbCkge1xuICAgIG9iamVjdFV0aWwubWVyZ2VTaGFwZXMgPSAoZmlyc3QsIHNlY29uZCkgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uZmlyc3QsXG4gICAgICAgICAgICAuLi5zZWNvbmQsIC8vIHNlY29uZCBvdmVyd3JpdGVzIGZpcnN0XG4gICAgICAgIH07XG4gICAgfTtcbn0pKG9iamVjdFV0aWwgfHwgKG9iamVjdFV0aWwgPSB7fSkpO1xuZXhwb3J0IGNvbnN0IFpvZFBhcnNlZFR5cGUgPSB1dGlsLmFycmF5VG9FbnVtKFtcbiAgICBcInN0cmluZ1wiLFxuICAgIFwibmFuXCIsXG4gICAgXCJudW1iZXJcIixcbiAgICBcImludGVnZXJcIixcbiAgICBcImZsb2F0XCIsXG4gICAgXCJib29sZWFuXCIsXG4gICAgXCJkYXRlXCIsXG4gICAgXCJiaWdpbnRcIixcbiAgICBcInN5bWJvbFwiLFxuICAgIFwiZnVuY3Rpb25cIixcbiAgICBcInVuZGVmaW5lZFwiLFxuICAgIFwibnVsbFwiLFxuICAgIFwiYXJyYXlcIixcbiAgICBcIm9iamVjdFwiLFxuICAgIFwidW5rbm93blwiLFxuICAgIFwicHJvbWlzZVwiLFxuICAgIFwidm9pZFwiLFxuICAgIFwibmV2ZXJcIixcbiAgICBcIm1hcFwiLFxuICAgIFwic2V0XCIsXG5dKTtcbmV4cG9ydCBjb25zdCBnZXRQYXJzZWRUeXBlID0gKGRhdGEpID0+IHtcbiAgICBjb25zdCB0ID0gdHlwZW9mIGRhdGE7XG4gICAgc3dpdGNoICh0KSB7XG4gICAgICAgIGNhc2UgXCJ1bmRlZmluZWRcIjpcbiAgICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLnVuZGVmaW5lZDtcbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUuc3RyaW5nO1xuICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgICAgICByZXR1cm4gTnVtYmVyLmlzTmFOKGRhdGEpID8gWm9kUGFyc2VkVHlwZS5uYW4gOiBab2RQYXJzZWRUeXBlLm51bWJlcjtcbiAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLmJvb2xlYW47XG4gICAgICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUuZnVuY3Rpb247XG4gICAgICAgIGNhc2UgXCJiaWdpbnRcIjpcbiAgICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLmJpZ2ludDtcbiAgICAgICAgY2FzZSBcInN5bWJvbFwiOlxuICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUuc3ltYm9sO1xuICAgICAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLmFycmF5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGEgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5udWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGEudGhlbiAmJiB0eXBlb2YgZGF0YS50aGVuID09PSBcImZ1bmN0aW9uXCIgJiYgZGF0YS5jYXRjaCAmJiB0eXBlb2YgZGF0YS5jYXRjaCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUucHJvbWlzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgTWFwICE9PSBcInVuZGVmaW5lZFwiICYmIGRhdGEgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5tYXA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIFNldCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkYXRhIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUuc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBEYXRlICE9PSBcInVuZGVmaW5lZFwiICYmIGRhdGEgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUuZGF0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLm9iamVjdDtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLnVua25vd247XG4gICAgfVxufTtcbiIsImltcG9ydCB7IHV0aWwgfSBmcm9tIFwiLi9oZWxwZXJzL3V0aWwuanNcIjtcbmV4cG9ydCBjb25zdCBab2RJc3N1ZUNvZGUgPSB1dGlsLmFycmF5VG9FbnVtKFtcbiAgICBcImludmFsaWRfdHlwZVwiLFxuICAgIFwiaW52YWxpZF9saXRlcmFsXCIsXG4gICAgXCJjdXN0b21cIixcbiAgICBcImludmFsaWRfdW5pb25cIixcbiAgICBcImludmFsaWRfdW5pb25fZGlzY3JpbWluYXRvclwiLFxuICAgIFwiaW52YWxpZF9lbnVtX3ZhbHVlXCIsXG4gICAgXCJ1bnJlY29nbml6ZWRfa2V5c1wiLFxuICAgIFwiaW52YWxpZF9hcmd1bWVudHNcIixcbiAgICBcImludmFsaWRfcmV0dXJuX3R5cGVcIixcbiAgICBcImludmFsaWRfZGF0ZVwiLFxuICAgIFwiaW52YWxpZF9zdHJpbmdcIixcbiAgICBcInRvb19zbWFsbFwiLFxuICAgIFwidG9vX2JpZ1wiLFxuICAgIFwiaW52YWxpZF9pbnRlcnNlY3Rpb25fdHlwZXNcIixcbiAgICBcIm5vdF9tdWx0aXBsZV9vZlwiLFxuICAgIFwibm90X2Zpbml0ZVwiLFxuXSk7XG5leHBvcnQgY29uc3QgcXVvdGVsZXNzSnNvbiA9IChvYmopID0+IHtcbiAgICBjb25zdCBqc29uID0gSlNPTi5zdHJpbmdpZnkob2JqLCBudWxsLCAyKTtcbiAgICByZXR1cm4ganNvbi5yZXBsYWNlKC9cIihbXlwiXSspXCI6L2csIFwiJDE6XCIpO1xufTtcbmV4cG9ydCBjbGFzcyBab2RFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBnZXQgZXJyb3JzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc3N1ZXM7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGlzc3Vlcykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmlzc3VlcyA9IFtdO1xuICAgICAgICB0aGlzLmFkZElzc3VlID0gKHN1YikgPT4ge1xuICAgICAgICAgICAgdGhpcy5pc3N1ZXMgPSBbLi4udGhpcy5pc3N1ZXMsIHN1Yl07XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYWRkSXNzdWVzID0gKHN1YnMgPSBbXSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5pc3N1ZXMgPSBbLi4udGhpcy5pc3N1ZXMsIC4uLnN1YnNdO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBhY3R1YWxQcm90byA9IG5ldy50YXJnZXQucHJvdG90eXBlO1xuICAgICAgICBpZiAoT2JqZWN0LnNldFByb3RvdHlwZU9mKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgYmFuL2JhblxuICAgICAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIGFjdHVhbFByb3RvKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX19wcm90b19fID0gYWN0dWFsUHJvdG87XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5uYW1lID0gXCJab2RFcnJvclwiO1xuICAgICAgICB0aGlzLmlzc3VlcyA9IGlzc3VlcztcbiAgICB9XG4gICAgZm9ybWF0KF9tYXBwZXIpIHtcbiAgICAgICAgY29uc3QgbWFwcGVyID0gX21hcHBlciB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGlzc3VlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzc3VlLm1lc3NhZ2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICBjb25zdCBmaWVsZEVycm9ycyA9IHsgX2Vycm9yczogW10gfTtcbiAgICAgICAgY29uc3QgcHJvY2Vzc0Vycm9yID0gKGVycm9yKSA9PiB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGlzc3VlIG9mIGVycm9yLmlzc3Vlcykge1xuICAgICAgICAgICAgICAgIGlmIChpc3N1ZS5jb2RlID09PSBcImludmFsaWRfdW5pb25cIikge1xuICAgICAgICAgICAgICAgICAgICBpc3N1ZS51bmlvbkVycm9ycy5tYXAocHJvY2Vzc0Vycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNzdWUuY29kZSA9PT0gXCJpbnZhbGlkX3JldHVybl90eXBlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc0Vycm9yKGlzc3VlLnJldHVyblR5cGVFcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLmNvZGUgPT09IFwiaW52YWxpZF9hcmd1bWVudHNcIikge1xuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzRXJyb3IoaXNzdWUuYXJndW1lbnRzRXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc3N1ZS5wYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBmaWVsZEVycm9ycy5fZXJyb3JzLnB1c2gobWFwcGVyKGlzc3VlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZXQgY3VyciA9IGZpZWxkRXJyb3JzO1xuICAgICAgICAgICAgICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChpIDwgaXNzdWUucGF0aC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVsID0gaXNzdWUucGF0aFtpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRlcm1pbmFsID0gaSA9PT0gaXNzdWUucGF0aC5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0ZXJtaW5hbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJbZWxdID0gY3VycltlbF0gfHwgeyBfZXJyb3JzOiBbXSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmICh0eXBlb2YgZWwgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgIGN1cnJbZWxdID0gY3VycltlbF0gfHwgeyBfZXJyb3JzOiBbXSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIH0gZWxzZSBpZiAodHlwZW9mIGVsID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICBjb25zdCBlcnJvckFycmF5OiBhbnkgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgIGVycm9yQXJyYXkuX2Vycm9ycyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgY3VycltlbF0gPSBjdXJyW2VsXSB8fCBlcnJvckFycmF5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJbZWxdID0gY3VycltlbF0gfHwgeyBfZXJyb3JzOiBbXSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJbZWxdLl9lcnJvcnMucHVzaChtYXBwZXIoaXNzdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnIgPSBjdXJyW2VsXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcHJvY2Vzc0Vycm9yKHRoaXMpO1xuICAgICAgICByZXR1cm4gZmllbGRFcnJvcnM7XG4gICAgfVxuICAgIHN0YXRpYyBhc3NlcnQodmFsdWUpIHtcbiAgICAgICAgaWYgKCEodmFsdWUgaW5zdGFuY2VvZiBab2RFcnJvcikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTm90IGEgWm9kRXJyb3I6ICR7dmFsdWV9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1lc3NhZ2U7XG4gICAgfVxuICAgIGdldCBtZXNzYWdlKCkge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy5pc3N1ZXMsIHV0aWwuanNvblN0cmluZ2lmeVJlcGxhY2VyLCAyKTtcbiAgICB9XG4gICAgZ2V0IGlzRW1wdHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzc3Vlcy5sZW5ndGggPT09IDA7XG4gICAgfVxuICAgIGZsYXR0ZW4obWFwcGVyID0gKGlzc3VlKSA9PiBpc3N1ZS5tZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IGZpZWxkRXJyb3JzID0ge307XG4gICAgICAgIGNvbnN0IGZvcm1FcnJvcnMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBzdWIgb2YgdGhpcy5pc3N1ZXMpIHtcbiAgICAgICAgICAgIGlmIChzdWIucGF0aC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmlyc3RFbCA9IHN1Yi5wYXRoWzBdO1xuICAgICAgICAgICAgICAgIGZpZWxkRXJyb3JzW2ZpcnN0RWxdID0gZmllbGRFcnJvcnNbZmlyc3RFbF0gfHwgW107XG4gICAgICAgICAgICAgICAgZmllbGRFcnJvcnNbZmlyc3RFbF0ucHVzaChtYXBwZXIoc3ViKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3JtRXJyb3JzLnB1c2gobWFwcGVyKHN1YikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGZvcm1FcnJvcnMsIGZpZWxkRXJyb3JzIH07XG4gICAgfVxuICAgIGdldCBmb3JtRXJyb3JzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mbGF0dGVuKCk7XG4gICAgfVxufVxuWm9kRXJyb3IuY3JlYXRlID0gKGlzc3VlcykgPT4ge1xuICAgIGNvbnN0IGVycm9yID0gbmV3IFpvZEVycm9yKGlzc3Vlcyk7XG4gICAgcmV0dXJuIGVycm9yO1xufTtcbiIsImltcG9ydCB7IFpvZElzc3VlQ29kZSB9IGZyb20gXCIuLi9ab2RFcnJvci5qc1wiO1xuaW1wb3J0IHsgdXRpbCwgWm9kUGFyc2VkVHlwZSB9IGZyb20gXCIuLi9oZWxwZXJzL3V0aWwuanNcIjtcbmNvbnN0IGVycm9yTWFwID0gKGlzc3VlLCBfY3R4KSA9PiB7XG4gICAgbGV0IG1lc3NhZ2U7XG4gICAgc3dpdGNoIChpc3N1ZS5jb2RlKSB7XG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZTpcbiAgICAgICAgICAgIGlmIChpc3N1ZS5yZWNlaXZlZCA9PT0gWm9kUGFyc2VkVHlwZS51bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gXCJSZXF1aXJlZFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBFeHBlY3RlZCAke2lzc3VlLmV4cGVjdGVkfSwgcmVjZWl2ZWQgJHtpc3N1ZS5yZWNlaXZlZH1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLmludmFsaWRfbGl0ZXJhbDpcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBsaXRlcmFsIHZhbHVlLCBleHBlY3RlZCAke0pTT04uc3RyaW5naWZ5KGlzc3VlLmV4cGVjdGVkLCB1dGlsLmpzb25TdHJpbmdpZnlSZXBsYWNlcil9YDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS51bnJlY29nbml6ZWRfa2V5czpcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgVW5yZWNvZ25pemVkIGtleShzKSBpbiBvYmplY3Q6ICR7dXRpbC5qb2luVmFsdWVzKGlzc3VlLmtleXMsIFwiLCBcIil9YDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX3VuaW9uOlxuICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGlucHV0YDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX3VuaW9uX2Rpc2NyaW1pbmF0b3I6XG4gICAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgZGlzY3JpbWluYXRvciB2YWx1ZS4gRXhwZWN0ZWQgJHt1dGlsLmpvaW5WYWx1ZXMoaXNzdWUub3B0aW9ucyl9YDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX2VudW1fdmFsdWU6XG4gICAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgZW51bSB2YWx1ZS4gRXhwZWN0ZWQgJHt1dGlsLmpvaW5WYWx1ZXMoaXNzdWUub3B0aW9ucyl9LCByZWNlaXZlZCAnJHtpc3N1ZS5yZWNlaXZlZH0nYDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX2FyZ3VtZW50czpcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBmdW5jdGlvbiBhcmd1bWVudHNgO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLmludmFsaWRfcmV0dXJuX3R5cGU6XG4gICAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgZnVuY3Rpb24gcmV0dXJuIHR5cGVgO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLmludmFsaWRfZGF0ZTpcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBkYXRlYDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZzpcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaXNzdWUudmFsaWRhdGlvbiA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgIGlmIChcImluY2x1ZGVzXCIgaW4gaXNzdWUudmFsaWRhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgaW5wdXQ6IG11c3QgaW5jbHVkZSBcIiR7aXNzdWUudmFsaWRhdGlvbi5pbmNsdWRlc31cImA7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaXNzdWUudmFsaWRhdGlvbi5wb3NpdGlvbiA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IGAke21lc3NhZ2V9IGF0IG9uZSBvciBtb3JlIHBvc2l0aW9ucyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gJHtpc3N1ZS52YWxpZGF0aW9uLnBvc2l0aW9ufWA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoXCJzdGFydHNXaXRoXCIgaW4gaXNzdWUudmFsaWRhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgaW5wdXQ6IG11c3Qgc3RhcnQgd2l0aCBcIiR7aXNzdWUudmFsaWRhdGlvbi5zdGFydHNXaXRofVwiYDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoXCJlbmRzV2l0aFwiIGluIGlzc3VlLnZhbGlkYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGlucHV0OiBtdXN0IGVuZCB3aXRoIFwiJHtpc3N1ZS52YWxpZGF0aW9uLmVuZHNXaXRofVwiYDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHV0aWwuYXNzZXJ0TmV2ZXIoaXNzdWUudmFsaWRhdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNzdWUudmFsaWRhdGlvbiAhPT0gXCJyZWdleFwiKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkICR7aXNzdWUudmFsaWRhdGlvbn1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IFwiSW52YWxpZFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLnRvb19zbWFsbDpcbiAgICAgICAgICAgIGlmIChpc3N1ZS50eXBlID09PSBcImFycmF5XCIpXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBBcnJheSBtdXN0IGNvbnRhaW4gJHtpc3N1ZS5leGFjdCA/IFwiZXhhY3RseVwiIDogaXNzdWUuaW5jbHVzaXZlID8gYGF0IGxlYXN0YCA6IGBtb3JlIHRoYW5gfSAke2lzc3VlLm1pbmltdW19IGVsZW1lbnQocylgO1xuICAgICAgICAgICAgZWxzZSBpZiAoaXNzdWUudHlwZSA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gYFN0cmluZyBtdXN0IGNvbnRhaW4gJHtpc3N1ZS5leGFjdCA/IFwiZXhhY3RseVwiIDogaXNzdWUuaW5jbHVzaXZlID8gYGF0IGxlYXN0YCA6IGBvdmVyYH0gJHtpc3N1ZS5taW5pbXVtfSBjaGFyYWN0ZXIocylgO1xuICAgICAgICAgICAgZWxzZSBpZiAoaXNzdWUudHlwZSA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gYE51bWJlciBtdXN0IGJlICR7aXNzdWUuZXhhY3QgPyBgZXhhY3RseSBlcXVhbCB0byBgIDogaXNzdWUuaW5jbHVzaXZlID8gYGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byBgIDogYGdyZWF0ZXIgdGhhbiBgfSR7aXNzdWUubWluaW11bX1gO1xuICAgICAgICAgICAgZWxzZSBpZiAoaXNzdWUudHlwZSA9PT0gXCJiaWdpbnRcIilcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gYE51bWJlciBtdXN0IGJlICR7aXNzdWUuZXhhY3QgPyBgZXhhY3RseSBlcXVhbCB0byBgIDogaXNzdWUuaW5jbHVzaXZlID8gYGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byBgIDogYGdyZWF0ZXIgdGhhbiBgfSR7aXNzdWUubWluaW11bX1gO1xuICAgICAgICAgICAgZWxzZSBpZiAoaXNzdWUudHlwZSA9PT0gXCJkYXRlXCIpXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBEYXRlIG11c3QgYmUgJHtpc3N1ZS5leGFjdCA/IGBleGFjdGx5IGVxdWFsIHRvIGAgOiBpc3N1ZS5pbmNsdXNpdmUgPyBgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIGAgOiBgZ3JlYXRlciB0aGFuIGB9JHtuZXcgRGF0ZShOdW1iZXIoaXNzdWUubWluaW11bSkpfWA7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IFwiSW52YWxpZCBpbnB1dFwiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLnRvb19iaWc6XG4gICAgICAgICAgICBpZiAoaXNzdWUudHlwZSA9PT0gXCJhcnJheVwiKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgQXJyYXkgbXVzdCBjb250YWluICR7aXNzdWUuZXhhY3QgPyBgZXhhY3RseWAgOiBpc3N1ZS5pbmNsdXNpdmUgPyBgYXQgbW9zdGAgOiBgbGVzcyB0aGFuYH0gJHtpc3N1ZS5tYXhpbXVtfSBlbGVtZW50KHMpYDtcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLnR5cGUgPT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBTdHJpbmcgbXVzdCBjb250YWluICR7aXNzdWUuZXhhY3QgPyBgZXhhY3RseWAgOiBpc3N1ZS5pbmNsdXNpdmUgPyBgYXQgbW9zdGAgOiBgdW5kZXJgfSAke2lzc3VlLm1heGltdW19IGNoYXJhY3RlcihzKWA7XG4gICAgICAgICAgICBlbHNlIGlmIChpc3N1ZS50eXBlID09PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgTnVtYmVyIG11c3QgYmUgJHtpc3N1ZS5leGFjdCA/IGBleGFjdGx5YCA6IGlzc3VlLmluY2x1c2l2ZSA/IGBsZXNzIHRoYW4gb3IgZXF1YWwgdG9gIDogYGxlc3MgdGhhbmB9ICR7aXNzdWUubWF4aW11bX1gO1xuICAgICAgICAgICAgZWxzZSBpZiAoaXNzdWUudHlwZSA9PT0gXCJiaWdpbnRcIilcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gYEJpZ0ludCBtdXN0IGJlICR7aXNzdWUuZXhhY3QgPyBgZXhhY3RseWAgOiBpc3N1ZS5pbmNsdXNpdmUgPyBgbGVzcyB0aGFuIG9yIGVxdWFsIHRvYCA6IGBsZXNzIHRoYW5gfSAke2lzc3VlLm1heGltdW19YDtcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLnR5cGUgPT09IFwiZGF0ZVwiKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgRGF0ZSBtdXN0IGJlICR7aXNzdWUuZXhhY3QgPyBgZXhhY3RseWAgOiBpc3N1ZS5pbmNsdXNpdmUgPyBgc21hbGxlciB0aGFuIG9yIGVxdWFsIHRvYCA6IGBzbWFsbGVyIHRoYW5gfSAke25ldyBEYXRlKE51bWJlcihpc3N1ZS5tYXhpbXVtKSl9YDtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gXCJJbnZhbGlkIGlucHV0XCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUuY3VzdG9tOlxuICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGlucHV0YDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX2ludGVyc2VjdGlvbl90eXBlczpcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgSW50ZXJzZWN0aW9uIHJlc3VsdHMgY291bGQgbm90IGJlIG1lcmdlZGA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUubm90X211bHRpcGxlX29mOlxuICAgICAgICAgICAgbWVzc2FnZSA9IGBOdW1iZXIgbXVzdCBiZSBhIG11bHRpcGxlIG9mICR7aXNzdWUubXVsdGlwbGVPZn1gO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLm5vdF9maW5pdGU6XG4gICAgICAgICAgICBtZXNzYWdlID0gXCJOdW1iZXIgbXVzdCBiZSBmaW5pdGVcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgbWVzc2FnZSA9IF9jdHguZGVmYXVsdEVycm9yO1xuICAgICAgICAgICAgdXRpbC5hc3NlcnROZXZlcihpc3N1ZSk7XG4gICAgfVxuICAgIHJldHVybiB7IG1lc3NhZ2UgfTtcbn07XG5leHBvcnQgZGVmYXVsdCBlcnJvck1hcDtcbiIsImltcG9ydCBkZWZhdWx0RXJyb3JNYXAgZnJvbSBcIi4vbG9jYWxlcy9lbi5qc1wiO1xubGV0IG92ZXJyaWRlRXJyb3JNYXAgPSBkZWZhdWx0RXJyb3JNYXA7XG5leHBvcnQgeyBkZWZhdWx0RXJyb3JNYXAgfTtcbmV4cG9ydCBmdW5jdGlvbiBzZXRFcnJvck1hcChtYXApIHtcbiAgICBvdmVycmlkZUVycm9yTWFwID0gbWFwO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldEVycm9yTWFwKCkge1xuICAgIHJldHVybiBvdmVycmlkZUVycm9yTWFwO1xufVxuIiwiaW1wb3J0IHsgZ2V0RXJyb3JNYXAgfSBmcm9tIFwiLi4vZXJyb3JzLmpzXCI7XG5pbXBvcnQgZGVmYXVsdEVycm9yTWFwIGZyb20gXCIuLi9sb2NhbGVzL2VuLmpzXCI7XG5leHBvcnQgY29uc3QgbWFrZUlzc3VlID0gKHBhcmFtcykgPT4ge1xuICAgIGNvbnN0IHsgZGF0YSwgcGF0aCwgZXJyb3JNYXBzLCBpc3N1ZURhdGEgfSA9IHBhcmFtcztcbiAgICBjb25zdCBmdWxsUGF0aCA9IFsuLi5wYXRoLCAuLi4oaXNzdWVEYXRhLnBhdGggfHwgW10pXTtcbiAgICBjb25zdCBmdWxsSXNzdWUgPSB7XG4gICAgICAgIC4uLmlzc3VlRGF0YSxcbiAgICAgICAgcGF0aDogZnVsbFBhdGgsXG4gICAgfTtcbiAgICBpZiAoaXNzdWVEYXRhLm1lc3NhZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uaXNzdWVEYXRhLFxuICAgICAgICAgICAgcGF0aDogZnVsbFBhdGgsXG4gICAgICAgICAgICBtZXNzYWdlOiBpc3N1ZURhdGEubWVzc2FnZSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgbGV0IGVycm9yTWVzc2FnZSA9IFwiXCI7XG4gICAgY29uc3QgbWFwcyA9IGVycm9yTWFwc1xuICAgICAgICAuZmlsdGVyKChtKSA9PiAhIW0pXG4gICAgICAgIC5zbGljZSgpXG4gICAgICAgIC5yZXZlcnNlKCk7XG4gICAgZm9yIChjb25zdCBtYXAgb2YgbWFwcykge1xuICAgICAgICBlcnJvck1lc3NhZ2UgPSBtYXAoZnVsbElzc3VlLCB7IGRhdGEsIGRlZmF1bHRFcnJvcjogZXJyb3JNZXNzYWdlIH0pLm1lc3NhZ2U7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIC4uLmlzc3VlRGF0YSxcbiAgICAgICAgcGF0aDogZnVsbFBhdGgsXG4gICAgICAgIG1lc3NhZ2U6IGVycm9yTWVzc2FnZSxcbiAgICB9O1xufTtcbmV4cG9ydCBjb25zdCBFTVBUWV9QQVRIID0gW107XG5leHBvcnQgZnVuY3Rpb24gYWRkSXNzdWVUb0NvbnRleHQoY3R4LCBpc3N1ZURhdGEpIHtcbiAgICBjb25zdCBvdmVycmlkZU1hcCA9IGdldEVycm9yTWFwKCk7XG4gICAgY29uc3QgaXNzdWUgPSBtYWtlSXNzdWUoe1xuICAgICAgICBpc3N1ZURhdGE6IGlzc3VlRGF0YSxcbiAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICBlcnJvck1hcHM6IFtcbiAgICAgICAgICAgIGN0eC5jb21tb24uY29udGV4dHVhbEVycm9yTWFwLCAvLyBjb250ZXh0dWFsIGVycm9yIG1hcCBpcyBmaXJzdCBwcmlvcml0eVxuICAgICAgICAgICAgY3R4LnNjaGVtYUVycm9yTWFwLCAvLyB0aGVuIHNjaGVtYS1ib3VuZCBtYXAgaWYgYXZhaWxhYmxlXG4gICAgICAgICAgICBvdmVycmlkZU1hcCwgLy8gdGhlbiBnbG9iYWwgb3ZlcnJpZGUgbWFwXG4gICAgICAgICAgICBvdmVycmlkZU1hcCA9PT0gZGVmYXVsdEVycm9yTWFwID8gdW5kZWZpbmVkIDogZGVmYXVsdEVycm9yTWFwLCAvLyB0aGVuIGdsb2JhbCBkZWZhdWx0IG1hcFxuICAgICAgICBdLmZpbHRlcigoeCkgPT4gISF4KSxcbiAgICB9KTtcbiAgICBjdHguY29tbW9uLmlzc3Vlcy5wdXNoKGlzc3VlKTtcbn1cbmV4cG9ydCBjbGFzcyBQYXJzZVN0YXR1cyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSBcInZhbGlkXCI7XG4gICAgfVxuICAgIGRpcnR5KCkge1xuICAgICAgICBpZiAodGhpcy52YWx1ZSA9PT0gXCJ2YWxpZFwiKVxuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IFwiZGlydHlcIjtcbiAgICB9XG4gICAgYWJvcnQoKSB7XG4gICAgICAgIGlmICh0aGlzLnZhbHVlICE9PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBcImFib3J0ZWRcIjtcbiAgICB9XG4gICAgc3RhdGljIG1lcmdlQXJyYXkoc3RhdHVzLCByZXN1bHRzKSB7XG4gICAgICAgIGNvbnN0IGFycmF5VmFsdWUgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBzIG9mIHJlc3VsdHMpIHtcbiAgICAgICAgICAgIGlmIChzLnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICBpZiAocy5zdGF0dXMgPT09IFwiZGlydHlcIilcbiAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgIGFycmF5VmFsdWUucHVzaChzLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGFycmF5VmFsdWUgfTtcbiAgICB9XG4gICAgc3RhdGljIGFzeW5jIG1lcmdlT2JqZWN0QXN5bmMoc3RhdHVzLCBwYWlycykge1xuICAgICAgICBjb25zdCBzeW5jUGFpcnMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBwYWlyIG9mIHBhaXJzKSB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBhd2FpdCBwYWlyLmtleTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgcGFpci52YWx1ZTtcbiAgICAgICAgICAgIHN5bmNQYWlycy5wdXNoKHtcbiAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUGFyc2VTdGF0dXMubWVyZ2VPYmplY3RTeW5jKHN0YXR1cywgc3luY1BhaXJzKTtcbiAgICB9XG4gICAgc3RhdGljIG1lcmdlT2JqZWN0U3luYyhzdGF0dXMsIHBhaXJzKSB7XG4gICAgICAgIGNvbnN0IGZpbmFsT2JqZWN0ID0ge307XG4gICAgICAgIGZvciAoY29uc3QgcGFpciBvZiBwYWlycykge1xuICAgICAgICAgICAgY29uc3QgeyBrZXksIHZhbHVlIH0gPSBwYWlyO1xuICAgICAgICAgICAgaWYgKGtleS5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgaWYgKHZhbHVlLnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICBpZiAoa2V5LnN0YXR1cyA9PT0gXCJkaXJ0eVwiKVxuICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgaWYgKHZhbHVlLnN0YXR1cyA9PT0gXCJkaXJ0eVwiKVxuICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgaWYgKGtleS52YWx1ZSAhPT0gXCJfX3Byb3RvX19cIiAmJiAodHlwZW9mIHZhbHVlLnZhbHVlICE9PSBcInVuZGVmaW5lZFwiIHx8IHBhaXIuYWx3YXlzU2V0KSkge1xuICAgICAgICAgICAgICAgIGZpbmFsT2JqZWN0W2tleS52YWx1ZV0gPSB2YWx1ZS52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGZpbmFsT2JqZWN0IH07XG4gICAgfVxufVxuZXhwb3J0IGNvbnN0IElOVkFMSUQgPSBPYmplY3QuZnJlZXplKHtcbiAgICBzdGF0dXM6IFwiYWJvcnRlZFwiLFxufSk7XG5leHBvcnQgY29uc3QgRElSVFkgPSAodmFsdWUpID0+ICh7IHN0YXR1czogXCJkaXJ0eVwiLCB2YWx1ZSB9KTtcbmV4cG9ydCBjb25zdCBPSyA9ICh2YWx1ZSkgPT4gKHsgc3RhdHVzOiBcInZhbGlkXCIsIHZhbHVlIH0pO1xuZXhwb3J0IGNvbnN0IGlzQWJvcnRlZCA9ICh4KSA9PiB4LnN0YXR1cyA9PT0gXCJhYm9ydGVkXCI7XG5leHBvcnQgY29uc3QgaXNEaXJ0eSA9ICh4KSA9PiB4LnN0YXR1cyA9PT0gXCJkaXJ0eVwiO1xuZXhwb3J0IGNvbnN0IGlzVmFsaWQgPSAoeCkgPT4geC5zdGF0dXMgPT09IFwidmFsaWRcIjtcbmV4cG9ydCBjb25zdCBpc0FzeW5jID0gKHgpID0+IHR5cGVvZiBQcm9taXNlICE9PSBcInVuZGVmaW5lZFwiICYmIHggaW5zdGFuY2VvZiBQcm9taXNlO1xuIiwiZXhwb3J0IHZhciBlcnJvclV0aWw7XG4oZnVuY3Rpb24gKGVycm9yVXRpbCkge1xuICAgIGVycm9yVXRpbC5lcnJUb09iaiA9IChtZXNzYWdlKSA9PiB0eXBlb2YgbWVzc2FnZSA9PT0gXCJzdHJpbmdcIiA/IHsgbWVzc2FnZSB9IDogbWVzc2FnZSB8fCB7fTtcbiAgICAvLyBiaW9tZS1pZ25vcmUgbGludDpcbiAgICBlcnJvclV0aWwudG9TdHJpbmcgPSAobWVzc2FnZSkgPT4gdHlwZW9mIG1lc3NhZ2UgPT09IFwic3RyaW5nXCIgPyBtZXNzYWdlIDogbWVzc2FnZT8ubWVzc2FnZTtcbn0pKGVycm9yVXRpbCB8fCAoZXJyb3JVdGlsID0ge30pKTtcbiIsImltcG9ydCB7IFpvZEVycm9yLCBab2RJc3N1ZUNvZGUsIH0gZnJvbSBcIi4vWm9kRXJyb3IuanNcIjtcbmltcG9ydCB7IGRlZmF1bHRFcnJvck1hcCwgZ2V0RXJyb3JNYXAgfSBmcm9tIFwiLi9lcnJvcnMuanNcIjtcbmltcG9ydCB7IGVycm9yVXRpbCB9IGZyb20gXCIuL2hlbHBlcnMvZXJyb3JVdGlsLmpzXCI7XG5pbXBvcnQgeyBESVJUWSwgSU5WQUxJRCwgT0ssIFBhcnNlU3RhdHVzLCBhZGRJc3N1ZVRvQ29udGV4dCwgaXNBYm9ydGVkLCBpc0FzeW5jLCBpc0RpcnR5LCBpc1ZhbGlkLCBtYWtlSXNzdWUsIH0gZnJvbSBcIi4vaGVscGVycy9wYXJzZVV0aWwuanNcIjtcbmltcG9ydCB7IHV0aWwsIFpvZFBhcnNlZFR5cGUsIGdldFBhcnNlZFR5cGUgfSBmcm9tIFwiLi9oZWxwZXJzL3V0aWwuanNcIjtcbmNsYXNzIFBhcnNlSW5wdXRMYXp5UGF0aCB7XG4gICAgY29uc3RydWN0b3IocGFyZW50LCB2YWx1ZSwgcGF0aCwga2V5KSB7XG4gICAgICAgIHRoaXMuX2NhY2hlZFBhdGggPSBbXTtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIHRoaXMuZGF0YSA9IHZhbHVlO1xuICAgICAgICB0aGlzLl9wYXRoID0gcGF0aDtcbiAgICAgICAgdGhpcy5fa2V5ID0ga2V5O1xuICAgIH1cbiAgICBnZXQgcGF0aCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9jYWNoZWRQYXRoLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5fa2V5KSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlZFBhdGgucHVzaCguLi50aGlzLl9wYXRoLCAuLi50aGlzLl9rZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2FjaGVkUGF0aC5wdXNoKC4uLnRoaXMuX3BhdGgsIHRoaXMuX2tleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlZFBhdGg7XG4gICAgfVxufVxuY29uc3QgaGFuZGxlUmVzdWx0ID0gKGN0eCwgcmVzdWx0KSA9PiB7XG4gICAgaWYgKGlzVmFsaWQocmVzdWx0KSkge1xuICAgICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlLCBkYXRhOiByZXN1bHQudmFsdWUgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmICghY3R4LmNvbW1vbi5pc3N1ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJWYWxpZGF0aW9uIGZhaWxlZCBidXQgbm8gaXNzdWVzIGRldGVjdGVkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICBnZXQgZXJyb3IoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2Vycm9yKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZXJyb3I7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgWm9kRXJyb3IoY3R4LmNvbW1vbi5pc3N1ZXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2Vycm9yID0gZXJyb3I7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Vycm9yO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG59O1xuZnVuY3Rpb24gcHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpIHtcbiAgICBpZiAoIXBhcmFtcylcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIGNvbnN0IHsgZXJyb3JNYXAsIGludmFsaWRfdHlwZV9lcnJvciwgcmVxdWlyZWRfZXJyb3IsIGRlc2NyaXB0aW9uIH0gPSBwYXJhbXM7XG4gICAgaWYgKGVycm9yTWFwICYmIChpbnZhbGlkX3R5cGVfZXJyb3IgfHwgcmVxdWlyZWRfZXJyb3IpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2FuJ3QgdXNlIFwiaW52YWxpZF90eXBlX2Vycm9yXCIgb3IgXCJyZXF1aXJlZF9lcnJvclwiIGluIGNvbmp1bmN0aW9uIHdpdGggY3VzdG9tIGVycm9yIG1hcC5gKTtcbiAgICB9XG4gICAgaWYgKGVycm9yTWFwKVxuICAgICAgICByZXR1cm4geyBlcnJvck1hcDogZXJyb3JNYXAsIGRlc2NyaXB0aW9uIH07XG4gICAgY29uc3QgY3VzdG9tTWFwID0gKGlzcywgY3R4KSA9PiB7XG4gICAgICAgIGNvbnN0IHsgbWVzc2FnZSB9ID0gcGFyYW1zO1xuICAgICAgICBpZiAoaXNzLmNvZGUgPT09IFwiaW52YWxpZF9lbnVtX3ZhbHVlXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB7IG1lc3NhZ2U6IG1lc3NhZ2UgPz8gY3R4LmRlZmF1bHRFcnJvciB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgY3R4LmRhdGEgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB7IG1lc3NhZ2U6IG1lc3NhZ2UgPz8gcmVxdWlyZWRfZXJyb3IgPz8gY3R4LmRlZmF1bHRFcnJvciB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc3MuY29kZSAhPT0gXCJpbnZhbGlkX3R5cGVcIilcbiAgICAgICAgICAgIHJldHVybiB7IG1lc3NhZ2U6IGN0eC5kZWZhdWx0RXJyb3IgfTtcbiAgICAgICAgcmV0dXJuIHsgbWVzc2FnZTogbWVzc2FnZSA/PyBpbnZhbGlkX3R5cGVfZXJyb3IgPz8gY3R4LmRlZmF1bHRFcnJvciB9O1xuICAgIH07XG4gICAgcmV0dXJuIHsgZXJyb3JNYXA6IGN1c3RvbU1hcCwgZGVzY3JpcHRpb24gfTtcbn1cbmV4cG9ydCBjbGFzcyBab2RUeXBlIHtcbiAgICBnZXQgZGVzY3JpcHRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuZGVzY3JpcHRpb247XG4gICAgfVxuICAgIF9nZXRUeXBlKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBnZXRQYXJzZWRUeXBlKGlucHV0LmRhdGEpO1xuICAgIH1cbiAgICBfZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCkge1xuICAgICAgICByZXR1cm4gKGN0eCB8fCB7XG4gICAgICAgICAgICBjb21tb246IGlucHV0LnBhcmVudC5jb21tb24sXG4gICAgICAgICAgICBkYXRhOiBpbnB1dC5kYXRhLFxuICAgICAgICAgICAgcGFyc2VkVHlwZTogZ2V0UGFyc2VkVHlwZShpbnB1dC5kYXRhKSxcbiAgICAgICAgICAgIHNjaGVtYUVycm9yTWFwOiB0aGlzLl9kZWYuZXJyb3JNYXAsXG4gICAgICAgICAgICBwYXRoOiBpbnB1dC5wYXRoLFxuICAgICAgICAgICAgcGFyZW50OiBpbnB1dC5wYXJlbnQsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdGF0dXM6IG5ldyBQYXJzZVN0YXR1cygpLFxuICAgICAgICAgICAgY3R4OiB7XG4gICAgICAgICAgICAgICAgY29tbW9uOiBpbnB1dC5wYXJlbnQuY29tbW9uLFxuICAgICAgICAgICAgICAgIGRhdGE6IGlucHV0LmRhdGEsXG4gICAgICAgICAgICAgICAgcGFyc2VkVHlwZTogZ2V0UGFyc2VkVHlwZShpbnB1dC5kYXRhKSxcbiAgICAgICAgICAgICAgICBzY2hlbWFFcnJvck1hcDogdGhpcy5fZGVmLmVycm9yTWFwLFxuICAgICAgICAgICAgICAgIHBhdGg6IGlucHV0LnBhdGgsXG4gICAgICAgICAgICAgICAgcGFyZW50OiBpbnB1dC5wYXJlbnQsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBfcGFyc2VTeW5jKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX3BhcnNlKGlucHV0KTtcbiAgICAgICAgaWYgKGlzQXN5bmMocmVzdWx0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3luY2hyb25vdXMgcGFyc2UgZW5jb3VudGVyZWQgcHJvbWlzZS5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgX3BhcnNlQXN5bmMoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fcGFyc2UoaW5wdXQpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCk7XG4gICAgfVxuICAgIHBhcnNlKGRhdGEsIHBhcmFtcykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnNhZmVQYXJzZShkYXRhLCBwYXJhbXMpO1xuICAgICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LmRhdGE7XG4gICAgICAgIHRocm93IHJlc3VsdC5lcnJvcjtcbiAgICB9XG4gICAgc2FmZVBhcnNlKGRhdGEsIHBhcmFtcykge1xuICAgICAgICBjb25zdCBjdHggPSB7XG4gICAgICAgICAgICBjb21tb246IHtcbiAgICAgICAgICAgICAgICBpc3N1ZXM6IFtdLFxuICAgICAgICAgICAgICAgIGFzeW5jOiBwYXJhbXM/LmFzeW5jID8/IGZhbHNlLFxuICAgICAgICAgICAgICAgIGNvbnRleHR1YWxFcnJvck1hcDogcGFyYW1zPy5lcnJvck1hcCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwYXRoOiBwYXJhbXM/LnBhdGggfHwgW10sXG4gICAgICAgICAgICBzY2hlbWFFcnJvck1hcDogdGhpcy5fZGVmLmVycm9yTWFwLFxuICAgICAgICAgICAgcGFyZW50OiBudWxsLFxuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgIHBhcnNlZFR5cGU6IGdldFBhcnNlZFR5cGUoZGF0YSksXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX3BhcnNlU3luYyh7IGRhdGEsIHBhdGg6IGN0eC5wYXRoLCBwYXJlbnQ6IGN0eCB9KTtcbiAgICAgICAgcmV0dXJuIGhhbmRsZVJlc3VsdChjdHgsIHJlc3VsdCk7XG4gICAgfVxuICAgIFwifnZhbGlkYXRlXCIoZGF0YSkge1xuICAgICAgICBjb25zdCBjdHggPSB7XG4gICAgICAgICAgICBjb21tb246IHtcbiAgICAgICAgICAgICAgICBpc3N1ZXM6IFtdLFxuICAgICAgICAgICAgICAgIGFzeW5jOiAhIXRoaXNbXCJ+c3RhbmRhcmRcIl0uYXN5bmMsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGF0aDogW10sXG4gICAgICAgICAgICBzY2hlbWFFcnJvck1hcDogdGhpcy5fZGVmLmVycm9yTWFwLFxuICAgICAgICAgICAgcGFyZW50OiBudWxsLFxuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgIHBhcnNlZFR5cGU6IGdldFBhcnNlZFR5cGUoZGF0YSksXG4gICAgICAgIH07XG4gICAgICAgIGlmICghdGhpc1tcIn5zdGFuZGFyZFwiXS5hc3luYykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9wYXJzZVN5bmMoeyBkYXRhLCBwYXRoOiBbXSwgcGFyZW50OiBjdHggfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzVmFsaWQocmVzdWx0KVxuICAgICAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiByZXN1bHQudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc3N1ZXM6IGN0eC5jb21tb24uaXNzdWVzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGlmIChlcnI/Lm1lc3NhZ2U/LnRvTG93ZXJDYXNlKCk/LmluY2x1ZGVzKFwiZW5jb3VudGVyZWRcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1tcIn5zdGFuZGFyZFwiXS5hc3luYyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN0eC5jb21tb24gPSB7XG4gICAgICAgICAgICAgICAgICAgIGlzc3VlczogW10sXG4gICAgICAgICAgICAgICAgICAgIGFzeW5jOiB0cnVlLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcnNlQXN5bmMoeyBkYXRhLCBwYXRoOiBbXSwgcGFyZW50OiBjdHggfSkudGhlbigocmVzdWx0KSA9PiBpc1ZhbGlkKHJlc3VsdClcbiAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgIHZhbHVlOiByZXN1bHQudmFsdWUsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICBpc3N1ZXM6IGN0eC5jb21tb24uaXNzdWVzLFxuICAgICAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIHBhcnNlQXN5bmMoZGF0YSwgcGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuc2FmZVBhcnNlQXN5bmMoZGF0YSwgcGFyYW1zKTtcbiAgICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzKVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5kYXRhO1xuICAgICAgICB0aHJvdyByZXN1bHQuZXJyb3I7XG4gICAgfVxuICAgIGFzeW5jIHNhZmVQYXJzZUFzeW5jKGRhdGEsIHBhcmFtcykge1xuICAgICAgICBjb25zdCBjdHggPSB7XG4gICAgICAgICAgICBjb21tb246IHtcbiAgICAgICAgICAgICAgICBpc3N1ZXM6IFtdLFxuICAgICAgICAgICAgICAgIGNvbnRleHR1YWxFcnJvck1hcDogcGFyYW1zPy5lcnJvck1hcCxcbiAgICAgICAgICAgICAgICBhc3luYzogdHJ1ZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwYXRoOiBwYXJhbXM/LnBhdGggfHwgW10sXG4gICAgICAgICAgICBzY2hlbWFFcnJvck1hcDogdGhpcy5fZGVmLmVycm9yTWFwLFxuICAgICAgICAgICAgcGFyZW50OiBudWxsLFxuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgIHBhcnNlZFR5cGU6IGdldFBhcnNlZFR5cGUoZGF0YSksXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG1heWJlQXN5bmNSZXN1bHQgPSB0aGlzLl9wYXJzZSh7IGRhdGEsIHBhdGg6IGN0eC5wYXRoLCBwYXJlbnQ6IGN0eCB9KTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgKGlzQXN5bmMobWF5YmVBc3luY1Jlc3VsdCkgPyBtYXliZUFzeW5jUmVzdWx0IDogUHJvbWlzZS5yZXNvbHZlKG1heWJlQXN5bmNSZXN1bHQpKTtcbiAgICAgICAgcmV0dXJuIGhhbmRsZVJlc3VsdChjdHgsIHJlc3VsdCk7XG4gICAgfVxuICAgIHJlZmluZShjaGVjaywgbWVzc2FnZSkge1xuICAgICAgICBjb25zdCBnZXRJc3N1ZVByb3BlcnRpZXMgPSAodmFsKSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIG1lc3NhZ2UgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBtZXNzYWdlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2UodmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVmaW5lbWVudCgodmFsLCBjdHgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGNoZWNrKHZhbCk7XG4gICAgICAgICAgICBjb25zdCBzZXRFcnJvciA9ICgpID0+IGN0eC5hZGRJc3N1ZSh7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmN1c3RvbSxcbiAgICAgICAgICAgICAgICAuLi5nZXRJc3N1ZVByb3BlcnRpZXModmFsKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBQcm9taXNlICE9PSBcInVuZGVmaW5lZFwiICYmIHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0LnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRFcnJvcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgc2V0RXJyb3IoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlZmluZW1lbnQoY2hlY2ssIHJlZmluZW1lbnREYXRhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWZpbmVtZW50KCh2YWwsIGN0eCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFjaGVjayh2YWwpKSB7XG4gICAgICAgICAgICAgICAgY3R4LmFkZElzc3VlKHR5cGVvZiByZWZpbmVtZW50RGF0YSA9PT0gXCJmdW5jdGlvblwiID8gcmVmaW5lbWVudERhdGEodmFsLCBjdHgpIDogcmVmaW5lbWVudERhdGEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX3JlZmluZW1lbnQocmVmaW5lbWVudCkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZEVmZmVjdHMoe1xuICAgICAgICAgICAgc2NoZW1hOiB0aGlzLFxuICAgICAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RFZmZlY3RzLFxuICAgICAgICAgICAgZWZmZWN0OiB7IHR5cGU6IFwicmVmaW5lbWVudFwiLCByZWZpbmVtZW50IH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdXBlclJlZmluZShyZWZpbmVtZW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWZpbmVtZW50KHJlZmluZW1lbnQpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihkZWYpIHtcbiAgICAgICAgLyoqIEFsaWFzIG9mIHNhZmVQYXJzZUFzeW5jICovXG4gICAgICAgIHRoaXMuc3BhID0gdGhpcy5zYWZlUGFyc2VBc3luYztcbiAgICAgICAgdGhpcy5fZGVmID0gZGVmO1xuICAgICAgICB0aGlzLnBhcnNlID0gdGhpcy5wYXJzZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNhZmVQYXJzZSA9IHRoaXMuc2FmZVBhcnNlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucGFyc2VBc3luYyA9IHRoaXMucGFyc2VBc3luYy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNhZmVQYXJzZUFzeW5jID0gdGhpcy5zYWZlUGFyc2VBc3luYy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNwYSA9IHRoaXMuc3BhLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucmVmaW5lID0gdGhpcy5yZWZpbmUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5yZWZpbmVtZW50ID0gdGhpcy5yZWZpbmVtZW50LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc3VwZXJSZWZpbmUgPSB0aGlzLnN1cGVyUmVmaW5lLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub3B0aW9uYWwgPSB0aGlzLm9wdGlvbmFsLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMubnVsbGFibGUgPSB0aGlzLm51bGxhYmxlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMubnVsbGlzaCA9IHRoaXMubnVsbGlzaC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmFycmF5ID0gdGhpcy5hcnJheS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnByb21pc2UgPSB0aGlzLnByb21pc2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vciA9IHRoaXMub3IuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5hbmQgPSB0aGlzLmFuZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnRyYW5zZm9ybSA9IHRoaXMudHJhbnNmb3JtLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuYnJhbmQgPSB0aGlzLmJyYW5kLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZGVmYXVsdCA9IHRoaXMuZGVmYXVsdC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmNhdGNoID0gdGhpcy5jYXRjaC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmRlc2NyaWJlID0gdGhpcy5kZXNjcmliZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnBpcGUgPSB0aGlzLnBpcGUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5yZWFkb25seSA9IHRoaXMucmVhZG9ubHkuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5pc051bGxhYmxlID0gdGhpcy5pc051bGxhYmxlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuaXNPcHRpb25hbCA9IHRoaXMuaXNPcHRpb25hbC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzW1wifnN0YW5kYXJkXCJdID0ge1xuICAgICAgICAgICAgdmVyc2lvbjogMSxcbiAgICAgICAgICAgIHZlbmRvcjogXCJ6b2RcIixcbiAgICAgICAgICAgIHZhbGlkYXRlOiAoZGF0YSkgPT4gdGhpc1tcIn52YWxpZGF0ZVwiXShkYXRhKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgb3B0aW9uYWwoKSB7XG4gICAgICAgIHJldHVybiBab2RPcHRpb25hbC5jcmVhdGUodGhpcywgdGhpcy5fZGVmKTtcbiAgICB9XG4gICAgbnVsbGFibGUoKSB7XG4gICAgICAgIHJldHVybiBab2ROdWxsYWJsZS5jcmVhdGUodGhpcywgdGhpcy5fZGVmKTtcbiAgICB9XG4gICAgbnVsbGlzaCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubnVsbGFibGUoKS5vcHRpb25hbCgpO1xuICAgIH1cbiAgICBhcnJheSgpIHtcbiAgICAgICAgcmV0dXJuIFpvZEFycmF5LmNyZWF0ZSh0aGlzKTtcbiAgICB9XG4gICAgcHJvbWlzZSgpIHtcbiAgICAgICAgcmV0dXJuIFpvZFByb21pc2UuY3JlYXRlKHRoaXMsIHRoaXMuX2RlZik7XG4gICAgfVxuICAgIG9yKG9wdGlvbikge1xuICAgICAgICByZXR1cm4gWm9kVW5pb24uY3JlYXRlKFt0aGlzLCBvcHRpb25dLCB0aGlzLl9kZWYpO1xuICAgIH1cbiAgICBhbmQoaW5jb21pbmcpIHtcbiAgICAgICAgcmV0dXJuIFpvZEludGVyc2VjdGlvbi5jcmVhdGUodGhpcywgaW5jb21pbmcsIHRoaXMuX2RlZik7XG4gICAgfVxuICAgIHRyYW5zZm9ybSh0cmFuc2Zvcm0pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RFZmZlY3RzKHtcbiAgICAgICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXModGhpcy5fZGVmKSxcbiAgICAgICAgICAgIHNjaGVtYTogdGhpcyxcbiAgICAgICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRWZmZWN0cyxcbiAgICAgICAgICAgIGVmZmVjdDogeyB0eXBlOiBcInRyYW5zZm9ybVwiLCB0cmFuc2Zvcm0gfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGRlZmF1bHQoZGVmKSB7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRWYWx1ZUZ1bmMgPSB0eXBlb2YgZGVmID09PSBcImZ1bmN0aW9uXCIgPyBkZWYgOiAoKSA9PiBkZWY7XG4gICAgICAgIHJldHVybiBuZXcgWm9kRGVmYXVsdCh7XG4gICAgICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHRoaXMuX2RlZiksXG4gICAgICAgICAgICBpbm5lclR5cGU6IHRoaXMsXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWU6IGRlZmF1bHRWYWx1ZUZ1bmMsXG4gICAgICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZERlZmF1bHQsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBicmFuZCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RCcmFuZGVkKHtcbiAgICAgICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kQnJhbmRlZCxcbiAgICAgICAgICAgIHR5cGU6IHRoaXMsXG4gICAgICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHRoaXMuX2RlZiksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjYXRjaChkZWYpIHtcbiAgICAgICAgY29uc3QgY2F0Y2hWYWx1ZUZ1bmMgPSB0eXBlb2YgZGVmID09PSBcImZ1bmN0aW9uXCIgPyBkZWYgOiAoKSA9PiBkZWY7XG4gICAgICAgIHJldHVybiBuZXcgWm9kQ2F0Y2goe1xuICAgICAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyh0aGlzLl9kZWYpLFxuICAgICAgICAgICAgaW5uZXJUeXBlOiB0aGlzLFxuICAgICAgICAgICAgY2F0Y2hWYWx1ZTogY2F0Y2hWYWx1ZUZ1bmMsXG4gICAgICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZENhdGNoLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZGVzY3JpYmUoZGVzY3JpcHRpb24pIHtcbiAgICAgICAgY29uc3QgVGhpcyA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgICAgIHJldHVybiBuZXcgVGhpcyh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHBpcGUodGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiBab2RQaXBlbGluZS5jcmVhdGUodGhpcywgdGFyZ2V0KTtcbiAgICB9XG4gICAgcmVhZG9ubHkoKSB7XG4gICAgICAgIHJldHVybiBab2RSZWFkb25seS5jcmVhdGUodGhpcyk7XG4gICAgfVxuICAgIGlzT3B0aW9uYWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNhZmVQYXJzZSh1bmRlZmluZWQpLnN1Y2Nlc3M7XG4gICAgfVxuICAgIGlzTnVsbGFibGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNhZmVQYXJzZShudWxsKS5zdWNjZXNzO1xuICAgIH1cbn1cbmNvbnN0IGN1aWRSZWdleCA9IC9eY1teXFxzLV17OCx9JC9pO1xuY29uc3QgY3VpZDJSZWdleCA9IC9eWzAtOWEtel0rJC87XG5jb25zdCB1bGlkUmVnZXggPSAvXlswLTlBLUhKS01OUC1UVi1aXXsyNn0kL2k7XG4vLyBjb25zdCB1dWlkUmVnZXggPVxuLy8gICAvXihbYS1mMC05XXs4fS1bYS1mMC05XXs0fS1bMS01XVthLWYwLTldezN9LVthLWYwLTldezR9LVthLWYwLTldezEyfXwwMDAwMDAwMC0wMDAwLTAwMDAtMDAwMC0wMDAwMDAwMDAwMDApJC9pO1xuY29uc3QgdXVpZFJlZ2V4ID0gL15bMC05YS1mQS1GXXs4fVxcYi1bMC05YS1mQS1GXXs0fVxcYi1bMC05YS1mQS1GXXs0fVxcYi1bMC05YS1mQS1GXXs0fVxcYi1bMC05YS1mQS1GXXsxMn0kL2k7XG5jb25zdCBuYW5vaWRSZWdleCA9IC9eW2EtejAtOV8tXXsyMX0kL2k7XG5jb25zdCBqd3RSZWdleCA9IC9eW0EtWmEtejAtOS1fXStcXC5bQS1aYS16MC05LV9dK1xcLltBLVphLXowLTktX10qJC87XG5jb25zdCBkdXJhdGlvblJlZ2V4ID0gL15bLStdP1AoPyEkKSg/Oig/OlstK10/XFxkK1kpfCg/OlstK10/XFxkK1suLF1cXGQrWSQpKT8oPzooPzpbLStdP1xcZCtNKXwoPzpbLStdP1xcZCtbLixdXFxkK00kKSk/KD86KD86Wy0rXT9cXGQrVyl8KD86Wy0rXT9cXGQrWy4sXVxcZCtXJCkpPyg/Oig/OlstK10/XFxkK0QpfCg/OlstK10/XFxkK1suLF1cXGQrRCQpKT8oPzpUKD89W1xcZCstXSkoPzooPzpbLStdP1xcZCtIKXwoPzpbLStdP1xcZCtbLixdXFxkK0gkKSk/KD86KD86Wy0rXT9cXGQrTSl8KD86Wy0rXT9cXGQrWy4sXVxcZCtNJCkpPyg/OlstK10/XFxkKyg/OlsuLF1cXGQrKT9TKT8pPz8kLztcbi8vIGZyb20gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzQ2MTgxLzE1NTAxNTVcbi8vIG9sZCB2ZXJzaW9uOiB0b28gc2xvdywgZGlkbid0IHN1cHBvcnQgdW5pY29kZVxuLy8gY29uc3QgZW1haWxSZWdleCA9IC9eKCgoW2Etel18XFxkfFshI1xcJCUmJ1xcKlxcK1xcLVxcLz1cXD9cXF5fYHtcXHx9fl18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKyhcXC4oW2Etel18XFxkfFshI1xcJCUmJ1xcKlxcK1xcLVxcLz1cXD9cXF5fYHtcXHx9fl18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKykqKXwoKFxceDIyKSgoKChcXHgyMHxcXHgwOSkqKFxceDBkXFx4MGEpKT8oXFx4MjB8XFx4MDkpKyk/KChbXFx4MDEtXFx4MDhcXHgwYlxceDBjXFx4MGUtXFx4MWZcXHg3Zl18XFx4MjF8W1xceDIzLVxceDViXXxbXFx4NWQtXFx4N2VdfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKXwoXFxcXChbXFx4MDEtXFx4MDlcXHgwYlxceDBjXFx4MGQtXFx4N2ZdfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSkpKSooKChcXHgyMHxcXHgwOSkqKFxceDBkXFx4MGEpKT8oXFx4MjB8XFx4MDkpKyk/KFxceDIyKSkpQCgoKFthLXpdfFxcZHxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSl8KChbYS16XXxcXGR8W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKFthLXpdfFxcZHwtfFxcLnxffH58W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKihbYS16XXxcXGR8W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKSlcXC4pKygoW2Etel18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pfCgoW2Etel18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKFthLXpdfFxcZHwtfFxcLnxffH58W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKihbYS16XXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkpKSQvaTtcbi8vb2xkIGVtYWlsIHJlZ2V4XG4vLyBjb25zdCBlbWFpbFJlZ2V4ID0gL14oKFtePD4oKVtcXF0uLDs6XFxzQFwiXSsoXFwuW148PigpW1xcXS4sOzpcXHNAXCJdKykqKXwoXCIuK1wiKSlAKCg/IS0pKFtePD4oKVtcXF0uLDs6XFxzQFwiXStcXC4pK1tePD4oKVtcXF0uLDs6XFxzQFwiXXsxLH0pW14tPD4oKVtcXF0uLDs6XFxzQFwiXSQvaTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuLy8gY29uc3QgZW1haWxSZWdleCA9XG4vLyAgIC9eKChbXjw+KClbXFxdXFxcXC4sOzpcXHNAXFxcIl0rKFxcLltePD4oKVtcXF1cXFxcLiw7Olxcc0BcXFwiXSspKil8KFxcXCIuK1xcXCIpKUAoKFxcWygoKDI1WzAtNV0pfCgyWzAtNF1bMC05XSl8KDFbMC05XXsyfSl8KFswLTldezEsMn0pKVxcLil7M30oKDI1WzAtNV0pfCgyWzAtNF1bMC05XSl8KDFbMC05XXsyfSl8KFswLTldezEsMn0pKVxcXSl8KFxcW0lQdjY6KChbYS1mMC05XXsxLDR9Oil7N318OjooW2EtZjAtOV17MSw0fTopezAsNn18KFthLWYwLTldezEsNH06KXsxfTooW2EtZjAtOV17MSw0fTopezAsNX18KFthLWYwLTldezEsNH06KXsyfTooW2EtZjAtOV17MSw0fTopezAsNH18KFthLWYwLTldezEsNH06KXszfTooW2EtZjAtOV17MSw0fTopezAsM318KFthLWYwLTldezEsNH06KXs0fTooW2EtZjAtOV17MSw0fTopezAsMn18KFthLWYwLTldezEsNH06KXs1fTooW2EtZjAtOV17MSw0fTopezAsMX0pKFthLWYwLTldezEsNH18KCgoMjVbMC01XSl8KDJbMC00XVswLTldKXwoMVswLTldezJ9KXwoWzAtOV17MSwyfSkpXFwuKXszfSgoMjVbMC01XSl8KDJbMC00XVswLTldKXwoMVswLTldezJ9KXwoWzAtOV17MSwyfSkpKVxcXSl8KFtBLVphLXowLTldKFtBLVphLXowLTktXSpbQS1aYS16MC05XSkqKFxcLltBLVphLXpdezIsfSkrKSkkLztcbi8vIGNvbnN0IGVtYWlsUmVnZXggPVxuLy8gICAvXlthLXpBLVowLTlcXC5cXCFcXCNcXCRcXCVcXCZcXCdcXCpcXCtcXC9cXD1cXD9cXF5cXF9cXGBcXHtcXHxcXH1cXH5cXC1dK0BbYS16QS1aMC05XSg/OlthLXpBLVowLTktXXswLDYxfVthLXpBLVowLTldKT8oPzpcXC5bYS16QS1aMC05XSg/OlthLXpBLVowLTktXXswLDYxfVthLXpBLVowLTldKT8pKiQvO1xuLy8gY29uc3QgZW1haWxSZWdleCA9XG4vLyAgIC9eKD86W2EtejAtOSEjJCUmJyorLz0/Xl9ge3x9fi1dKyg/OlxcLlthLXowLTkhIyQlJicqKy89P15fYHt8fX4tXSspKnxcIig/OltcXHgwMS1cXHgwOFxceDBiXFx4MGNcXHgwZS1cXHgxZlxceDIxXFx4MjMtXFx4NWJcXHg1ZC1cXHg3Zl18XFxcXFtcXHgwMS1cXHgwOVxceDBiXFx4MGNcXHgwZS1cXHg3Zl0pKlwiKUAoPzooPzpbYS16MC05XSg/OlthLXowLTktXSpbYS16MC05XSk/XFwuKStbYS16MC05XSg/OlthLXowLTktXSpbYS16MC05XSk/fFxcWyg/Oig/OjI1WzAtNV18MlswLTRdWzAtOV18WzAxXT9bMC05XVswLTldPylcXC4pezN9KD86MjVbMC01XXwyWzAtNF1bMC05XXxbMDFdP1swLTldWzAtOV0/fFthLXowLTktXSpbYS16MC05XTooPzpbXFx4MDEtXFx4MDhcXHgwYlxceDBjXFx4MGUtXFx4MWZcXHgyMS1cXHg1YVxceDUzLVxceDdmXXxcXFxcW1xceDAxLVxceDA5XFx4MGJcXHgwY1xceDBlLVxceDdmXSkrKVxcXSkkL2k7XG5jb25zdCBlbWFpbFJlZ2V4ID0gL14oPyFcXC4pKD8hLipcXC5cXC4pKFtBLVowLTlfJytcXC1cXC5dKilbQS1aMC05XystXUAoW0EtWjAtOV1bQS1aMC05XFwtXSpcXC4pK1tBLVpdezIsfSQvaTtcbi8vIGNvbnN0IGVtYWlsUmVnZXggPVxuLy8gICAvXlthLXowLTkuISMkJSbigJkqKy89P15fYHt8fX4tXStAW2EtejAtOS1dKyg/OlxcLlthLXowLTlcXC1dKykqJC9pO1xuLy8gZnJvbSBodHRwczovL3RoZWtldmluc2NvdHQuY29tL2Vtb2ppcy1pbi1qYXZhc2NyaXB0LyN3cml0aW5nLWEtcmVndWxhci1leHByZXNzaW9uXG5jb25zdCBfZW1vamlSZWdleCA9IGBeKFxcXFxwe0V4dGVuZGVkX1BpY3RvZ3JhcGhpY318XFxcXHB7RW1vamlfQ29tcG9uZW50fSkrJGA7XG5sZXQgZW1vamlSZWdleDtcbi8vIGZhc3Rlciwgc2ltcGxlciwgc2FmZXJcbmNvbnN0IGlwdjRSZWdleCA9IC9eKD86KD86MjVbMC01XXwyWzAtNF1bMC05XXwxWzAtOV1bMC05XXxbMS05XVswLTldfFswLTldKVxcLil7M30oPzoyNVswLTVdfDJbMC00XVswLTldfDFbMC05XVswLTldfFsxLTldWzAtOV18WzAtOV0pJC87XG5jb25zdCBpcHY0Q2lkclJlZ2V4ID0gL14oPzooPzoyNVswLTVdfDJbMC00XVswLTldfDFbMC05XVswLTldfFsxLTldWzAtOV18WzAtOV0pXFwuKXszfSg/OjI1WzAtNV18MlswLTRdWzAtOV18MVswLTldWzAtOV18WzEtOV1bMC05XXxbMC05XSlcXC8oM1swLTJdfFsxMl0/WzAtOV0pJC87XG4vLyBjb25zdCBpcHY2UmVnZXggPVxuLy8gL14oKFthLWYwLTldezEsNH06KXs3fXw6OihbYS1mMC05XXsxLDR9Oil7MCw2fXwoW2EtZjAtOV17MSw0fTopezF9OihbYS1mMC05XXsxLDR9Oil7MCw1fXwoW2EtZjAtOV17MSw0fTopezJ9OihbYS1mMC05XXsxLDR9Oil7MCw0fXwoW2EtZjAtOV17MSw0fTopezN9OihbYS1mMC05XXsxLDR9Oil7MCwzfXwoW2EtZjAtOV17MSw0fTopezR9OihbYS1mMC05XXsxLDR9Oil7MCwyfXwoW2EtZjAtOV17MSw0fTopezV9OihbYS1mMC05XXsxLDR9Oil7MCwxfSkoW2EtZjAtOV17MSw0fXwoKCgyNVswLTVdKXwoMlswLTRdWzAtOV0pfCgxWzAtOV17Mn0pfChbMC05XXsxLDJ9KSlcXC4pezN9KCgyNVswLTVdKXwoMlswLTRdWzAtOV0pfCgxWzAtOV17Mn0pfChbMC05XXsxLDJ9KSkpJC87XG5jb25zdCBpcHY2UmVnZXggPSAvXigoWzAtOWEtZkEtRl17MSw0fTopezcsN31bMC05YS1mQS1GXXsxLDR9fChbMC05YS1mQS1GXXsxLDR9Oil7MSw3fTp8KFswLTlhLWZBLUZdezEsNH06KXsxLDZ9OlswLTlhLWZBLUZdezEsNH18KFswLTlhLWZBLUZdezEsNH06KXsxLDV9KDpbMC05YS1mQS1GXXsxLDR9KXsxLDJ9fChbMC05YS1mQS1GXXsxLDR9Oil7MSw0fSg6WzAtOWEtZkEtRl17MSw0fSl7MSwzfXwoWzAtOWEtZkEtRl17MSw0fTopezEsM30oOlswLTlhLWZBLUZdezEsNH0pezEsNH18KFswLTlhLWZBLUZdezEsNH06KXsxLDJ9KDpbMC05YS1mQS1GXXsxLDR9KXsxLDV9fFswLTlhLWZBLUZdezEsNH06KCg6WzAtOWEtZkEtRl17MSw0fSl7MSw2fSl8OigoOlswLTlhLWZBLUZdezEsNH0pezEsN318Oil8ZmU4MDooOlswLTlhLWZBLUZdezAsNH0pezAsNH0lWzAtOWEtekEtWl17MSx9fDo6KGZmZmYoOjB7MSw0fSl7MCwxfTopezAsMX0oKDI1WzAtNV18KDJbMC00XXwxezAsMX1bMC05XSl7MCwxfVswLTldKVxcLil7MywzfSgyNVswLTVdfCgyWzAtNF18MXswLDF9WzAtOV0pezAsMX1bMC05XSl8KFswLTlhLWZBLUZdezEsNH06KXsxLDR9OigoMjVbMC01XXwoMlswLTRdfDF7MCwxfVswLTldKXswLDF9WzAtOV0pXFwuKXszLDN9KDI1WzAtNV18KDJbMC00XXwxezAsMX1bMC05XSl7MCwxfVswLTldKSkkLztcbmNvbnN0IGlwdjZDaWRyUmVnZXggPSAvXigoWzAtOWEtZkEtRl17MSw0fTopezcsN31bMC05YS1mQS1GXXsxLDR9fChbMC05YS1mQS1GXXsxLDR9Oil7MSw3fTp8KFswLTlhLWZBLUZdezEsNH06KXsxLDZ9OlswLTlhLWZBLUZdezEsNH18KFswLTlhLWZBLUZdezEsNH06KXsxLDV9KDpbMC05YS1mQS1GXXsxLDR9KXsxLDJ9fChbMC05YS1mQS1GXXsxLDR9Oil7MSw0fSg6WzAtOWEtZkEtRl17MSw0fSl7MSwzfXwoWzAtOWEtZkEtRl17MSw0fTopezEsM30oOlswLTlhLWZBLUZdezEsNH0pezEsNH18KFswLTlhLWZBLUZdezEsNH06KXsxLDJ9KDpbMC05YS1mQS1GXXsxLDR9KXsxLDV9fFswLTlhLWZBLUZdezEsNH06KCg6WzAtOWEtZkEtRl17MSw0fSl7MSw2fSl8OigoOlswLTlhLWZBLUZdezEsNH0pezEsN318Oil8ZmU4MDooOlswLTlhLWZBLUZdezAsNH0pezAsNH0lWzAtOWEtekEtWl17MSx9fDo6KGZmZmYoOjB7MSw0fSl7MCwxfTopezAsMX0oKDI1WzAtNV18KDJbMC00XXwxezAsMX1bMC05XSl7MCwxfVswLTldKVxcLil7MywzfSgyNVswLTVdfCgyWzAtNF18MXswLDF9WzAtOV0pezAsMX1bMC05XSl8KFswLTlhLWZBLUZdezEsNH06KXsxLDR9OigoMjVbMC01XXwoMlswLTRdfDF7MCwxfVswLTldKXswLDF9WzAtOV0pXFwuKXszLDN9KDI1WzAtNV18KDJbMC00XXwxezAsMX1bMC05XSl7MCwxfVswLTldKSlcXC8oMTJbMC04XXwxWzAxXVswLTldfFsxLTldP1swLTldKSQvO1xuLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNzg2MDM5Mi9kZXRlcm1pbmUtaWYtc3RyaW5nLWlzLWluLWJhc2U2NC11c2luZy1qYXZhc2NyaXB0XG5jb25zdCBiYXNlNjRSZWdleCA9IC9eKFswLTlhLXpBLVorL117NH0pKigoWzAtOWEtekEtWisvXXsyfT09KXwoWzAtOWEtekEtWisvXXszfT0pKT8kLztcbi8vIGh0dHBzOi8vYmFzZTY0Lmd1cnUvc3RhbmRhcmRzL2Jhc2U2NHVybFxuY29uc3QgYmFzZTY0dXJsUmVnZXggPSAvXihbMC05YS16QS1aLV9dezR9KSooKFswLTlhLXpBLVotX117Mn0oPT0pPyl8KFswLTlhLXpBLVotX117M30oPSk/KSk/JC87XG4vLyBzaW1wbGVcbi8vIGNvbnN0IGRhdGVSZWdleFNvdXJjZSA9IGBcXFxcZHs0fS1cXFxcZHsyfS1cXFxcZHsyfWA7XG4vLyBubyBsZWFwIHllYXIgdmFsaWRhdGlvblxuLy8gY29uc3QgZGF0ZVJlZ2V4U291cmNlID0gYFxcXFxkezR9LSgoMFsxMzU3OF18MTB8MTIpLTMxfCgwWzEzLTldfDFbMC0yXSktMzB8KDBbMS05XXwxWzAtMl0pLSgwWzEtOV18MVxcXFxkfDJcXFxcZCkpYDtcbi8vIHdpdGggbGVhcCB5ZWFyIHZhbGlkYXRpb25cbmNvbnN0IGRhdGVSZWdleFNvdXJjZSA9IGAoKFxcXFxkXFxcXGRbMjQ2OF1bMDQ4XXxcXFxcZFxcXFxkWzEzNTc5XVsyNl18XFxcXGRcXFxcZDBbNDhdfFswMjQ2OF1bMDQ4XTAwfFsxMzU3OV1bMjZdMDApLTAyLTI5fFxcXFxkezR9LSgoMFsxMzU3OF18MVswMl0pLSgwWzEtOV18WzEyXVxcXFxkfDNbMDFdKXwoMFs0NjldfDExKS0oMFsxLTldfFsxMl1cXFxcZHwzMCl8KDAyKS0oMFsxLTldfDFcXFxcZHwyWzAtOF0pKSlgO1xuY29uc3QgZGF0ZVJlZ2V4ID0gbmV3IFJlZ0V4cChgXiR7ZGF0ZVJlZ2V4U291cmNlfSRgKTtcbmZ1bmN0aW9uIHRpbWVSZWdleFNvdXJjZShhcmdzKSB7XG4gICAgbGV0IHNlY29uZHNSZWdleFNvdXJjZSA9IGBbMC01XVxcXFxkYDtcbiAgICBpZiAoYXJncy5wcmVjaXNpb24pIHtcbiAgICAgICAgc2Vjb25kc1JlZ2V4U291cmNlID0gYCR7c2Vjb25kc1JlZ2V4U291cmNlfVxcXFwuXFxcXGR7JHthcmdzLnByZWNpc2lvbn19YDtcbiAgICB9XG4gICAgZWxzZSBpZiAoYXJncy5wcmVjaXNpb24gPT0gbnVsbCkge1xuICAgICAgICBzZWNvbmRzUmVnZXhTb3VyY2UgPSBgJHtzZWNvbmRzUmVnZXhTb3VyY2V9KFxcXFwuXFxcXGQrKT9gO1xuICAgIH1cbiAgICBjb25zdCBzZWNvbmRzUXVhbnRpZmllciA9IGFyZ3MucHJlY2lzaW9uID8gXCIrXCIgOiBcIj9cIjsgLy8gcmVxdWlyZSBzZWNvbmRzIGlmIHByZWNpc2lvbiBpcyBub256ZXJvXG4gICAgcmV0dXJuIGAoWzAxXVxcXFxkfDJbMC0zXSk6WzAtNV1cXFxcZCg6JHtzZWNvbmRzUmVnZXhTb3VyY2V9KSR7c2Vjb25kc1F1YW50aWZpZXJ9YDtcbn1cbmZ1bmN0aW9uIHRpbWVSZWdleChhcmdzKSB7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoYF4ke3RpbWVSZWdleFNvdXJjZShhcmdzKX0kYCk7XG59XG4vLyBBZGFwdGVkIGZyb20gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzMxNDMyMzFcbmV4cG9ydCBmdW5jdGlvbiBkYXRldGltZVJlZ2V4KGFyZ3MpIHtcbiAgICBsZXQgcmVnZXggPSBgJHtkYXRlUmVnZXhTb3VyY2V9VCR7dGltZVJlZ2V4U291cmNlKGFyZ3MpfWA7XG4gICAgY29uc3Qgb3B0cyA9IFtdO1xuICAgIG9wdHMucHVzaChhcmdzLmxvY2FsID8gYFo/YCA6IGBaYCk7XG4gICAgaWYgKGFyZ3Mub2Zmc2V0KVxuICAgICAgICBvcHRzLnB1c2goYChbKy1dXFxcXGR7Mn06P1xcXFxkezJ9KWApO1xuICAgIHJlZ2V4ID0gYCR7cmVnZXh9KCR7b3B0cy5qb2luKFwifFwiKX0pYDtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChgXiR7cmVnZXh9JGApO1xufVxuZnVuY3Rpb24gaXNWYWxpZElQKGlwLCB2ZXJzaW9uKSB7XG4gICAgaWYgKCh2ZXJzaW9uID09PSBcInY0XCIgfHwgIXZlcnNpb24pICYmIGlwdjRSZWdleC50ZXN0KGlwKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCh2ZXJzaW9uID09PSBcInY2XCIgfHwgIXZlcnNpb24pICYmIGlwdjZSZWdleC50ZXN0KGlwKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNWYWxpZEpXVChqd3QsIGFsZykge1xuICAgIGlmICghand0UmVnZXgudGVzdChqd3QpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgW2hlYWRlcl0gPSBqd3Quc3BsaXQoXCIuXCIpO1xuICAgICAgICBpZiAoIWhlYWRlcilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgLy8gQ29udmVydCBiYXNlNjR1cmwgdG8gYmFzZTY0XG4gICAgICAgIGNvbnN0IGJhc2U2NCA9IGhlYWRlclxuICAgICAgICAgICAgLnJlcGxhY2UoLy0vZywgXCIrXCIpXG4gICAgICAgICAgICAucmVwbGFjZSgvXy9nLCBcIi9cIilcbiAgICAgICAgICAgIC5wYWRFbmQoaGVhZGVyLmxlbmd0aCArICgoNCAtIChoZWFkZXIubGVuZ3RoICUgNCkpICUgNCksIFwiPVwiKTtcbiAgICAgICAgY29uc3QgZGVjb2RlZCA9IEpTT04ucGFyc2UoYXRvYihiYXNlNjQpKTtcbiAgICAgICAgaWYgKHR5cGVvZiBkZWNvZGVkICE9PSBcIm9iamVjdFwiIHx8IGRlY29kZWQgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChcInR5cFwiIGluIGRlY29kZWQgJiYgZGVjb2RlZD8udHlwICE9PSBcIkpXVFwiKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoIWRlY29kZWQuYWxnKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoYWxnICYmIGRlY29kZWQuYWxnICE9PSBhbGcpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjYXRjaCB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBpc1ZhbGlkQ2lkcihpcCwgdmVyc2lvbikge1xuICAgIGlmICgodmVyc2lvbiA9PT0gXCJ2NFwiIHx8ICF2ZXJzaW9uKSAmJiBpcHY0Q2lkclJlZ2V4LnRlc3QoaXApKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoKHZlcnNpb24gPT09IFwidjZcIiB8fCAhdmVyc2lvbikgJiYgaXB2NkNpZHJSZWdleC50ZXN0KGlwKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZXhwb3J0IGNsYXNzIFpvZFN0cmluZyBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBpZiAodGhpcy5fZGVmLmNvZXJjZSkge1xuICAgICAgICAgICAgaW5wdXQuZGF0YSA9IFN0cmluZyhpbnB1dC5kYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLnN0cmluZykge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5zdHJpbmcsXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdGF0dXMgPSBuZXcgUGFyc2VTdGF0dXMoKTtcbiAgICAgICAgbGV0IGN0eCA9IHVuZGVmaW5lZDtcbiAgICAgICAgZm9yIChjb25zdCBjaGVjayBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICAgICAgICBpZiAoY2hlY2sua2luZCA9PT0gXCJtaW5cIikge1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dC5kYXRhLmxlbmd0aCA8IGNoZWNrLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fc21hbGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5pbXVtOiBjaGVjay52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBleGFjdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJtYXhcIikge1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dC5kYXRhLmxlbmd0aCA+IGNoZWNrLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fYmlnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4aW11bTogY2hlY2sudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwibGVuZ3RoXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b29CaWcgPSBpbnB1dC5kYXRhLmxlbmd0aCA+IGNoZWNrLnZhbHVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvb1NtYWxsID0gaW5wdXQuZGF0YS5sZW5ndGggPCBjaGVjay52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAodG9vQmlnIHx8IHRvb1NtYWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodG9vQmlnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX2JpZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXhpbXVtOiBjaGVjay52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGFjdDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodG9vU21hbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fc21hbGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluaW11bTogY2hlY2sudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiZW1haWxcIikge1xuICAgICAgICAgICAgICAgIGlmICghZW1haWxSZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwiZW1haWxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImVtb2ppXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWVtb2ppUmVnZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgZW1vamlSZWdleCA9IG5ldyBSZWdFeHAoX2Vtb2ppUmVnZXgsIFwidVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFlbW9qaVJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJlbW9qaVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwidXVpZFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF1dWlkUmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcInV1aWRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcIm5hbm9pZFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFuYW5vaWRSZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwibmFub2lkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJjdWlkXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWN1aWRSZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwiY3VpZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiY3VpZDJcIikge1xuICAgICAgICAgICAgICAgIGlmICghY3VpZDJSZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwiY3VpZDJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcInVsaWRcIikge1xuICAgICAgICAgICAgICAgIGlmICghdWxpZFJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJ1bGlkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJ1cmxcIikge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIG5ldyBVUkwoaW5wdXQuZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJ1cmxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcInJlZ2V4XCIpIHtcbiAgICAgICAgICAgICAgICBjaGVjay5yZWdleC5sYXN0SW5kZXggPSAwO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRlc3RSZXN1bHQgPSBjaGVjay5yZWdleC50ZXN0KGlucHV0LmRhdGEpO1xuICAgICAgICAgICAgICAgIGlmICghdGVzdFJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcInJlZ2V4XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJ0cmltXCIpIHtcbiAgICAgICAgICAgICAgICBpbnB1dC5kYXRhID0gaW5wdXQuZGF0YS50cmltKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImluY2x1ZGVzXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlucHV0LmRhdGEuaW5jbHVkZXMoY2hlY2sudmFsdWUsIGNoZWNrLnBvc2l0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiB7IGluY2x1ZGVzOiBjaGVjay52YWx1ZSwgcG9zaXRpb246IGNoZWNrLnBvc2l0aW9uIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJ0b0xvd2VyQ2FzZVwiKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQuZGF0YSA9IGlucHV0LmRhdGEudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwidG9VcHBlckNhc2VcIikge1xuICAgICAgICAgICAgICAgIGlucHV0LmRhdGEgPSBpbnB1dC5kYXRhLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcInN0YXJ0c1dpdGhcIikge1xuICAgICAgICAgICAgICAgIGlmICghaW5wdXQuZGF0YS5zdGFydHNXaXRoKGNoZWNrLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiB7IHN0YXJ0c1dpdGg6IGNoZWNrLnZhbHVlIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJlbmRzV2l0aFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpbnB1dC5kYXRhLmVuZHNXaXRoKGNoZWNrLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiB7IGVuZHNXaXRoOiBjaGVjay52YWx1ZSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiZGF0ZXRpbWVcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlZ2V4ID0gZGF0ZXRpbWVSZWdleChjaGVjayk7XG4gICAgICAgICAgICAgICAgaWYgKCFyZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwiZGF0ZXRpbWVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImRhdGVcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlZ2V4ID0gZGF0ZVJlZ2V4O1xuICAgICAgICAgICAgICAgIGlmICghcmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcImRhdGVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcInRpbWVcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlZ2V4ID0gdGltZVJlZ2V4KGNoZWNrKTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJ0aW1lXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJkdXJhdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFkdXJhdGlvblJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJkdXJhdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiaXBcIikge1xuICAgICAgICAgICAgICAgIGlmICghaXNWYWxpZElQKGlucHV0LmRhdGEsIGNoZWNrLnZlcnNpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwiaXBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImp3dFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1ZhbGlkSldUKGlucHV0LmRhdGEsIGNoZWNrLmFsZykpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJqd3RcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImNpZHJcIikge1xuICAgICAgICAgICAgICAgIGlmICghaXNWYWxpZENpZHIoaW5wdXQuZGF0YSwgY2hlY2sudmVyc2lvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJjaWRyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJiYXNlNjRcIikge1xuICAgICAgICAgICAgICAgIGlmICghYmFzZTY0UmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcImJhc2U2NFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiYmFzZTY0dXJsXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWJhc2U2NHVybFJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJiYXNlNjR1cmxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB1dGlsLmFzc2VydE5ldmVyKGNoZWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGlucHV0LmRhdGEgfTtcbiAgICB9XG4gICAgX3JlZ2V4KHJlZ2V4LCB2YWxpZGF0aW9uLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlZmluZW1lbnQoKGRhdGEpID0+IHJlZ2V4LnRlc3QoZGF0YSksIHtcbiAgICAgICAgICAgIHZhbGlkYXRpb24sXG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfYWRkQ2hlY2soY2hlY2spIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RTdHJpbmcoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgY2hlY2tzOiBbLi4udGhpcy5fZGVmLmNoZWNrcywgY2hlY2tdLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZW1haWwobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImVtYWlsXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSB9KTtcbiAgICB9XG4gICAgdXJsKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJ1cmxcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpIH0pO1xuICAgIH1cbiAgICBlbW9qaShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwiZW1vamlcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpIH0pO1xuICAgIH1cbiAgICB1dWlkKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJ1dWlkXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSB9KTtcbiAgICB9XG4gICAgbmFub2lkKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJuYW5vaWRcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpIH0pO1xuICAgIH1cbiAgICBjdWlkKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJjdWlkXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSB9KTtcbiAgICB9XG4gICAgY3VpZDIobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImN1aWQyXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSB9KTtcbiAgICB9XG4gICAgdWxpZChtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwidWxpZFwiLCAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkgfSk7XG4gICAgfVxuICAgIGJhc2U2NChtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwiYmFzZTY0XCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSB9KTtcbiAgICB9XG4gICAgYmFzZTY0dXJsKG1lc3NhZ2UpIHtcbiAgICAgICAgLy8gYmFzZTY0dXJsIGVuY29kaW5nIGlzIGEgbW9kaWZpY2F0aW9uIG9mIGJhc2U2NCB0aGF0IGNhbiBzYWZlbHkgYmUgdXNlZCBpbiBVUkxzIGFuZCBmaWxlbmFtZXNcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwiYmFzZTY0dXJsXCIsXG4gICAgICAgICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBqd3Qob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImp3dFwiLCAuLi5lcnJvclV0aWwuZXJyVG9PYmoob3B0aW9ucykgfSk7XG4gICAgfVxuICAgIGlwKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJpcFwiLCAuLi5lcnJvclV0aWwuZXJyVG9PYmoob3B0aW9ucykgfSk7XG4gICAgfVxuICAgIGNpZHIob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImNpZHJcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG9wdGlvbnMpIH0pO1xuICAgIH1cbiAgICBkYXRldGltZShvcHRpb25zKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgICAgICBraW5kOiBcImRhdGV0aW1lXCIsXG4gICAgICAgICAgICAgICAgcHJlY2lzaW9uOiBudWxsLFxuICAgICAgICAgICAgICAgIG9mZnNldDogZmFsc2UsXG4gICAgICAgICAgICAgICAgbG9jYWw6IGZhbHNlLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG9wdGlvbnMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJkYXRldGltZVwiLFxuICAgICAgICAgICAgcHJlY2lzaW9uOiB0eXBlb2Ygb3B0aW9ucz8ucHJlY2lzaW9uID09PSBcInVuZGVmaW5lZFwiID8gbnVsbCA6IG9wdGlvbnM/LnByZWNpc2lvbixcbiAgICAgICAgICAgIG9mZnNldDogb3B0aW9ucz8ub2Zmc2V0ID8/IGZhbHNlLFxuICAgICAgICAgICAgbG9jYWw6IG9wdGlvbnM/LmxvY2FsID8/IGZhbHNlLFxuICAgICAgICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG9wdGlvbnM/Lm1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZGF0ZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwiZGF0ZVwiLCBtZXNzYWdlIH0pO1xuICAgIH1cbiAgICB0aW1lKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAgICAgIGtpbmQ6IFwidGltZVwiLFxuICAgICAgICAgICAgICAgIHByZWNpc2lvbjogbnVsbCxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBvcHRpb25zLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwidGltZVwiLFxuICAgICAgICAgICAgcHJlY2lzaW9uOiB0eXBlb2Ygb3B0aW9ucz8ucHJlY2lzaW9uID09PSBcInVuZGVmaW5lZFwiID8gbnVsbCA6IG9wdGlvbnM/LnByZWNpc2lvbixcbiAgICAgICAgICAgIC4uLmVycm9yVXRpbC5lcnJUb09iaihvcHRpb25zPy5tZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGR1cmF0aW9uKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJkdXJhdGlvblwiLCAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkgfSk7XG4gICAgfVxuICAgIHJlZ2V4KHJlZ2V4LCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcInJlZ2V4XCIsXG4gICAgICAgICAgICByZWdleDogcmVnZXgsXG4gICAgICAgICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpbmNsdWRlcyh2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJpbmNsdWRlc1wiLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgcG9zaXRpb246IG9wdGlvbnM/LnBvc2l0aW9uLFxuICAgICAgICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG9wdGlvbnM/Lm1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhcnRzV2l0aCh2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJzdGFydHNXaXRoXCIsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbmRzV2l0aCh2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJlbmRzV2l0aFwiLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbWluKG1pbkxlbmd0aCwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtaW5cIixcbiAgICAgICAgICAgIHZhbHVlOiBtaW5MZW5ndGgsXG4gICAgICAgICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBtYXgobWF4TGVuZ3RoLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm1heFwiLFxuICAgICAgICAgICAgdmFsdWU6IG1heExlbmd0aCxcbiAgICAgICAgICAgIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGxlbmd0aChsZW4sIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibGVuZ3RoXCIsXG4gICAgICAgICAgICB2YWx1ZTogbGVuLFxuICAgICAgICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXF1aXZhbGVudCB0byBgLm1pbigxKWBcbiAgICAgKi9cbiAgICBub25lbXB0eShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbigxLCBlcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkpO1xuICAgIH1cbiAgICB0cmltKCkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZFN0cmluZyh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBjaGVja3M6IFsuLi50aGlzLl9kZWYuY2hlY2tzLCB7IGtpbmQ6IFwidHJpbVwiIH1dLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdG9Mb3dlckNhc2UoKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kU3RyaW5nKHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIGNoZWNrczogWy4uLnRoaXMuX2RlZi5jaGVja3MsIHsga2luZDogXCJ0b0xvd2VyQ2FzZVwiIH1dLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdG9VcHBlckNhc2UoKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kU3RyaW5nKHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIGNoZWNrczogWy4uLnRoaXMuX2RlZi5jaGVja3MsIHsga2luZDogXCJ0b1VwcGVyQ2FzZVwiIH1dLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0IGlzRGF0ZXRpbWUoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwiZGF0ZXRpbWVcIik7XG4gICAgfVxuICAgIGdldCBpc0RhdGUoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwiZGF0ZVwiKTtcbiAgICB9XG4gICAgZ2V0IGlzVGltZSgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJ0aW1lXCIpO1xuICAgIH1cbiAgICBnZXQgaXNEdXJhdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJkdXJhdGlvblwiKTtcbiAgICB9XG4gICAgZ2V0IGlzRW1haWwoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwiZW1haWxcIik7XG4gICAgfVxuICAgIGdldCBpc1VSTCgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJ1cmxcIik7XG4gICAgfVxuICAgIGdldCBpc0Vtb2ppKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImVtb2ppXCIpO1xuICAgIH1cbiAgICBnZXQgaXNVVUlEKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcInV1aWRcIik7XG4gICAgfVxuICAgIGdldCBpc05BTk9JRCgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJuYW5vaWRcIik7XG4gICAgfVxuICAgIGdldCBpc0NVSUQoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwiY3VpZFwiKTtcbiAgICB9XG4gICAgZ2V0IGlzQ1VJRDIoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwiY3VpZDJcIik7XG4gICAgfVxuICAgIGdldCBpc1VMSUQoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwidWxpZFwiKTtcbiAgICB9XG4gICAgZ2V0IGlzSVAoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwiaXBcIik7XG4gICAgfVxuICAgIGdldCBpc0NJRFIoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwiY2lkclwiKTtcbiAgICB9XG4gICAgZ2V0IGlzQmFzZTY0KCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImJhc2U2NFwiKTtcbiAgICB9XG4gICAgZ2V0IGlzQmFzZTY0dXJsKCkge1xuICAgICAgICAvLyBiYXNlNjR1cmwgZW5jb2RpbmcgaXMgYSBtb2RpZmljYXRpb24gb2YgYmFzZTY0IHRoYXQgY2FuIHNhZmVseSBiZSB1c2VkIGluIFVSTHMgYW5kIGZpbGVuYW1lc1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImJhc2U2NHVybFwiKTtcbiAgICB9XG4gICAgZ2V0IG1pbkxlbmd0aCgpIHtcbiAgICAgICAgbGV0IG1pbiA9IG51bGw7XG4gICAgICAgIGZvciAoY29uc3QgY2ggb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgICAgICAgaWYgKGNoLmtpbmQgPT09IFwibWluXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAobWluID09PSBudWxsIHx8IGNoLnZhbHVlID4gbWluKVxuICAgICAgICAgICAgICAgICAgICBtaW4gPSBjaC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWluO1xuICAgIH1cbiAgICBnZXQgbWF4TGVuZ3RoKCkge1xuICAgICAgICBsZXQgbWF4ID0gbnVsbDtcbiAgICAgICAgZm9yIChjb25zdCBjaCBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICAgICAgICBpZiAoY2gua2luZCA9PT0gXCJtYXhcIikge1xuICAgICAgICAgICAgICAgIGlmIChtYXggPT09IG51bGwgfHwgY2gudmFsdWUgPCBtYXgpXG4gICAgICAgICAgICAgICAgICAgIG1heCA9IGNoLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXg7XG4gICAgfVxufVxuWm9kU3RyaW5nLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZFN0cmluZyh7XG4gICAgICAgIGNoZWNrczogW10sXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kU3RyaW5nLFxuICAgICAgICBjb2VyY2U6IHBhcmFtcz8uY29lcmNlID8/IGZhbHNlLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzk2NjQ4NC93aHktZG9lcy1tb2R1bHVzLW9wZXJhdG9yLXJldHVybi1mcmFjdGlvbmFsLW51bWJlci1pbi1qYXZhc2NyaXB0LzMxNzExMDM0IzMxNzExMDM0XG5mdW5jdGlvbiBmbG9hdFNhZmVSZW1haW5kZXIodmFsLCBzdGVwKSB7XG4gICAgY29uc3QgdmFsRGVjQ291bnQgPSAodmFsLnRvU3RyaW5nKCkuc3BsaXQoXCIuXCIpWzFdIHx8IFwiXCIpLmxlbmd0aDtcbiAgICBjb25zdCBzdGVwRGVjQ291bnQgPSAoc3RlcC50b1N0cmluZygpLnNwbGl0KFwiLlwiKVsxXSB8fCBcIlwiKS5sZW5ndGg7XG4gICAgY29uc3QgZGVjQ291bnQgPSB2YWxEZWNDb3VudCA+IHN0ZXBEZWNDb3VudCA/IHZhbERlY0NvdW50IDogc3RlcERlY0NvdW50O1xuICAgIGNvbnN0IHZhbEludCA9IE51bWJlci5wYXJzZUludCh2YWwudG9GaXhlZChkZWNDb3VudCkucmVwbGFjZShcIi5cIiwgXCJcIikpO1xuICAgIGNvbnN0IHN0ZXBJbnQgPSBOdW1iZXIucGFyc2VJbnQoc3RlcC50b0ZpeGVkKGRlY0NvdW50KS5yZXBsYWNlKFwiLlwiLCBcIlwiKSk7XG4gICAgcmV0dXJuICh2YWxJbnQgJSBzdGVwSW50KSAvIDEwICoqIGRlY0NvdW50O1xufVxuZXhwb3J0IGNsYXNzIFpvZE51bWJlciBleHRlbmRzIFpvZFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm1pbiA9IHRoaXMuZ3RlO1xuICAgICAgICB0aGlzLm1heCA9IHRoaXMubHRlO1xuICAgICAgICB0aGlzLnN0ZXAgPSB0aGlzLm11bHRpcGxlT2Y7XG4gICAgfVxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBpZiAodGhpcy5fZGVmLmNvZXJjZSkge1xuICAgICAgICAgICAgaW5wdXQuZGF0YSA9IE51bWJlcihpbnB1dC5kYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLm51bWJlcikge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5udW1iZXIsXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY3R4ID0gdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBzdGF0dXMgPSBuZXcgUGFyc2VTdGF0dXMoKTtcbiAgICAgICAgZm9yIChjb25zdCBjaGVjayBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICAgICAgICBpZiAoY2hlY2sua2luZCA9PT0gXCJpbnRcIikge1xuICAgICAgICAgICAgICAgIGlmICghdXRpbC5pc0ludGVnZXIoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBcImludGVnZXJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBcImZsb2F0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJtaW5cIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvb1NtYWxsID0gY2hlY2suaW5jbHVzaXZlID8gaW5wdXQuZGF0YSA8IGNoZWNrLnZhbHVlIDogaW5wdXQuZGF0YSA8PSBjaGVjay52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAodG9vU21hbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19zbWFsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbmltdW06IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogY2hlY2suaW5jbHVzaXZlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwibWF4XCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b29CaWcgPSBjaGVjay5pbmNsdXNpdmUgPyBpbnB1dC5kYXRhID4gY2hlY2sudmFsdWUgOiBpbnB1dC5kYXRhID49IGNoZWNrLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmICh0b29CaWcpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19iaWcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhpbXVtOiBjaGVjay52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IGNoZWNrLmluY2x1c2l2ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcIm11bHRpcGxlT2ZcIikge1xuICAgICAgICAgICAgICAgIGlmIChmbG9hdFNhZmVSZW1haW5kZXIoaW5wdXQuZGF0YSwgY2hlY2sudmFsdWUpICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5ub3RfbXVsdGlwbGVfb2YsXG4gICAgICAgICAgICAgICAgICAgICAgICBtdWx0aXBsZU9mOiBjaGVjay52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImZpbml0ZVwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLm5vdF9maW5pdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdXRpbC5hc3NlcnROZXZlcihjaGVjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBpbnB1dC5kYXRhIH07XG4gICAgfVxuICAgIGd0ZSh2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRMaW1pdChcIm1pblwiLCB2YWx1ZSwgdHJ1ZSwgZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpKTtcbiAgICB9XG4gICAgZ3QodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0TGltaXQoXCJtaW5cIiwgdmFsdWUsIGZhbHNlLCBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkpO1xuICAgIH1cbiAgICBsdGUodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0TGltaXQoXCJtYXhcIiwgdmFsdWUsIHRydWUsIGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSk7XG4gICAgfVxuICAgIGx0KHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWF4XCIsIHZhbHVlLCBmYWxzZSwgZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpKTtcbiAgICB9XG4gICAgc2V0TGltaXQoa2luZCwgdmFsdWUsIGluY2x1c2l2ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZE51bWJlcih7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBjaGVja3M6IFtcbiAgICAgICAgICAgICAgICAuLi50aGlzLl9kZWYuY2hlY2tzLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAga2luZCxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2FkZENoZWNrKGNoZWNrKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kTnVtYmVyKHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIGNoZWNrczogWy4uLnRoaXMuX2RlZi5jaGVja3MsIGNoZWNrXSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGludChtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcImludFwiLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcG9zaXRpdmUobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtaW5cIixcbiAgICAgICAgICAgIHZhbHVlOiAwLFxuICAgICAgICAgICAgaW5jbHVzaXZlOiBmYWxzZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG5lZ2F0aXZlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWF4XCIsXG4gICAgICAgICAgICB2YWx1ZTogMCxcbiAgICAgICAgICAgIGluY2x1c2l2ZTogZmFsc2UsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBub25wb3NpdGl2ZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm1heFwiLFxuICAgICAgICAgICAgdmFsdWU6IDAsXG4gICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBub25uZWdhdGl2ZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm1pblwiLFxuICAgICAgICAgICAgdmFsdWU6IDAsXG4gICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBtdWx0aXBsZU9mKHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm11bHRpcGxlT2ZcIixcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZpbml0ZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcImZpbml0ZVwiLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2FmZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm1pblwiLFxuICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IE51bWJlci5NSU5fU0FGRV9JTlRFR0VSLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KS5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtYXhcIixcbiAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUixcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldCBtaW5WYWx1ZSgpIHtcbiAgICAgICAgbGV0IG1pbiA9IG51bGw7XG4gICAgICAgIGZvciAoY29uc3QgY2ggb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgICAgICAgaWYgKGNoLmtpbmQgPT09IFwibWluXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAobWluID09PSBudWxsIHx8IGNoLnZhbHVlID4gbWluKVxuICAgICAgICAgICAgICAgICAgICBtaW4gPSBjaC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWluO1xuICAgIH1cbiAgICBnZXQgbWF4VmFsdWUoKSB7XG4gICAgICAgIGxldCBtYXggPSBudWxsO1xuICAgICAgICBmb3IgKGNvbnN0IGNoIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcbiAgICAgICAgICAgIGlmIChjaC5raW5kID09PSBcIm1heFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1heCA9PT0gbnVsbCB8fCBjaC52YWx1ZSA8IG1heClcbiAgICAgICAgICAgICAgICAgICAgbWF4ID0gY2gudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1heDtcbiAgICB9XG4gICAgZ2V0IGlzSW50KCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImludFwiIHx8IChjaC5raW5kID09PSBcIm11bHRpcGxlT2ZcIiAmJiB1dGlsLmlzSW50ZWdlcihjaC52YWx1ZSkpKTtcbiAgICB9XG4gICAgZ2V0IGlzRmluaXRlKCkge1xuICAgICAgICBsZXQgbWF4ID0gbnVsbDtcbiAgICAgICAgbGV0IG1pbiA9IG51bGw7XG4gICAgICAgIGZvciAoY29uc3QgY2ggb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgICAgICAgaWYgKGNoLmtpbmQgPT09IFwiZmluaXRlXCIgfHwgY2gua2luZCA9PT0gXCJpbnRcIiB8fCBjaC5raW5kID09PSBcIm11bHRpcGxlT2ZcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2gua2luZCA9PT0gXCJtaW5cIikge1xuICAgICAgICAgICAgICAgIGlmIChtaW4gPT09IG51bGwgfHwgY2gudmFsdWUgPiBtaW4pXG4gICAgICAgICAgICAgICAgICAgIG1pbiA9IGNoLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2gua2luZCA9PT0gXCJtYXhcIikge1xuICAgICAgICAgICAgICAgIGlmIChtYXggPT09IG51bGwgfHwgY2gudmFsdWUgPCBtYXgpXG4gICAgICAgICAgICAgICAgICAgIG1heCA9IGNoLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBOdW1iZXIuaXNGaW5pdGUobWluKSAmJiBOdW1iZXIuaXNGaW5pdGUobWF4KTtcbiAgICB9XG59XG5ab2ROdW1iZXIuY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kTnVtYmVyKHtcbiAgICAgICAgY2hlY2tzOiBbXSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2ROdW1iZXIsXG4gICAgICAgIGNvZXJjZTogcGFyYW1zPy5jb2VyY2UgfHwgZmFsc2UsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5leHBvcnQgY2xhc3MgWm9kQmlnSW50IGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubWluID0gdGhpcy5ndGU7XG4gICAgICAgIHRoaXMubWF4ID0gdGhpcy5sdGU7XG4gICAgfVxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBpZiAodGhpcy5fZGVmLmNvZXJjZSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpbnB1dC5kYXRhID0gQmlnSW50KGlucHV0LmRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2gge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRJbnZhbGlkSW5wdXQoaW5wdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICAgICAgaWYgKHBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUuYmlnaW50KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0SW52YWxpZElucHV0KGlucHV0KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY3R4ID0gdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBzdGF0dXMgPSBuZXcgUGFyc2VTdGF0dXMoKTtcbiAgICAgICAgZm9yIChjb25zdCBjaGVjayBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICAgICAgICBpZiAoY2hlY2sua2luZCA9PT0gXCJtaW5cIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvb1NtYWxsID0gY2hlY2suaW5jbHVzaXZlID8gaW5wdXQuZGF0YSA8IGNoZWNrLnZhbHVlIDogaW5wdXQuZGF0YSA8PSBjaGVjay52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAodG9vU21hbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19zbWFsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiYmlnaW50XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5pbXVtOiBjaGVjay52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogY2hlY2suaW5jbHVzaXZlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwibWF4XCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b29CaWcgPSBjaGVjay5pbmNsdXNpdmUgPyBpbnB1dC5kYXRhID4gY2hlY2sudmFsdWUgOiBpbnB1dC5kYXRhID49IGNoZWNrLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmICh0b29CaWcpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19iaWcsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImJpZ2ludFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4aW11bTogY2hlY2sudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IGNoZWNrLmluY2x1c2l2ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcIm11bHRpcGxlT2ZcIikge1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dC5kYXRhICUgY2hlY2sudmFsdWUgIT09IEJpZ0ludCgwKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUubm90X211bHRpcGxlX29mLFxuICAgICAgICAgICAgICAgICAgICAgICAgbXVsdGlwbGVPZjogY2hlY2sudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdXRpbC5hc3NlcnROZXZlcihjaGVjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBpbnB1dC5kYXRhIH07XG4gICAgfVxuICAgIF9nZXRJbnZhbGlkSW5wdXQoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5iaWdpbnQsXG4gICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICB9XG4gICAgZ3RlKHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWluXCIsIHZhbHVlLCB0cnVlLCBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkpO1xuICAgIH1cbiAgICBndCh2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRMaW1pdChcIm1pblwiLCB2YWx1ZSwgZmFsc2UsIGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSk7XG4gICAgfVxuICAgIGx0ZSh2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRMaW1pdChcIm1heFwiLCB2YWx1ZSwgdHJ1ZSwgZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpKTtcbiAgICB9XG4gICAgbHQodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0TGltaXQoXCJtYXhcIiwgdmFsdWUsIGZhbHNlLCBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkpO1xuICAgIH1cbiAgICBzZXRMaW1pdChraW5kLCB2YWx1ZSwgaW5jbHVzaXZlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kQmlnSW50KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIGNoZWNrczogW1xuICAgICAgICAgICAgICAgIC4uLnRoaXMuX2RlZi5jaGVja3MsXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBraW5kLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfYWRkQ2hlY2soY2hlY2spIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RCaWdJbnQoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgY2hlY2tzOiBbLi4udGhpcy5fZGVmLmNoZWNrcywgY2hlY2tdLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcG9zaXRpdmUobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtaW5cIixcbiAgICAgICAgICAgIHZhbHVlOiBCaWdJbnQoMCksXG4gICAgICAgICAgICBpbmNsdXNpdmU6IGZhbHNlLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbmVnYXRpdmUobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtYXhcIixcbiAgICAgICAgICAgIHZhbHVlOiBCaWdJbnQoMCksXG4gICAgICAgICAgICBpbmNsdXNpdmU6IGZhbHNlLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbm9ucG9zaXRpdmUobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtYXhcIixcbiAgICAgICAgICAgIHZhbHVlOiBCaWdJbnQoMCksXG4gICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBub25uZWdhdGl2ZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm1pblwiLFxuICAgICAgICAgICAgdmFsdWU6IEJpZ0ludCgwKSxcbiAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG11bHRpcGxlT2YodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibXVsdGlwbGVPZlwiLFxuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXQgbWluVmFsdWUoKSB7XG4gICAgICAgIGxldCBtaW4gPSBudWxsO1xuICAgICAgICBmb3IgKGNvbnN0IGNoIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcbiAgICAgICAgICAgIGlmIChjaC5raW5kID09PSBcIm1pblwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1pbiA9PT0gbnVsbCB8fCBjaC52YWx1ZSA+IG1pbilcbiAgICAgICAgICAgICAgICAgICAgbWluID0gY2gudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1pbjtcbiAgICB9XG4gICAgZ2V0IG1heFZhbHVlKCkge1xuICAgICAgICBsZXQgbWF4ID0gbnVsbDtcbiAgICAgICAgZm9yIChjb25zdCBjaCBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICAgICAgICBpZiAoY2gua2luZCA9PT0gXCJtYXhcIikge1xuICAgICAgICAgICAgICAgIGlmIChtYXggPT09IG51bGwgfHwgY2gudmFsdWUgPCBtYXgpXG4gICAgICAgICAgICAgICAgICAgIG1heCA9IGNoLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXg7XG4gICAgfVxufVxuWm9kQmlnSW50LmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZEJpZ0ludCh7XG4gICAgICAgIGNoZWNrczogW10sXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kQmlnSW50LFxuICAgICAgICBjb2VyY2U6IHBhcmFtcz8uY29lcmNlID8/IGZhbHNlLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuZXhwb3J0IGNsYXNzIFpvZEJvb2xlYW4gZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RlZi5jb2VyY2UpIHtcbiAgICAgICAgICAgIGlucHV0LmRhdGEgPSBCb29sZWFuKGlucHV0LmRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICAgICAgaWYgKHBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUuYm9vbGVhbikge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5ib29sZWFuLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE9LKGlucHV0LmRhdGEpO1xuICAgIH1cbn1cblpvZEJvb2xlYW4uY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kQm9vbGVhbih7XG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kQm9vbGVhbixcbiAgICAgICAgY29lcmNlOiBwYXJhbXM/LmNvZXJjZSB8fCBmYWxzZSxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmV4cG9ydCBjbGFzcyBab2REYXRlIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGlmICh0aGlzLl9kZWYuY29lcmNlKSB7XG4gICAgICAgICAgICBpbnB1dC5kYXRhID0gbmV3IERhdGUoaW5wdXQuZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5kYXRlKSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLmRhdGUsXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoTnVtYmVyLmlzTmFOKGlucHV0LmRhdGEuZ2V0VGltZSgpKSkge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfZGF0ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RhdHVzID0gbmV3IFBhcnNlU3RhdHVzKCk7XG4gICAgICAgIGxldCBjdHggPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAoY29uc3QgY2hlY2sgb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgICAgICAgaWYgKGNoZWNrLmtpbmQgPT09IFwibWluXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQuZGF0YS5nZXRUaW1lKCkgPCBjaGVjay52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX3NtYWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbmltdW06IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJkYXRlXCIsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcIm1heFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0LmRhdGEuZ2V0VGltZSgpID4gY2hlY2sudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19iaWcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4aW11bTogY2hlY2sudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImRhdGVcIixcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHV0aWwuYXNzZXJ0TmV2ZXIoY2hlY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdGF0dXM6IHN0YXR1cy52YWx1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBuZXcgRGF0ZShpbnB1dC5kYXRhLmdldFRpbWUoKSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIF9hZGRDaGVjayhjaGVjaykge1xuICAgICAgICByZXR1cm4gbmV3IFpvZERhdGUoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgY2hlY2tzOiBbLi4udGhpcy5fZGVmLmNoZWNrcywgY2hlY2tdLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbWluKG1pbkRhdGUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWluXCIsXG4gICAgICAgICAgICB2YWx1ZTogbWluRGF0ZS5nZXRUaW1lKCksXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBtYXgobWF4RGF0ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtYXhcIixcbiAgICAgICAgICAgIHZhbHVlOiBtYXhEYXRlLmdldFRpbWUoKSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldCBtaW5EYXRlKCkge1xuICAgICAgICBsZXQgbWluID0gbnVsbDtcbiAgICAgICAgZm9yIChjb25zdCBjaCBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICAgICAgICBpZiAoY2gua2luZCA9PT0gXCJtaW5cIikge1xuICAgICAgICAgICAgICAgIGlmIChtaW4gPT09IG51bGwgfHwgY2gudmFsdWUgPiBtaW4pXG4gICAgICAgICAgICAgICAgICAgIG1pbiA9IGNoLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtaW4gIT0gbnVsbCA/IG5ldyBEYXRlKG1pbikgOiBudWxsO1xuICAgIH1cbiAgICBnZXQgbWF4RGF0ZSgpIHtcbiAgICAgICAgbGV0IG1heCA9IG51bGw7XG4gICAgICAgIGZvciAoY29uc3QgY2ggb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgICAgICAgaWYgKGNoLmtpbmQgPT09IFwibWF4XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAobWF4ID09PSBudWxsIHx8IGNoLnZhbHVlIDwgbWF4KVxuICAgICAgICAgICAgICAgICAgICBtYXggPSBjaC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWF4ICE9IG51bGwgPyBuZXcgRGF0ZShtYXgpIDogbnVsbDtcbiAgICB9XG59XG5ab2REYXRlLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZERhdGUoe1xuICAgICAgICBjaGVja3M6IFtdLFxuICAgICAgICBjb2VyY2U6IHBhcmFtcz8uY29lcmNlIHx8IGZhbHNlLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZERhdGUsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5leHBvcnQgY2xhc3MgWm9kU3ltYm9sIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICAgICAgaWYgKHBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUuc3ltYm9sKSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLnN5bWJvbCxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcbiAgICB9XG59XG5ab2RTeW1ib2wuY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kU3ltYm9sKHtcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RTeW1ib2wsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5leHBvcnQgY2xhc3MgWm9kVW5kZWZpbmVkIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICAgICAgaWYgKHBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUudW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLnVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcbiAgICB9XG59XG5ab2RVbmRlZmluZWQuY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kVW5kZWZpbmVkKHtcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RVbmRlZmluZWQsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5leHBvcnQgY2xhc3MgWm9kTnVsbCBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLm51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUubnVsbCxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcbiAgICB9XG59XG5ab2ROdWxsLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZE51bGwoe1xuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE51bGwsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5leHBvcnQgY2xhc3MgWm9kQW55IGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIC8vIHRvIHByZXZlbnQgaW5zdGFuY2VzIG9mIG90aGVyIGNsYXNzZXMgZnJvbSBleHRlbmRpbmcgWm9kQW55LiB0aGlzIGNhdXNlcyBpc3N1ZXMgd2l0aCBjYXRjaGFsbCBpbiBab2RPYmplY3QuXG4gICAgICAgIHRoaXMuX2FueSA9IHRydWU7XG4gICAgfVxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICByZXR1cm4gT0soaW5wdXQuZGF0YSk7XG4gICAgfVxufVxuWm9kQW55LmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZEFueSh7XG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kQW55LFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuZXhwb3J0IGNsYXNzIFpvZFVua25vd24gZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgLy8gcmVxdWlyZWRcbiAgICAgICAgdGhpcy5fdW5rbm93biA9IHRydWU7XG4gICAgfVxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICByZXR1cm4gT0soaW5wdXQuZGF0YSk7XG4gICAgfVxufVxuWm9kVW5rbm93bi5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RVbmtub3duKHtcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RVbmtub3duLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuZXhwb3J0IGNsYXNzIFpvZE5ldmVyIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUubmV2ZXIsXG4gICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICB9XG59XG5ab2ROZXZlci5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2ROZXZlcih7XG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTmV2ZXIsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5leHBvcnQgY2xhc3MgWm9kVm9pZCBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLnVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS52b2lkLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE9LKGlucHV0LmRhdGEpO1xuICAgIH1cbn1cblpvZFZvaWQuY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kVm9pZCh7XG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kVm9pZCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmV4cG9ydCBjbGFzcyBab2RBcnJheSBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IGN0eCwgc3RhdHVzIH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBjb25zdCBkZWYgPSB0aGlzLl9kZWY7XG4gICAgICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5hcnJheSkge1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5hcnJheSxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZWYuZXhhY3RMZW5ndGggIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IHRvb0JpZyA9IGN0eC5kYXRhLmxlbmd0aCA+IGRlZi5leGFjdExlbmd0aC52YWx1ZTtcbiAgICAgICAgICAgIGNvbnN0IHRvb1NtYWxsID0gY3R4LmRhdGEubGVuZ3RoIDwgZGVmLmV4YWN0TGVuZ3RoLnZhbHVlO1xuICAgICAgICAgICAgaWYgKHRvb0JpZyB8fCB0b29TbWFsbCkge1xuICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiB0b29CaWcgPyBab2RJc3N1ZUNvZGUudG9vX2JpZyA6IFpvZElzc3VlQ29kZS50b29fc21hbGwsXG4gICAgICAgICAgICAgICAgICAgIG1pbmltdW06ICh0b29TbWFsbCA/IGRlZi5leGFjdExlbmd0aC52YWx1ZSA6IHVuZGVmaW5lZCksXG4gICAgICAgICAgICAgICAgICAgIG1heGltdW06ICh0b29CaWcgPyBkZWYuZXhhY3RMZW5ndGgudmFsdWUgOiB1bmRlZmluZWQpLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGRlZi5leGFjdExlbmd0aC5tZXNzYWdlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChkZWYubWluTGVuZ3RoICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoY3R4LmRhdGEubGVuZ3RoIDwgZGVmLm1pbkxlbmd0aC52YWx1ZSkge1xuICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX3NtYWxsLFxuICAgICAgICAgICAgICAgICAgICBtaW5pbXVtOiBkZWYubWluTGVuZ3RoLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBkZWYubWluTGVuZ3RoLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlZi5tYXhMZW5ndGggIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChjdHguZGF0YS5sZW5ndGggPiBkZWYubWF4TGVuZ3RoLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fYmlnLFxuICAgICAgICAgICAgICAgICAgICBtYXhpbXVtOiBkZWYubWF4TGVuZ3RoLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBkZWYubWF4TGVuZ3RoLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChbLi4uY3R4LmRhdGFdLm1hcCgoaXRlbSwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWYudHlwZS5fcGFyc2VBc3luYyhuZXcgUGFyc2VJbnB1dExhenlQYXRoKGN0eCwgaXRlbSwgY3R4LnBhdGgsIGkpKTtcbiAgICAgICAgICAgIH0pKS50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUGFyc2VTdGF0dXMubWVyZ2VBcnJheShzdGF0dXMsIHJlc3VsdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBbLi4uY3R4LmRhdGFdLm1hcCgoaXRlbSwgaSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGRlZi50eXBlLl9wYXJzZVN5bmMobmV3IFBhcnNlSW5wdXRMYXp5UGF0aChjdHgsIGl0ZW0sIGN0eC5wYXRoLCBpKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gUGFyc2VTdGF0dXMubWVyZ2VBcnJheShzdGF0dXMsIHJlc3VsdCk7XG4gICAgfVxuICAgIGdldCBlbGVtZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnR5cGU7XG4gICAgfVxuICAgIG1pbihtaW5MZW5ndGgsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RBcnJheSh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBtaW5MZW5ndGg6IHsgdmFsdWU6IG1pbkxlbmd0aCwgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBtYXgobWF4TGVuZ3RoLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kQXJyYXkoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgbWF4TGVuZ3RoOiB7IHZhbHVlOiBtYXhMZW5ndGgsIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbGVuZ3RoKGxlbiwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZEFycmF5KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIGV4YWN0TGVuZ3RoOiB7IHZhbHVlOiBsZW4sIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbm9uZW1wdHkobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5taW4oMSwgbWVzc2FnZSk7XG4gICAgfVxufVxuWm9kQXJyYXkuY3JlYXRlID0gKHNjaGVtYSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RBcnJheSh7XG4gICAgICAgIHR5cGU6IHNjaGVtYSxcbiAgICAgICAgbWluTGVuZ3RoOiBudWxsLFxuICAgICAgICBtYXhMZW5ndGg6IG51bGwsXG4gICAgICAgIGV4YWN0TGVuZ3RoOiBudWxsLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEFycmF5LFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuZnVuY3Rpb24gZGVlcFBhcnRpYWxpZnkoc2NoZW1hKSB7XG4gICAgaWYgKHNjaGVtYSBpbnN0YW5jZW9mIFpvZE9iamVjdCkge1xuICAgICAgICBjb25zdCBuZXdTaGFwZSA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEuc2hhcGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkU2NoZW1hID0gc2NoZW1hLnNoYXBlW2tleV07XG4gICAgICAgICAgICBuZXdTaGFwZVtrZXldID0gWm9kT3B0aW9uYWwuY3JlYXRlKGRlZXBQYXJ0aWFsaWZ5KGZpZWxkU2NoZW1hKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICAgICAgLi4uc2NoZW1hLl9kZWYsXG4gICAgICAgICAgICBzaGFwZTogKCkgPT4gbmV3U2hhcGUsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmIChzY2hlbWEgaW5zdGFuY2VvZiBab2RBcnJheSkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZEFycmF5KHtcbiAgICAgICAgICAgIC4uLnNjaGVtYS5fZGVmLFxuICAgICAgICAgICAgdHlwZTogZGVlcFBhcnRpYWxpZnkoc2NoZW1hLmVsZW1lbnQpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc2NoZW1hIGluc3RhbmNlb2YgWm9kT3B0aW9uYWwpIHtcbiAgICAgICAgcmV0dXJuIFpvZE9wdGlvbmFsLmNyZWF0ZShkZWVwUGFydGlhbGlmeShzY2hlbWEudW53cmFwKCkpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc2NoZW1hIGluc3RhbmNlb2YgWm9kTnVsbGFibGUpIHtcbiAgICAgICAgcmV0dXJuIFpvZE51bGxhYmxlLmNyZWF0ZShkZWVwUGFydGlhbGlmeShzY2hlbWEudW53cmFwKCkpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc2NoZW1hIGluc3RhbmNlb2YgWm9kVHVwbGUpIHtcbiAgICAgICAgcmV0dXJuIFpvZFR1cGxlLmNyZWF0ZShzY2hlbWEuaXRlbXMubWFwKChpdGVtKSA9PiBkZWVwUGFydGlhbGlmeShpdGVtKSkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHNjaGVtYTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgWm9kT2JqZWN0IGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuX2NhY2hlZCA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZGVwcmVjYXRlZCBJbiBtb3N0IGNhc2VzLCB0aGlzIGlzIG5vIGxvbmdlciBuZWVkZWQgLSB1bmtub3duIHByb3BlcnRpZXMgYXJlIG5vdyBzaWxlbnRseSBzdHJpcHBlZC5cbiAgICAgICAgICogSWYgeW91IHdhbnQgdG8gcGFzcyB0aHJvdWdoIHVua25vd24gcHJvcGVydGllcywgdXNlIGAucGFzc3Rocm91Z2goKWAgaW5zdGVhZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubm9uc3RyaWN0ID0gdGhpcy5wYXNzdGhyb3VnaDtcbiAgICAgICAgLy8gZXh0ZW5kPFxuICAgICAgICAvLyAgIEF1Z21lbnRhdGlvbiBleHRlbmRzIFpvZFJhd1NoYXBlLFxuICAgICAgICAvLyAgIE5ld091dHB1dCBleHRlbmRzIHV0aWwuZmxhdHRlbjx7XG4gICAgICAgIC8vICAgICBbayBpbiBrZXlvZiBBdWdtZW50YXRpb24gfCBrZXlvZiBPdXRwdXRdOiBrIGV4dGVuZHMga2V5b2YgQXVnbWVudGF0aW9uXG4gICAgICAgIC8vICAgICAgID8gQXVnbWVudGF0aW9uW2tdW1wiX291dHB1dFwiXVxuICAgICAgICAvLyAgICAgICA6IGsgZXh0ZW5kcyBrZXlvZiBPdXRwdXRcbiAgICAgICAgLy8gICAgICAgPyBPdXRwdXRba11cbiAgICAgICAgLy8gICAgICAgOiBuZXZlcjtcbiAgICAgICAgLy8gICB9PixcbiAgICAgICAgLy8gICBOZXdJbnB1dCBleHRlbmRzIHV0aWwuZmxhdHRlbjx7XG4gICAgICAgIC8vICAgICBbayBpbiBrZXlvZiBBdWdtZW50YXRpb24gfCBrZXlvZiBJbnB1dF06IGsgZXh0ZW5kcyBrZXlvZiBBdWdtZW50YXRpb25cbiAgICAgICAgLy8gICAgICAgPyBBdWdtZW50YXRpb25ba11bXCJfaW5wdXRcIl1cbiAgICAgICAgLy8gICAgICAgOiBrIGV4dGVuZHMga2V5b2YgSW5wdXRcbiAgICAgICAgLy8gICAgICAgPyBJbnB1dFtrXVxuICAgICAgICAvLyAgICAgICA6IG5ldmVyO1xuICAgICAgICAvLyAgIH0+XG4gICAgICAgIC8vID4oXG4gICAgICAgIC8vICAgYXVnbWVudGF0aW9uOiBBdWdtZW50YXRpb25cbiAgICAgICAgLy8gKTogWm9kT2JqZWN0PFxuICAgICAgICAvLyAgIGV4dGVuZFNoYXBlPFQsIEF1Z21lbnRhdGlvbj4sXG4gICAgICAgIC8vICAgVW5rbm93bktleXMsXG4gICAgICAgIC8vICAgQ2F0Y2hhbGwsXG4gICAgICAgIC8vICAgTmV3T3V0cHV0LFxuICAgICAgICAvLyAgIE5ld0lucHV0XG4gICAgICAgIC8vID4ge1xuICAgICAgICAvLyAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgLy8gICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgLy8gICAgIHNoYXBlOiAoKSA9PiAoe1xuICAgICAgICAvLyAgICAgICAuLi50aGlzLl9kZWYuc2hhcGUoKSxcbiAgICAgICAgLy8gICAgICAgLi4uYXVnbWVudGF0aW9uLFxuICAgICAgICAvLyAgICAgfSksXG4gICAgICAgIC8vICAgfSkgYXMgYW55O1xuICAgICAgICAvLyB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZGVwcmVjYXRlZCBVc2UgYC5leHRlbmRgIGluc3RlYWRcbiAgICAgICAgICogICovXG4gICAgICAgIHRoaXMuYXVnbWVudCA9IHRoaXMuZXh0ZW5kO1xuICAgIH1cbiAgICBfZ2V0Q2FjaGVkKCkge1xuICAgICAgICBpZiAodGhpcy5fY2FjaGVkICE9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlZDtcbiAgICAgICAgY29uc3Qgc2hhcGUgPSB0aGlzLl9kZWYuc2hhcGUoKTtcbiAgICAgICAgY29uc3Qga2V5cyA9IHV0aWwub2JqZWN0S2V5cyhzaGFwZSk7XG4gICAgICAgIHRoaXMuX2NhY2hlZCA9IHsgc2hhcGUsIGtleXMgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlZDtcbiAgICB9XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICAgICAgaWYgKHBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUub2JqZWN0KSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLm9iamVjdCxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgc3RhdHVzLCBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGNvbnN0IHsgc2hhcGUsIGtleXM6IHNoYXBlS2V5cyB9ID0gdGhpcy5fZ2V0Q2FjaGVkKCk7XG4gICAgICAgIGNvbnN0IGV4dHJhS2V5cyA9IFtdO1xuICAgICAgICBpZiAoISh0aGlzLl9kZWYuY2F0Y2hhbGwgaW5zdGFuY2VvZiBab2ROZXZlciAmJiB0aGlzLl9kZWYudW5rbm93bktleXMgPT09IFwic3RyaXBcIikpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIGN0eC5kYXRhKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzaGFwZUtleXMuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBleHRyYUtleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYWlycyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBzaGFwZUtleXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleVZhbGlkYXRvciA9IHNoYXBlW2tleV07XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGN0eC5kYXRhW2tleV07XG4gICAgICAgICAgICBwYWlycy5wdXNoKHtcbiAgICAgICAgICAgICAgICBrZXk6IHsgc3RhdHVzOiBcInZhbGlkXCIsIHZhbHVlOiBrZXkgfSxcbiAgICAgICAgICAgICAgICB2YWx1ZToga2V5VmFsaWRhdG9yLl9wYXJzZShuZXcgUGFyc2VJbnB1dExhenlQYXRoKGN0eCwgdmFsdWUsIGN0eC5wYXRoLCBrZXkpKSxcbiAgICAgICAgICAgICAgICBhbHdheXNTZXQ6IGtleSBpbiBjdHguZGF0YSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9kZWYuY2F0Y2hhbGwgaW5zdGFuY2VvZiBab2ROZXZlcikge1xuICAgICAgICAgICAgY29uc3QgdW5rbm93bktleXMgPSB0aGlzLl9kZWYudW5rbm93bktleXM7XG4gICAgICAgICAgICBpZiAodW5rbm93bktleXMgPT09IFwicGFzc3Rocm91Z2hcIikge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGV4dHJhS2V5cykge1xuICAgICAgICAgICAgICAgICAgICBwYWlycy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogeyBzdGF0dXM6IFwidmFsaWRcIiwgdmFsdWU6IGtleSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHsgc3RhdHVzOiBcInZhbGlkXCIsIHZhbHVlOiBjdHguZGF0YVtrZXldIH0sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHVua25vd25LZXlzID09PSBcInN0cmljdFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGV4dHJhS2V5cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnVucmVjb2duaXplZF9rZXlzLFxuICAgICAgICAgICAgICAgICAgICAgICAga2V5czogZXh0cmFLZXlzLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodW5rbm93bktleXMgPT09IFwic3RyaXBcIikge1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnRlcm5hbCBab2RPYmplY3QgZXJyb3I6IGludmFsaWQgdW5rbm93bktleXMgdmFsdWUuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBydW4gY2F0Y2hhbGwgdmFsaWRhdGlvblxuICAgICAgICAgICAgY29uc3QgY2F0Y2hhbGwgPSB0aGlzLl9kZWYuY2F0Y2hhbGw7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBleHRyYUtleXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGN0eC5kYXRhW2tleV07XG4gICAgICAgICAgICAgICAgcGFpcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGtleTogeyBzdGF0dXM6IFwidmFsaWRcIiwgdmFsdWU6IGtleSB9LFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogY2F0Y2hhbGwuX3BhcnNlKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCB2YWx1ZSwgY3R4LnBhdGgsIGtleSkgLy8sIGN0eC5jaGlsZChrZXkpLCB2YWx1ZSwgZ2V0UGFyc2VkVHlwZSh2YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgYWx3YXlzU2V0OiBrZXkgaW4gY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICAgICAgICAgICAgICAgIC50aGVuKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzeW5jUGFpcnMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHBhaXIgb2YgcGFpcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gYXdhaXQgcGFpci5rZXk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgcGFpci52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgc3luY1BhaXJzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBhbHdheXNTZXQ6IHBhaXIuYWx3YXlzU2V0LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN5bmNQYWlycztcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKHN5bmNQYWlycykgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBQYXJzZVN0YXR1cy5tZXJnZU9iamVjdFN5bmMoc3RhdHVzLCBzeW5jUGFpcnMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gUGFyc2VTdGF0dXMubWVyZ2VPYmplY3RTeW5jKHN0YXR1cywgcGFpcnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBzaGFwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5zaGFwZSgpO1xuICAgIH1cbiAgICBzdHJpY3QobWVzc2FnZSkge1xuICAgICAgICBlcnJvclV0aWwuZXJyVG9PYmo7XG4gICAgICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIHVua25vd25LZXlzOiBcInN0cmljdFwiLFxuICAgICAgICAgICAgLi4uKG1lc3NhZ2UgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICBlcnJvck1hcDogKGlzc3VlLCBjdHgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRFcnJvciA9IHRoaXMuX2RlZi5lcnJvck1hcD8uKGlzc3VlLCBjdHgpLm1lc3NhZ2UgPz8gY3R4LmRlZmF1bHRFcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc3N1ZS5jb2RlID09PSBcInVucmVjb2duaXplZF9rZXlzXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpLm1lc3NhZ2UgPz8gZGVmYXVsdEVycm9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGRlZmF1bHRFcnJvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDoge30pLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RyaXAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIHVua25vd25LZXlzOiBcInN0cmlwXCIsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwYXNzdGhyb3VnaCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgdW5rbm93bktleXM6IFwicGFzc3Rocm91Z2hcIixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIGNvbnN0IEF1Z21lbnRGYWN0b3J5ID1cbiAgICAvLyAgIDxEZWYgZXh0ZW5kcyBab2RPYmplY3REZWY+KGRlZjogRGVmKSA9PlxuICAgIC8vICAgPEF1Z21lbnRhdGlvbiBleHRlbmRzIFpvZFJhd1NoYXBlPihcbiAgICAvLyAgICAgYXVnbWVudGF0aW9uOiBBdWdtZW50YXRpb25cbiAgICAvLyAgICk6IFpvZE9iamVjdDxcbiAgICAvLyAgICAgZXh0ZW5kU2hhcGU8UmV0dXJuVHlwZTxEZWZbXCJzaGFwZVwiXT4sIEF1Z21lbnRhdGlvbj4sXG4gICAgLy8gICAgIERlZltcInVua25vd25LZXlzXCJdLFxuICAgIC8vICAgICBEZWZbXCJjYXRjaGFsbFwiXVxuICAgIC8vICAgPiA9PiB7XG4gICAgLy8gICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAvLyAgICAgICAuLi5kZWYsXG4gICAgLy8gICAgICAgc2hhcGU6ICgpID0+ICh7XG4gICAgLy8gICAgICAgICAuLi5kZWYuc2hhcGUoKSxcbiAgICAvLyAgICAgICAgIC4uLmF1Z21lbnRhdGlvbixcbiAgICAvLyAgICAgICB9KSxcbiAgICAvLyAgICAgfSkgYXMgYW55O1xuICAgIC8vICAgfTtcbiAgICBleHRlbmQoYXVnbWVudGF0aW9uKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIHNoYXBlOiAoKSA9PiAoe1xuICAgICAgICAgICAgICAgIC4uLnRoaXMuX2RlZi5zaGFwZSgpLFxuICAgICAgICAgICAgICAgIC4uLmF1Z21lbnRhdGlvbixcbiAgICAgICAgICAgIH0pLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJpb3IgdG8gem9kQDEuMC4xMiB0aGVyZSB3YXMgYSBidWcgaW4gdGhlXG4gICAgICogaW5mZXJyZWQgdHlwZSBvZiBtZXJnZWQgb2JqZWN0cy4gUGxlYXNlXG4gICAgICogdXBncmFkZSBpZiB5b3UgYXJlIGV4cGVyaWVuY2luZyBpc3N1ZXMuXG4gICAgICovXG4gICAgbWVyZ2UobWVyZ2luZykge1xuICAgICAgICBjb25zdCBtZXJnZWQgPSBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgICAgIHVua25vd25LZXlzOiBtZXJnaW5nLl9kZWYudW5rbm93bktleXMsXG4gICAgICAgICAgICBjYXRjaGFsbDogbWVyZ2luZy5fZGVmLmNhdGNoYWxsLFxuICAgICAgICAgICAgc2hhcGU6ICgpID0+ICh7XG4gICAgICAgICAgICAgICAgLi4udGhpcy5fZGVmLnNoYXBlKCksXG4gICAgICAgICAgICAgICAgLi4ubWVyZ2luZy5fZGVmLnNoYXBlKCksXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kT2JqZWN0LFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG1lcmdlZDtcbiAgICB9XG4gICAgLy8gbWVyZ2U8XG4gICAgLy8gICBJbmNvbWluZyBleHRlbmRzIEFueVpvZE9iamVjdCxcbiAgICAvLyAgIEF1Z21lbnRhdGlvbiBleHRlbmRzIEluY29taW5nW1wic2hhcGVcIl0sXG4gICAgLy8gICBOZXdPdXRwdXQgZXh0ZW5kcyB7XG4gICAgLy8gICAgIFtrIGluIGtleW9mIEF1Z21lbnRhdGlvbiB8IGtleW9mIE91dHB1dF06IGsgZXh0ZW5kcyBrZXlvZiBBdWdtZW50YXRpb25cbiAgICAvLyAgICAgICA/IEF1Z21lbnRhdGlvbltrXVtcIl9vdXRwdXRcIl1cbiAgICAvLyAgICAgICA6IGsgZXh0ZW5kcyBrZXlvZiBPdXRwdXRcbiAgICAvLyAgICAgICA/IE91dHB1dFtrXVxuICAgIC8vICAgICAgIDogbmV2ZXI7XG4gICAgLy8gICB9LFxuICAgIC8vICAgTmV3SW5wdXQgZXh0ZW5kcyB7XG4gICAgLy8gICAgIFtrIGluIGtleW9mIEF1Z21lbnRhdGlvbiB8IGtleW9mIElucHV0XTogayBleHRlbmRzIGtleW9mIEF1Z21lbnRhdGlvblxuICAgIC8vICAgICAgID8gQXVnbWVudGF0aW9uW2tdW1wiX2lucHV0XCJdXG4gICAgLy8gICAgICAgOiBrIGV4dGVuZHMga2V5b2YgSW5wdXRcbiAgICAvLyAgICAgICA/IElucHV0W2tdXG4gICAgLy8gICAgICAgOiBuZXZlcjtcbiAgICAvLyAgIH1cbiAgICAvLyA+KFxuICAgIC8vICAgbWVyZ2luZzogSW5jb21pbmdcbiAgICAvLyApOiBab2RPYmplY3Q8XG4gICAgLy8gICBleHRlbmRTaGFwZTxULCBSZXR1cm5UeXBlPEluY29taW5nW1wiX2RlZlwiXVtcInNoYXBlXCJdPj4sXG4gICAgLy8gICBJbmNvbWluZ1tcIl9kZWZcIl1bXCJ1bmtub3duS2V5c1wiXSxcbiAgICAvLyAgIEluY29taW5nW1wiX2RlZlwiXVtcImNhdGNoYWxsXCJdLFxuICAgIC8vICAgTmV3T3V0cHV0LFxuICAgIC8vICAgTmV3SW5wdXRcbiAgICAvLyA+IHtcbiAgICAvLyAgIGNvbnN0IG1lcmdlZDogYW55ID0gbmV3IFpvZE9iamVjdCh7XG4gICAgLy8gICAgIHVua25vd25LZXlzOiBtZXJnaW5nLl9kZWYudW5rbm93bktleXMsXG4gICAgLy8gICAgIGNhdGNoYWxsOiBtZXJnaW5nLl9kZWYuY2F0Y2hhbGwsXG4gICAgLy8gICAgIHNoYXBlOiAoKSA9PlxuICAgIC8vICAgICAgIG9iamVjdFV0aWwubWVyZ2VTaGFwZXModGhpcy5fZGVmLnNoYXBlKCksIG1lcmdpbmcuX2RlZi5zaGFwZSgpKSxcbiAgICAvLyAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RPYmplY3QsXG4gICAgLy8gICB9KSBhcyBhbnk7XG4gICAgLy8gICByZXR1cm4gbWVyZ2VkO1xuICAgIC8vIH1cbiAgICBzZXRLZXkoa2V5LCBzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXVnbWVudCh7IFtrZXldOiBzY2hlbWEgfSk7XG4gICAgfVxuICAgIC8vIG1lcmdlPEluY29taW5nIGV4dGVuZHMgQW55Wm9kT2JqZWN0PihcbiAgICAvLyAgIG1lcmdpbmc6IEluY29taW5nXG4gICAgLy8gKTogLy9ab2RPYmplY3Q8VCAmIEluY29taW5nW1wiX3NoYXBlXCJdLCBVbmtub3duS2V5cywgQ2F0Y2hhbGw+ID0gKG1lcmdpbmcpID0+IHtcbiAgICAvLyBab2RPYmplY3Q8XG4gICAgLy8gICBleHRlbmRTaGFwZTxULCBSZXR1cm5UeXBlPEluY29taW5nW1wiX2RlZlwiXVtcInNoYXBlXCJdPj4sXG4gICAgLy8gICBJbmNvbWluZ1tcIl9kZWZcIl1bXCJ1bmtub3duS2V5c1wiXSxcbiAgICAvLyAgIEluY29taW5nW1wiX2RlZlwiXVtcImNhdGNoYWxsXCJdXG4gICAgLy8gPiB7XG4gICAgLy8gICAvLyBjb25zdCBtZXJnZWRTaGFwZSA9IG9iamVjdFV0aWwubWVyZ2VTaGFwZXMoXG4gICAgLy8gICAvLyAgIHRoaXMuX2RlZi5zaGFwZSgpLFxuICAgIC8vICAgLy8gICBtZXJnaW5nLl9kZWYuc2hhcGUoKVxuICAgIC8vICAgLy8gKTtcbiAgICAvLyAgIGNvbnN0IG1lcmdlZDogYW55ID0gbmV3IFpvZE9iamVjdCh7XG4gICAgLy8gICAgIHVua25vd25LZXlzOiBtZXJnaW5nLl9kZWYudW5rbm93bktleXMsXG4gICAgLy8gICAgIGNhdGNoYWxsOiBtZXJnaW5nLl9kZWYuY2F0Y2hhbGwsXG4gICAgLy8gICAgIHNoYXBlOiAoKSA9PlxuICAgIC8vICAgICAgIG9iamVjdFV0aWwubWVyZ2VTaGFwZXModGhpcy5fZGVmLnNoYXBlKCksIG1lcmdpbmcuX2RlZi5zaGFwZSgpKSxcbiAgICAvLyAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RPYmplY3QsXG4gICAgLy8gICB9KSBhcyBhbnk7XG4gICAgLy8gICByZXR1cm4gbWVyZ2VkO1xuICAgIC8vIH1cbiAgICBjYXRjaGFsbChpbmRleCkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBjYXRjaGFsbDogaW5kZXgsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwaWNrKG1hc2spIHtcbiAgICAgICAgY29uc3Qgc2hhcGUgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgdXRpbC5vYmplY3RLZXlzKG1hc2spKSB7XG4gICAgICAgICAgICBpZiAobWFza1trZXldICYmIHRoaXMuc2hhcGVba2V5XSkge1xuICAgICAgICAgICAgICAgIHNoYXBlW2tleV0gPSB0aGlzLnNoYXBlW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgc2hhcGU6ICgpID0+IHNoYXBlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgb21pdChtYXNrKSB7XG4gICAgICAgIGNvbnN0IHNoYXBlID0ge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHV0aWwub2JqZWN0S2V5cyh0aGlzLnNoYXBlKSkge1xuICAgICAgICAgICAgaWYgKCFtYXNrW2tleV0pIHtcbiAgICAgICAgICAgICAgICBzaGFwZVtrZXldID0gdGhpcy5zaGFwZVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIHNoYXBlOiAoKSA9PiBzaGFwZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICovXG4gICAgZGVlcFBhcnRpYWwoKSB7XG4gICAgICAgIHJldHVybiBkZWVwUGFydGlhbGlmeSh0aGlzKTtcbiAgICB9XG4gICAgcGFydGlhbChtYXNrKSB7XG4gICAgICAgIGNvbnN0IG5ld1NoYXBlID0ge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHV0aWwub2JqZWN0S2V5cyh0aGlzLnNoYXBlKSkge1xuICAgICAgICAgICAgY29uc3QgZmllbGRTY2hlbWEgPSB0aGlzLnNoYXBlW2tleV07XG4gICAgICAgICAgICBpZiAobWFzayAmJiAhbWFza1trZXldKSB7XG4gICAgICAgICAgICAgICAgbmV3U2hhcGVba2V5XSA9IGZpZWxkU2NoZW1hO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3U2hhcGVba2V5XSA9IGZpZWxkU2NoZW1hLm9wdGlvbmFsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgc2hhcGU6ICgpID0+IG5ld1NoYXBlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVxdWlyZWQobWFzaykge1xuICAgICAgICBjb25zdCBuZXdTaGFwZSA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiB1dGlsLm9iamVjdEtleXModGhpcy5zaGFwZSkpIHtcbiAgICAgICAgICAgIGlmIChtYXNrICYmICFtYXNrW2tleV0pIHtcbiAgICAgICAgICAgICAgICBuZXdTaGFwZVtrZXldID0gdGhpcy5zaGFwZVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmllbGRTY2hlbWEgPSB0aGlzLnNoYXBlW2tleV07XG4gICAgICAgICAgICAgICAgbGV0IG5ld0ZpZWxkID0gZmllbGRTY2hlbWE7XG4gICAgICAgICAgICAgICAgd2hpbGUgKG5ld0ZpZWxkIGluc3RhbmNlb2YgWm9kT3B0aW9uYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3RmllbGQgPSBuZXdGaWVsZC5fZGVmLmlubmVyVHlwZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmV3U2hhcGVba2V5XSA9IG5ld0ZpZWxkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIHNoYXBlOiAoKSA9PiBuZXdTaGFwZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGtleW9mKCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlWm9kRW51bSh1dGlsLm9iamVjdEtleXModGhpcy5zaGFwZSkpO1xuICAgIH1cbn1cblpvZE9iamVjdC5jcmVhdGUgPSAoc2hhcGUsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgc2hhcGU6ICgpID0+IHNoYXBlLFxuICAgICAgICB1bmtub3duS2V5czogXCJzdHJpcFwiLFxuICAgICAgICBjYXRjaGFsbDogWm9kTmV2ZXIuY3JlYXRlKCksXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kT2JqZWN0LFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuWm9kT2JqZWN0LnN0cmljdENyZWF0ZSA9IChzaGFwZSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICBzaGFwZTogKCkgPT4gc2hhcGUsXG4gICAgICAgIHVua25vd25LZXlzOiBcInN0cmljdFwiLFxuICAgICAgICBjYXRjaGFsbDogWm9kTmV2ZXIuY3JlYXRlKCksXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kT2JqZWN0LFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuWm9kT2JqZWN0LmxhenljcmVhdGUgPSAoc2hhcGUsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgc2hhcGUsXG4gICAgICAgIHVua25vd25LZXlzOiBcInN0cmlwXCIsXG4gICAgICAgIGNhdGNoYWxsOiBab2ROZXZlci5jcmVhdGUoKSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RPYmplY3QsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5leHBvcnQgY2xhc3MgWm9kVW5pb24gZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLl9kZWYub3B0aW9ucztcbiAgICAgICAgZnVuY3Rpb24gaGFuZGxlUmVzdWx0cyhyZXN1bHRzKSB7XG4gICAgICAgICAgICAvLyByZXR1cm4gZmlyc3QgaXNzdWUtZnJlZSB2YWxpZGF0aW9uIGlmIGl0IGV4aXN0c1xuICAgICAgICAgICAgZm9yIChjb25zdCByZXN1bHQgb2YgcmVzdWx0cykge1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQucmVzdWx0LnN0YXR1cyA9PT0gXCJ2YWxpZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQucmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgcmVzdWx0IG9mIHJlc3VsdHMpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnJlc3VsdC5zdGF0dXMgPT09IFwiZGlydHlcIikge1xuICAgICAgICAgICAgICAgICAgICAvLyBhZGQgaXNzdWVzIGZyb20gZGlydHkgb3B0aW9uXG4gICAgICAgICAgICAgICAgICAgIGN0eC5jb21tb24uaXNzdWVzLnB1c2goLi4ucmVzdWx0LmN0eC5jb21tb24uaXNzdWVzKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcmV0dXJuIGludmFsaWRcbiAgICAgICAgICAgIGNvbnN0IHVuaW9uRXJyb3JzID0gcmVzdWx0cy5tYXAoKHJlc3VsdCkgPT4gbmV3IFpvZEVycm9yKHJlc3VsdC5jdHguY29tbW9uLmlzc3VlcykpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdW5pb24sXG4gICAgICAgICAgICAgICAgdW5pb25FcnJvcnMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwob3B0aW9ucy5tYXAoYXN5bmMgKG9wdGlvbikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkQ3R4ID0ge1xuICAgICAgICAgICAgICAgICAgICAuLi5jdHgsXG4gICAgICAgICAgICAgICAgICAgIGNvbW1vbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4uY3R4LmNvbW1vbixcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzc3VlczogW10sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogbnVsbCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDogYXdhaXQgb3B0aW9uLl9wYXJzZUFzeW5jKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGNoaWxkQ3R4LFxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgY3R4OiBjaGlsZEN0eCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSkpLnRoZW4oaGFuZGxlUmVzdWx0cyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgZGlydHkgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjb25zdCBpc3N1ZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgb3B0aW9uIG9mIG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZEN0eCA9IHtcbiAgICAgICAgICAgICAgICAgICAgLi4uY3R4LFxuICAgICAgICAgICAgICAgICAgICBjb21tb246IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmN0eC5jb21tb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBpc3N1ZXM6IFtdLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IG51bGwsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBvcHRpb24uX3BhcnNlU3luYyh7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBjaGlsZEN0eCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnN0YXR1cyA9PT0gXCJ2YWxpZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlc3VsdC5zdGF0dXMgPT09IFwiZGlydHlcIiAmJiAhZGlydHkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlydHkgPSB7IHJlc3VsdCwgY3R4OiBjaGlsZEN0eCB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY2hpbGRDdHguY29tbW9uLmlzc3Vlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNzdWVzLnB1c2goY2hpbGRDdHguY29tbW9uLmlzc3Vlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRpcnR5KSB7XG4gICAgICAgICAgICAgICAgY3R4LmNvbW1vbi5pc3N1ZXMucHVzaCguLi5kaXJ0eS5jdHguY29tbW9uLmlzc3Vlcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRpcnR5LnJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHVuaW9uRXJyb3JzID0gaXNzdWVzLm1hcCgoaXNzdWVzKSA9PiBuZXcgWm9kRXJyb3IoaXNzdWVzKSk7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF91bmlvbixcbiAgICAgICAgICAgICAgICB1bmlvbkVycm9ycyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IG9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYub3B0aW9ucztcbiAgICB9XG59XG5ab2RVbmlvbi5jcmVhdGUgPSAodHlwZXMsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kVW5pb24oe1xuICAgICAgICBvcHRpb25zOiB0eXBlcyxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RVbmlvbixcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vLy8vLy8vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vLy8vLy8vLy9cbi8vLy8vLy8vLy8gICAgICBab2REaXNjcmltaW5hdGVkVW5pb24gICAgICAvLy8vLy8vLy8vXG4vLy8vLy8vLy8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8vLy8vLy8vL1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5jb25zdCBnZXREaXNjcmltaW5hdG9yID0gKHR5cGUpID0+IHtcbiAgICBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZExhenkpIHtcbiAgICAgICAgcmV0dXJuIGdldERpc2NyaW1pbmF0b3IodHlwZS5zY2hlbWEpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kRWZmZWN0cykge1xuICAgICAgICByZXR1cm4gZ2V0RGlzY3JpbWluYXRvcih0eXBlLmlubmVyVHlwZSgpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZExpdGVyYWwpIHtcbiAgICAgICAgcmV0dXJuIFt0eXBlLnZhbHVlXTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZEVudW0pIHtcbiAgICAgICAgcmV0dXJuIHR5cGUub3B0aW9ucztcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZE5hdGl2ZUVudW0pIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGJhbi9iYW5cbiAgICAgICAgcmV0dXJuIHV0aWwub2JqZWN0VmFsdWVzKHR5cGUuZW51bSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2REZWZhdWx0KSB7XG4gICAgICAgIHJldHVybiBnZXREaXNjcmltaW5hdG9yKHR5cGUuX2RlZi5pbm5lclR5cGUpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kVW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBbdW5kZWZpbmVkXTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZE51bGwpIHtcbiAgICAgICAgcmV0dXJuIFtudWxsXTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZE9wdGlvbmFsKSB7XG4gICAgICAgIHJldHVybiBbdW5kZWZpbmVkLCAuLi5nZXREaXNjcmltaW5hdG9yKHR5cGUudW53cmFwKCkpXTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZE51bGxhYmxlKSB7XG4gICAgICAgIHJldHVybiBbbnVsbCwgLi4uZ2V0RGlzY3JpbWluYXRvcih0eXBlLnVud3JhcCgpKV07XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2RCcmFuZGVkKSB7XG4gICAgICAgIHJldHVybiBnZXREaXNjcmltaW5hdG9yKHR5cGUudW53cmFwKCkpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kUmVhZG9ubHkpIHtcbiAgICAgICAgcmV0dXJuIGdldERpc2NyaW1pbmF0b3IodHlwZS51bndyYXAoKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2RDYXRjaCkge1xuICAgICAgICByZXR1cm4gZ2V0RGlzY3JpbWluYXRvcih0eXBlLl9kZWYuaW5uZXJUeXBlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG59O1xuZXhwb3J0IGNsYXNzIFpvZERpc2NyaW1pbmF0ZWRVbmlvbiBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLm9iamVjdCkge1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5vYmplY3QsXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkaXNjcmltaW5hdG9yID0gdGhpcy5kaXNjcmltaW5hdG9yO1xuICAgICAgICBjb25zdCBkaXNjcmltaW5hdG9yVmFsdWUgPSBjdHguZGF0YVtkaXNjcmltaW5hdG9yXTtcbiAgICAgICAgY29uc3Qgb3B0aW9uID0gdGhpcy5vcHRpb25zTWFwLmdldChkaXNjcmltaW5hdG9yVmFsdWUpO1xuICAgICAgICBpZiAoIW9wdGlvbikge1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdW5pb25fZGlzY3JpbWluYXRvcixcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBBcnJheS5mcm9tKHRoaXMub3B0aW9uc01hcC5rZXlzKCkpLFxuICAgICAgICAgICAgICAgIHBhdGg6IFtkaXNjcmltaW5hdG9yXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgICAgICAgIHJldHVybiBvcHRpb24uX3BhcnNlQXN5bmMoe1xuICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gb3B0aW9uLl9wYXJzZVN5bmMoe1xuICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGRpc2NyaW1pbmF0b3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuZGlzY3JpbWluYXRvcjtcbiAgICB9XG4gICAgZ2V0IG9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYub3B0aW9ucztcbiAgICB9XG4gICAgZ2V0IG9wdGlvbnNNYXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYub3B0aW9uc01hcDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGNvbnN0cnVjdG9yIG9mIHRoZSBkaXNjcmltaW5hdGVkIHVuaW9uIHNjaGVtYS4gSXRzIGJlaGF2aW91ciBpcyB2ZXJ5IHNpbWlsYXIgdG8gdGhhdCBvZiB0aGUgbm9ybWFsIHoudW5pb24oKSBjb25zdHJ1Y3Rvci5cbiAgICAgKiBIb3dldmVyLCBpdCBvbmx5IGFsbG93cyBhIHVuaW9uIG9mIG9iamVjdHMsIGFsbCBvZiB3aGljaCBuZWVkIHRvIHNoYXJlIGEgZGlzY3JpbWluYXRvciBwcm9wZXJ0eS4gVGhpcyBwcm9wZXJ0eSBtdXN0XG4gICAgICogaGF2ZSBhIGRpZmZlcmVudCB2YWx1ZSBmb3IgZWFjaCBvYmplY3QgaW4gdGhlIHVuaW9uLlxuICAgICAqIEBwYXJhbSBkaXNjcmltaW5hdG9yIHRoZSBuYW1lIG9mIHRoZSBkaXNjcmltaW5hdG9yIHByb3BlcnR5XG4gICAgICogQHBhcmFtIHR5cGVzIGFuIGFycmF5IG9mIG9iamVjdCBzY2hlbWFzXG4gICAgICogQHBhcmFtIHBhcmFtc1xuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUoZGlzY3JpbWluYXRvciwgb3B0aW9ucywgcGFyYW1zKSB7XG4gICAgICAgIC8vIEdldCBhbGwgdGhlIHZhbGlkIGRpc2NyaW1pbmF0b3IgdmFsdWVzXG4gICAgICAgIGNvbnN0IG9wdGlvbnNNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8vIHRyeSB7XG4gICAgICAgIGZvciAoY29uc3QgdHlwZSBvZiBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBkaXNjcmltaW5hdG9yVmFsdWVzID0gZ2V0RGlzY3JpbWluYXRvcih0eXBlLnNoYXBlW2Rpc2NyaW1pbmF0b3JdKTtcbiAgICAgICAgICAgIGlmICghZGlzY3JpbWluYXRvclZhbHVlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEEgZGlzY3JpbWluYXRvciB2YWx1ZSBmb3Iga2V5IFxcYCR7ZGlzY3JpbWluYXRvcn1cXGAgY291bGQgbm90IGJlIGV4dHJhY3RlZCBmcm9tIGFsbCBzY2hlbWEgb3B0aW9uc2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiBkaXNjcmltaW5hdG9yVmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnNNYXAuaGFzKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYERpc2NyaW1pbmF0b3IgcHJvcGVydHkgJHtTdHJpbmcoZGlzY3JpbWluYXRvcil9IGhhcyBkdXBsaWNhdGUgdmFsdWUgJHtTdHJpbmcodmFsdWUpfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvcHRpb25zTWFwLnNldCh2YWx1ZSwgdHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBab2REaXNjcmltaW5hdGVkVW5pb24oe1xuICAgICAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2REaXNjcmltaW5hdGVkVW5pb24sXG4gICAgICAgICAgICBkaXNjcmltaW5hdG9yLFxuICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgIG9wdGlvbnNNYXAsXG4gICAgICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG1lcmdlVmFsdWVzKGEsIGIpIHtcbiAgICBjb25zdCBhVHlwZSA9IGdldFBhcnNlZFR5cGUoYSk7XG4gICAgY29uc3QgYlR5cGUgPSBnZXRQYXJzZWRUeXBlKGIpO1xuICAgIGlmIChhID09PSBiKSB7XG4gICAgICAgIHJldHVybiB7IHZhbGlkOiB0cnVlLCBkYXRhOiBhIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKGFUeXBlID09PSBab2RQYXJzZWRUeXBlLm9iamVjdCAmJiBiVHlwZSA9PT0gWm9kUGFyc2VkVHlwZS5vYmplY3QpIHtcbiAgICAgICAgY29uc3QgYktleXMgPSB1dGlsLm9iamVjdEtleXMoYik7XG4gICAgICAgIGNvbnN0IHNoYXJlZEtleXMgPSB1dGlsLm9iamVjdEtleXMoYSkuZmlsdGVyKChrZXkpID0+IGJLZXlzLmluZGV4T2Yoa2V5KSAhPT0gLTEpO1xuICAgICAgICBjb25zdCBuZXdPYmogPSB7IC4uLmEsIC4uLmIgfTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2Ygc2hhcmVkS2V5cykge1xuICAgICAgICAgICAgY29uc3Qgc2hhcmVkVmFsdWUgPSBtZXJnZVZhbHVlcyhhW2tleV0sIGJba2V5XSk7XG4gICAgICAgICAgICBpZiAoIXNoYXJlZFZhbHVlLnZhbGlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IGZhbHNlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdPYmpba2V5XSA9IHNoYXJlZFZhbHVlLmRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IHRydWUsIGRhdGE6IG5ld09iaiB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChhVHlwZSA9PT0gWm9kUGFyc2VkVHlwZS5hcnJheSAmJiBiVHlwZSA9PT0gWm9kUGFyc2VkVHlwZS5hcnJheSkge1xuICAgICAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4geyB2YWxpZDogZmFsc2UgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXdBcnJheSA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgYS5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW1BID0gYVtpbmRleF07XG4gICAgICAgICAgICBjb25zdCBpdGVtQiA9IGJbaW5kZXhdO1xuICAgICAgICAgICAgY29uc3Qgc2hhcmVkVmFsdWUgPSBtZXJnZVZhbHVlcyhpdGVtQSwgaXRlbUIpO1xuICAgICAgICAgICAgaWYgKCFzaGFyZWRWYWx1ZS52YWxpZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbGlkOiBmYWxzZSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3QXJyYXkucHVzaChzaGFyZWRWYWx1ZS5kYXRhKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyB2YWxpZDogdHJ1ZSwgZGF0YTogbmV3QXJyYXkgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYVR5cGUgPT09IFpvZFBhcnNlZFR5cGUuZGF0ZSAmJiBiVHlwZSA9PT0gWm9kUGFyc2VkVHlwZS5kYXRlICYmICthID09PSArYikge1xuICAgICAgICByZXR1cm4geyB2YWxpZDogdHJ1ZSwgZGF0YTogYSB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IGZhbHNlIH07XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFpvZEludGVyc2VjdGlvbiBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IHN0YXR1cywgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBjb25zdCBoYW5kbGVQYXJzZWQgPSAocGFyc2VkTGVmdCwgcGFyc2VkUmlnaHQpID0+IHtcbiAgICAgICAgICAgIGlmIChpc0Fib3J0ZWQocGFyc2VkTGVmdCkgfHwgaXNBYm9ydGVkKHBhcnNlZFJpZ2h0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbWVyZ2VkID0gbWVyZ2VWYWx1ZXMocGFyc2VkTGVmdC52YWx1ZSwgcGFyc2VkUmlnaHQudmFsdWUpO1xuICAgICAgICAgICAgaWYgKCFtZXJnZWQudmFsaWQpIHtcbiAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfaW50ZXJzZWN0aW9uX3R5cGVzLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzRGlydHkocGFyc2VkTGVmdCkgfHwgaXNEaXJ0eShwYXJzZWRSaWdodCkpIHtcbiAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogbWVyZ2VkLmRhdGEgfTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgdGhpcy5fZGVmLmxlZnQuX3BhcnNlQXN5bmMoe1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIHRoaXMuX2RlZi5yaWdodC5fcGFyc2VBc3luYyh7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBjdHgsXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBdKS50aGVuKChbbGVmdCwgcmlnaHRdKSA9PiBoYW5kbGVQYXJzZWQobGVmdCwgcmlnaHQpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVQYXJzZWQodGhpcy5fZGVmLmxlZnQuX3BhcnNlU3luYyh7XG4gICAgICAgICAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgcGFyZW50OiBjdHgsXG4gICAgICAgICAgICB9KSwgdGhpcy5fZGVmLnJpZ2h0Ll9wYXJzZVN5bmMoe1xuICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgfVxufVxuWm9kSW50ZXJzZWN0aW9uLmNyZWF0ZSA9IChsZWZ0LCByaWdodCwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RJbnRlcnNlY3Rpb24oe1xuICAgICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgICByaWdodDogcmlnaHQsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kSW50ZXJzZWN0aW9uLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuLy8gdHlwZSBab2RUdXBsZUl0ZW1zID0gW1pvZFR5cGVBbnksIC4uLlpvZFR5cGVBbnlbXV07XG5leHBvcnQgY2xhc3MgWm9kVHVwbGUgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBzdGF0dXMsIGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLmFycmF5KSB7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLmFycmF5LFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN0eC5kYXRhLmxlbmd0aCA8IHRoaXMuX2RlZi5pdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fc21hbGwsXG4gICAgICAgICAgICAgICAgbWluaW11bTogdGhpcy5fZGVmLml0ZW1zLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdCA9IHRoaXMuX2RlZi5yZXN0O1xuICAgICAgICBpZiAoIXJlc3QgJiYgY3R4LmRhdGEubGVuZ3RoID4gdGhpcy5fZGVmLml0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19iaWcsXG4gICAgICAgICAgICAgICAgbWF4aW11bTogdGhpcy5fZGVmLml0ZW1zLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXRlbXMgPSBbLi4uY3R4LmRhdGFdXG4gICAgICAgICAgICAubWFwKChpdGVtLCBpdGVtSW5kZXgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNjaGVtYSA9IHRoaXMuX2RlZi5pdGVtc1tpdGVtSW5kZXhdIHx8IHRoaXMuX2RlZi5yZXN0O1xuICAgICAgICAgICAgaWYgKCFzY2hlbWEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICByZXR1cm4gc2NoZW1hLl9wYXJzZShuZXcgUGFyc2VJbnB1dExhenlQYXRoKGN0eCwgaXRlbSwgY3R4LnBhdGgsIGl0ZW1JbmRleCkpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmZpbHRlcigoeCkgPT4gISF4KTsgLy8gZmlsdGVyIG51bGxzXG4gICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoaXRlbXMpLnRoZW4oKHJlc3VsdHMpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUGFyc2VTdGF0dXMubWVyZ2VBcnJheShzdGF0dXMsIHJlc3VsdHMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gUGFyc2VTdGF0dXMubWVyZ2VBcnJheShzdGF0dXMsIGl0ZW1zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgaXRlbXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuaXRlbXM7XG4gICAgfVxuICAgIHJlc3QocmVzdCkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZFR1cGxlKHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIHJlc3QsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cblpvZFR1cGxlLmNyZWF0ZSA9IChzY2hlbWFzLCBwYXJhbXMpID0+IHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoc2NoZW1hcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IG11c3QgcGFzcyBhbiBhcnJheSBvZiBzY2hlbWFzIHRvIHoudHVwbGUoWyAuLi4gXSlcIik7XG4gICAgfVxuICAgIHJldHVybiBuZXcgWm9kVHVwbGUoe1xuICAgICAgICBpdGVtczogc2NoZW1hcyxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RUdXBsZSxcbiAgICAgICAgcmVzdDogbnVsbCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmV4cG9ydCBjbGFzcyBab2RSZWNvcmQgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBnZXQga2V5U2NoZW1hKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmtleVR5cGU7XG4gICAgfVxuICAgIGdldCB2YWx1ZVNjaGVtYSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi52YWx1ZVR5cGU7XG4gICAgfVxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IHN0YXR1cywgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBpZiAoY3R4LnBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUub2JqZWN0KSB7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLm9iamVjdCxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhaXJzID0gW107XG4gICAgICAgIGNvbnN0IGtleVR5cGUgPSB0aGlzLl9kZWYua2V5VHlwZTtcbiAgICAgICAgY29uc3QgdmFsdWVUeXBlID0gdGhpcy5fZGVmLnZhbHVlVHlwZTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gY3R4LmRhdGEpIHtcbiAgICAgICAgICAgIHBhaXJzLnB1c2goe1xuICAgICAgICAgICAgICAgIGtleToga2V5VHlwZS5fcGFyc2UobmV3IFBhcnNlSW5wdXRMYXp5UGF0aChjdHgsIGtleSwgY3R4LnBhdGgsIGtleSkpLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVR5cGUuX3BhcnNlKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCBjdHguZGF0YVtrZXldLCBjdHgucGF0aCwga2V5KSksXG4gICAgICAgICAgICAgICAgYWx3YXlzU2V0OiBrZXkgaW4gY3R4LmRhdGEsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgICAgICAgcmV0dXJuIFBhcnNlU3RhdHVzLm1lcmdlT2JqZWN0QXN5bmMoc3RhdHVzLCBwYWlycyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gUGFyc2VTdGF0dXMubWVyZ2VPYmplY3RTeW5jKHN0YXR1cywgcGFpcnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBlbGVtZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnZhbHVlVHlwZTtcbiAgICB9XG4gICAgc3RhdGljIGNyZWF0ZShmaXJzdCwgc2Vjb25kLCB0aGlyZCkge1xuICAgICAgICBpZiAoc2Vjb25kIGluc3RhbmNlb2YgWm9kVHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBab2RSZWNvcmQoe1xuICAgICAgICAgICAgICAgIGtleVR5cGU6IGZpcnN0LFxuICAgICAgICAgICAgICAgIHZhbHVlVHlwZTogc2Vjb25kLFxuICAgICAgICAgICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kUmVjb3JkLFxuICAgICAgICAgICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXModGhpcmQpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBab2RSZWNvcmQoe1xuICAgICAgICAgICAga2V5VHlwZTogWm9kU3RyaW5nLmNyZWF0ZSgpLFxuICAgICAgICAgICAgdmFsdWVUeXBlOiBmaXJzdCxcbiAgICAgICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kUmVjb3JkLFxuICAgICAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhzZWNvbmQpLFxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgWm9kTWFwIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgZ2V0IGtleVNjaGVtYSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5rZXlUeXBlO1xuICAgIH1cbiAgICBnZXQgdmFsdWVTY2hlbWEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYudmFsdWVUeXBlO1xuICAgIH1cbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBzdGF0dXMsIGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLm1hcCkge1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5tYXAsXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBrZXlUeXBlID0gdGhpcy5fZGVmLmtleVR5cGU7XG4gICAgICAgIGNvbnN0IHZhbHVlVHlwZSA9IHRoaXMuX2RlZi52YWx1ZVR5cGU7XG4gICAgICAgIGNvbnN0IHBhaXJzID0gWy4uLmN0eC5kYXRhLmVudHJpZXMoKV0ubWFwKChba2V5LCB2YWx1ZV0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGtleToga2V5VHlwZS5fcGFyc2UobmV3IFBhcnNlSW5wdXRMYXp5UGF0aChjdHgsIGtleSwgY3R4LnBhdGgsIFtpbmRleCwgXCJrZXlcIl0pKSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVUeXBlLl9wYXJzZShuZXcgUGFyc2VJbnB1dExhenlQYXRoKGN0eCwgdmFsdWUsIGN0eC5wYXRoLCBbaW5kZXgsIFwidmFsdWVcIl0pKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgICAgICAgY29uc3QgZmluYWxNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBwYWlyIG9mIHBhaXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IGF3YWl0IHBhaXIua2V5O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IHBhaXIudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkuc3RhdHVzID09PSBcImFib3J0ZWRcIiB8fCB2YWx1ZS5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5LnN0YXR1cyA9PT0gXCJkaXJ0eVwiIHx8IHZhbHVlLnN0YXR1cyA9PT0gXCJkaXJ0eVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmaW5hbE1hcC5zZXQoa2V5LnZhbHVlLCB2YWx1ZS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogZmluYWxNYXAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZmluYWxNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHBhaXIgb2YgcGFpcnMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBwYWlyLmtleTtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHBhaXIudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKGtleS5zdGF0dXMgPT09IFwiYWJvcnRlZFwiIHx8IHZhbHVlLnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChrZXkuc3RhdHVzID09PSBcImRpcnR5XCIgfHwgdmFsdWUuc3RhdHVzID09PSBcImRpcnR5XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsTWFwLnNldChrZXkudmFsdWUsIHZhbHVlLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogZmluYWxNYXAgfTtcbiAgICAgICAgfVxuICAgIH1cbn1cblpvZE1hcC5jcmVhdGUgPSAoa2V5VHlwZSwgdmFsdWVUeXBlLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZE1hcCh7XG4gICAgICAgIHZhbHVlVHlwZSxcbiAgICAgICAga2V5VHlwZSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RNYXAsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5leHBvcnQgY2xhc3MgWm9kU2V0IGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgc3RhdHVzLCBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5zZXQpIHtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUuc2V0LFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGVmID0gdGhpcy5fZGVmO1xuICAgICAgICBpZiAoZGVmLm1pblNpemUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChjdHguZGF0YS5zaXplIDwgZGVmLm1pblNpemUudmFsdWUpIHtcbiAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19zbWFsbCxcbiAgICAgICAgICAgICAgICAgICAgbWluaW11bTogZGVmLm1pblNpemUudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwic2V0XCIsXG4gICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBkZWYubWluU2l6ZS5tZXNzYWdlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChkZWYubWF4U2l6ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGN0eC5kYXRhLnNpemUgPiBkZWYubWF4U2l6ZS52YWx1ZSkge1xuICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX2JpZyxcbiAgICAgICAgICAgICAgICAgICAgbWF4aW11bTogZGVmLm1heFNpemUudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwic2V0XCIsXG4gICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBkZWYubWF4U2l6ZS5tZXNzYWdlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhbHVlVHlwZSA9IHRoaXMuX2RlZi52YWx1ZVR5cGU7XG4gICAgICAgIGZ1bmN0aW9uIGZpbmFsaXplU2V0KGVsZW1lbnRzKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWRTZXQgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgZWxlbWVudHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5zdGF0dXMgPT09IFwiZGlydHlcIilcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgcGFyc2VkU2V0LmFkZChlbGVtZW50LnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogcGFyc2VkU2V0IH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZWxlbWVudHMgPSBbLi4uY3R4LmRhdGEudmFsdWVzKCldLm1hcCgoaXRlbSwgaSkgPT4gdmFsdWVUeXBlLl9wYXJzZShuZXcgUGFyc2VJbnB1dExhenlQYXRoKGN0eCwgaXRlbSwgY3R4LnBhdGgsIGkpKSk7XG4gICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoZWxlbWVudHMpLnRoZW4oKGVsZW1lbnRzKSA9PiBmaW5hbGl6ZVNldChlbGVtZW50cykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZpbmFsaXplU2V0KGVsZW1lbnRzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtaW4obWluU2l6ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZFNldCh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBtaW5TaXplOiB7IHZhbHVlOiBtaW5TaXplLCBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG1heChtYXhTaXplLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kU2V0KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIG1heFNpemU6IHsgdmFsdWU6IG1heFNpemUsIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2l6ZShzaXplLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbihzaXplLCBtZXNzYWdlKS5tYXgoc2l6ZSwgbWVzc2FnZSk7XG4gICAgfVxuICAgIG5vbmVtcHR5KG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWluKDEsIG1lc3NhZ2UpO1xuICAgIH1cbn1cblpvZFNldC5jcmVhdGUgPSAodmFsdWVUeXBlLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZFNldCh7XG4gICAgICAgIHZhbHVlVHlwZSxcbiAgICAgICAgbWluU2l6ZTogbnVsbCxcbiAgICAgICAgbWF4U2l6ZTogbnVsbCxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RTZXQsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5leHBvcnQgY2xhc3MgWm9kRnVuY3Rpb24gZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy52YWxpZGF0ZSA9IHRoaXMuaW1wbGVtZW50O1xuICAgIH1cbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5mdW5jdGlvbikge1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5mdW5jdGlvbixcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG1ha2VBcmdzSXNzdWUoYXJncywgZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBtYWtlSXNzdWUoe1xuICAgICAgICAgICAgICAgIGRhdGE6IGFyZ3MsXG4gICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgZXJyb3JNYXBzOiBbY3R4LmNvbW1vbi5jb250ZXh0dWFsRXJyb3JNYXAsIGN0eC5zY2hlbWFFcnJvck1hcCwgZ2V0RXJyb3JNYXAoKSwgZGVmYXVsdEVycm9yTWFwXS5maWx0ZXIoKHgpID0+ICEheCksXG4gICAgICAgICAgICAgICAgaXNzdWVEYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX2FyZ3VtZW50cyxcbiAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzRXJyb3I6IGVycm9yLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBtYWtlUmV0dXJuc0lzc3VlKHJldHVybnMsIGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gbWFrZUlzc3VlKHtcbiAgICAgICAgICAgICAgICBkYXRhOiByZXR1cm5zLFxuICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgIGVycm9yTWFwczogW2N0eC5jb21tb24uY29udGV4dHVhbEVycm9yTWFwLCBjdHguc2NoZW1hRXJyb3JNYXAsIGdldEVycm9yTWFwKCksIGRlZmF1bHRFcnJvck1hcF0uZmlsdGVyKCh4KSA9PiAhIXgpLFxuICAgICAgICAgICAgICAgIGlzc3VlRGF0YToge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9yZXR1cm5fdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuVHlwZUVycm9yOiBlcnJvcixcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyYW1zID0geyBlcnJvck1hcDogY3R4LmNvbW1vbi5jb250ZXh0dWFsRXJyb3JNYXAgfTtcbiAgICAgICAgY29uc3QgZm4gPSBjdHguZGF0YTtcbiAgICAgICAgaWYgKHRoaXMuX2RlZi5yZXR1cm5zIGluc3RhbmNlb2YgWm9kUHJvbWlzZSkge1xuICAgICAgICAgICAgLy8gV291bGQgbG92ZSBhIHdheSB0byBhdm9pZCBkaXNhYmxpbmcgdGhpcyBydWxlLCBidXQgd2UgbmVlZFxuICAgICAgICAgICAgLy8gYW4gYWxpYXMgKHVzaW5nIGFuIGFycm93IGZ1bmN0aW9uIHdhcyB3aGF0IGNhdXNlZCAyNjUxKS5cbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdGhpcy1hbGlhc1xuICAgICAgICAgICAgY29uc3QgbWUgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIE9LKGFzeW5jIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgWm9kRXJyb3IoW10pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZEFyZ3MgPSBhd2FpdCBtZS5fZGVmLmFyZ3MucGFyc2VBc3luYyhhcmdzLCBwYXJhbXMpLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yLmFkZElzc3VlKG1ha2VBcmdzSXNzdWUoYXJncywgZSkpO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBSZWZsZWN0LmFwcGx5KGZuLCB0aGlzLCBwYXJzZWRBcmdzKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWRSZXR1cm5zID0gYXdhaXQgbWUuX2RlZi5yZXR1cm5zLl9kZWYudHlwZVxuICAgICAgICAgICAgICAgICAgICAucGFyc2VBc3luYyhyZXN1bHQsIHBhcmFtcylcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yLmFkZElzc3VlKG1ha2VSZXR1cm5zSXNzdWUocmVzdWx0LCBlKSk7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZWRSZXR1cm5zO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBXb3VsZCBsb3ZlIGEgd2F5IHRvIGF2b2lkIGRpc2FibGluZyB0aGlzIHJ1bGUsIGJ1dCB3ZSBuZWVkXG4gICAgICAgICAgICAvLyBhbiBhbGlhcyAodXNpbmcgYW4gYXJyb3cgZnVuY3Rpb24gd2FzIHdoYXQgY2F1c2VkIDI2NTEpLlxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby10aGlzLWFsaWFzXG4gICAgICAgICAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gT0soZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWRBcmdzID0gbWUuX2RlZi5hcmdzLnNhZmVQYXJzZShhcmdzLCBwYXJhbXMpO1xuICAgICAgICAgICAgICAgIGlmICghcGFyc2VkQXJncy5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBab2RFcnJvcihbbWFrZUFyZ3NJc3N1ZShhcmdzLCBwYXJzZWRBcmdzLmVycm9yKV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBSZWZsZWN0LmFwcGx5KGZuLCB0aGlzLCBwYXJzZWRBcmdzLmRhdGEpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZFJldHVybnMgPSBtZS5fZGVmLnJldHVybnMuc2FmZVBhcnNlKHJlc3VsdCwgcGFyYW1zKTtcbiAgICAgICAgICAgICAgICBpZiAoIXBhcnNlZFJldHVybnMuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgWm9kRXJyb3IoW21ha2VSZXR1cm5zSXNzdWUocmVzdWx0LCBwYXJzZWRSZXR1cm5zLmVycm9yKV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VkUmV0dXJucy5kYXRhO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcGFyYW1ldGVycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5hcmdzO1xuICAgIH1cbiAgICByZXR1cm5UeXBlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnJldHVybnM7XG4gICAgfVxuICAgIGFyZ3MoLi4uaXRlbXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RGdW5jdGlvbih7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBhcmdzOiBab2RUdXBsZS5jcmVhdGUoaXRlbXMpLnJlc3QoWm9kVW5rbm93bi5jcmVhdGUoKSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm5zKHJldHVyblR5cGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RGdW5jdGlvbih7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICByZXR1cm5zOiByZXR1cm5UeXBlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaW1wbGVtZW50KGZ1bmMpIHtcbiAgICAgICAgY29uc3QgdmFsaWRhdGVkRnVuYyA9IHRoaXMucGFyc2UoZnVuYyk7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZWRGdW5jO1xuICAgIH1cbiAgICBzdHJpY3RJbXBsZW1lbnQoZnVuYykge1xuICAgICAgICBjb25zdCB2YWxpZGF0ZWRGdW5jID0gdGhpcy5wYXJzZShmdW5jKTtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlZEZ1bmM7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGUoYXJncywgcmV0dXJucywgcGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kRnVuY3Rpb24oe1xuICAgICAgICAgICAgYXJnczogKGFyZ3MgPyBhcmdzIDogWm9kVHVwbGUuY3JlYXRlKFtdKS5yZXN0KFpvZFVua25vd24uY3JlYXRlKCkpKSxcbiAgICAgICAgICAgIHJldHVybnM6IHJldHVybnMgfHwgWm9kVW5rbm93bi5jcmVhdGUoKSxcbiAgICAgICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRnVuY3Rpb24sXG4gICAgICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBab2RMYXp5IGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgZ2V0IHNjaGVtYSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5nZXR0ZXIoKTtcbiAgICB9XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBjb25zdCBsYXp5U2NoZW1hID0gdGhpcy5fZGVmLmdldHRlcigpO1xuICAgICAgICByZXR1cm4gbGF6eVNjaGVtYS5fcGFyc2UoeyBkYXRhOiBjdHguZGF0YSwgcGF0aDogY3R4LnBhdGgsIHBhcmVudDogY3R4IH0pO1xuICAgIH1cbn1cblpvZExhenkuY3JlYXRlID0gKGdldHRlciwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RMYXp5KHtcbiAgICAgICAgZ2V0dGVyOiBnZXR0ZXIsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTGF6eSxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmV4cG9ydCBjbGFzcyBab2RMaXRlcmFsIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGlmIChpbnB1dC5kYXRhICE9PSB0aGlzLl9kZWYudmFsdWUpIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9saXRlcmFsLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiB0aGlzLl9kZWYudmFsdWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHN0YXR1czogXCJ2YWxpZFwiLCB2YWx1ZTogaW5wdXQuZGF0YSB9O1xuICAgIH1cbiAgICBnZXQgdmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYudmFsdWU7XG4gICAgfVxufVxuWm9kTGl0ZXJhbC5jcmVhdGUgPSAodmFsdWUsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kTGl0ZXJhbCh7XG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RMaXRlcmFsLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuZnVuY3Rpb24gY3JlYXRlWm9kRW51bSh2YWx1ZXMsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgWm9kRW51bSh7XG4gICAgICAgIHZhbHVlcyxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RFbnVtLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG5leHBvcnQgY2xhc3MgWm9kRW51bSBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0LmRhdGEgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGNvbnN0IGV4cGVjdGVkVmFsdWVzID0gdGhpcy5fZGVmLnZhbHVlcztcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiB1dGlsLmpvaW5WYWx1ZXMoZXhwZWN0ZWRWYWx1ZXMpLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX2NhY2hlKSB7XG4gICAgICAgICAgICB0aGlzLl9jYWNoZSA9IG5ldyBTZXQodGhpcy5fZGVmLnZhbHVlcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9jYWNoZS5oYXMoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGNvbnN0IGV4cGVjdGVkVmFsdWVzID0gdGhpcy5fZGVmLnZhbHVlcztcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9lbnVtX3ZhbHVlLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGV4cGVjdGVkVmFsdWVzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT0soaW5wdXQuZGF0YSk7XG4gICAgfVxuICAgIGdldCBvcHRpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnZhbHVlcztcbiAgICB9XG4gICAgZ2V0IGVudW0oKSB7XG4gICAgICAgIGNvbnN0IGVudW1WYWx1ZXMgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCB2YWwgb2YgdGhpcy5fZGVmLnZhbHVlcykge1xuICAgICAgICAgICAgZW51bVZhbHVlc1t2YWxdID0gdmFsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbnVtVmFsdWVzO1xuICAgIH1cbiAgICBnZXQgVmFsdWVzKCkge1xuICAgICAgICBjb25zdCBlbnVtVmFsdWVzID0ge307XG4gICAgICAgIGZvciAoY29uc3QgdmFsIG9mIHRoaXMuX2RlZi52YWx1ZXMpIHtcbiAgICAgICAgICAgIGVudW1WYWx1ZXNbdmFsXSA9IHZhbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW51bVZhbHVlcztcbiAgICB9XG4gICAgZ2V0IEVudW0oKSB7XG4gICAgICAgIGNvbnN0IGVudW1WYWx1ZXMgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCB2YWwgb2YgdGhpcy5fZGVmLnZhbHVlcykge1xuICAgICAgICAgICAgZW51bVZhbHVlc1t2YWxdID0gdmFsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbnVtVmFsdWVzO1xuICAgIH1cbiAgICBleHRyYWN0KHZhbHVlcywgbmV3RGVmID0gdGhpcy5fZGVmKSB7XG4gICAgICAgIHJldHVybiBab2RFbnVtLmNyZWF0ZSh2YWx1ZXMsIHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIC4uLm5ld0RlZixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGV4Y2x1ZGUodmFsdWVzLCBuZXdEZWYgPSB0aGlzLl9kZWYpIHtcbiAgICAgICAgcmV0dXJuIFpvZEVudW0uY3JlYXRlKHRoaXMub3B0aW9ucy5maWx0ZXIoKG9wdCkgPT4gIXZhbHVlcy5pbmNsdWRlcyhvcHQpKSwge1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgLi4ubmV3RGVmLFxuICAgICAgICB9KTtcbiAgICB9XG59XG5ab2RFbnVtLmNyZWF0ZSA9IGNyZWF0ZVpvZEVudW07XG5leHBvcnQgY2xhc3MgWm9kTmF0aXZlRW51bSBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCBuYXRpdmVFbnVtVmFsdWVzID0gdXRpbC5nZXRWYWxpZEVudW1WYWx1ZXModGhpcy5fZGVmLnZhbHVlcyk7XG4gICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLnN0cmluZyAmJiBjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5udW1iZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4cGVjdGVkVmFsdWVzID0gdXRpbC5vYmplY3RWYWx1ZXMobmF0aXZlRW51bVZhbHVlcyk7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogdXRpbC5qb2luVmFsdWVzKGV4cGVjdGVkVmFsdWVzKSxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9jYWNoZSkge1xuICAgICAgICAgICAgdGhpcy5fY2FjaGUgPSBuZXcgU2V0KHV0aWwuZ2V0VmFsaWRFbnVtVmFsdWVzKHRoaXMuX2RlZi52YWx1ZXMpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX2NhY2hlLmhhcyhpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWRWYWx1ZXMgPSB1dGlsLm9iamVjdFZhbHVlcyhuYXRpdmVFbnVtVmFsdWVzKTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9lbnVtX3ZhbHVlLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGV4cGVjdGVkVmFsdWVzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT0soaW5wdXQuZGF0YSk7XG4gICAgfVxuICAgIGdldCBlbnVtKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnZhbHVlcztcbiAgICB9XG59XG5ab2ROYXRpdmVFbnVtLmNyZWF0ZSA9ICh2YWx1ZXMsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kTmF0aXZlRW51bSh7XG4gICAgICAgIHZhbHVlczogdmFsdWVzLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE5hdGl2ZUVudW0sXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5leHBvcnQgY2xhc3MgWm9kUHJvbWlzZSBleHRlbmRzIFpvZFR5cGUge1xuICAgIHVud3JhcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi50eXBlO1xuICAgIH1cbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5wcm9taXNlICYmIGN0eC5jb21tb24uYXN5bmMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLnByb21pc2UsXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcm9taXNpZmllZCA9IGN0eC5wYXJzZWRUeXBlID09PSBab2RQYXJzZWRUeXBlLnByb21pc2UgPyBjdHguZGF0YSA6IFByb21pc2UucmVzb2x2ZShjdHguZGF0YSk7XG4gICAgICAgIHJldHVybiBPSyhwcm9taXNpZmllZC50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnR5cGUucGFyc2VBc3luYyhkYXRhLCB7XG4gICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgZXJyb3JNYXA6IGN0eC5jb21tb24uY29udGV4dHVhbEVycm9yTWFwLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pKTtcbiAgICB9XG59XG5ab2RQcm9taXNlLmNyZWF0ZSA9IChzY2hlbWEsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kUHJvbWlzZSh7XG4gICAgICAgIHR5cGU6IHNjaGVtYSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RQcm9taXNlLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuZXhwb3J0IGNsYXNzIFpvZEVmZmVjdHMgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBpbm5lclR5cGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuc2NoZW1hO1xuICAgIH1cbiAgICBzb3VyY2VUeXBlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnNjaGVtYS5fZGVmLnR5cGVOYW1lID09PSBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRWZmZWN0c1xuICAgICAgICAgICAgPyB0aGlzLl9kZWYuc2NoZW1hLnNvdXJjZVR5cGUoKVxuICAgICAgICAgICAgOiB0aGlzLl9kZWYuc2NoZW1hO1xuICAgIH1cbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBzdGF0dXMsIGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgY29uc3QgZWZmZWN0ID0gdGhpcy5fZGVmLmVmZmVjdCB8fCBudWxsO1xuICAgICAgICBjb25zdCBjaGVja0N0eCA9IHtcbiAgICAgICAgICAgIGFkZElzc3VlOiAoYXJnKSA9PiB7XG4gICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCBhcmcpO1xuICAgICAgICAgICAgICAgIGlmIChhcmcuZmF0YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmFib3J0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0IHBhdGgoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGN0eC5wYXRoO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgY2hlY2tDdHguYWRkSXNzdWUgPSBjaGVja0N0eC5hZGRJc3N1ZS5iaW5kKGNoZWNrQ3R4KTtcbiAgICAgICAgaWYgKGVmZmVjdC50eXBlID09PSBcInByZXByb2Nlc3NcIikge1xuICAgICAgICAgICAgY29uc3QgcHJvY2Vzc2VkID0gZWZmZWN0LnRyYW5zZm9ybShjdHguZGF0YSwgY2hlY2tDdHgpO1xuICAgICAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHByb2Nlc3NlZCkudGhlbihhc3luYyAocHJvY2Vzc2VkKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0dXMudmFsdWUgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuX2RlZi5zY2hlbWEuX3BhcnNlQXN5bmMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogcHJvY2Vzc2VkLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuc3RhdHVzID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnN0YXR1cyA9PT0gXCJkaXJ0eVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIERJUlRZKHJlc3VsdC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0dXMudmFsdWUgPT09IFwiZGlydHlcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBESVJUWShyZXN1bHQudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXR1cy52YWx1ZSA9PT0gXCJhYm9ydGVkXCIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX2RlZi5zY2hlbWEuX3BhcnNlU3luYyh7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHByb2Nlc3NlZCxcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuc3RhdHVzID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5zdGF0dXMgPT09IFwiZGlydHlcIilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIERJUlRZKHJlc3VsdC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXR1cy52YWx1ZSA9PT0gXCJkaXJ0eVwiKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRElSVFkocmVzdWx0LnZhbHVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChlZmZlY3QudHlwZSA9PT0gXCJyZWZpbmVtZW50XCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4ZWN1dGVSZWZpbmVtZW50ID0gKGFjYykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGVmZmVjdC5yZWZpbmVtZW50KGFjYywgY2hlY2tDdHgpO1xuICAgICAgICAgICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXN5bmMgcmVmaW5lbWVudCBlbmNvdW50ZXJlZCBkdXJpbmcgc3luY2hyb25vdXMgcGFyc2Ugb3BlcmF0aW9uLiBVc2UgLnBhcnNlQXN5bmMgaW5zdGVhZC5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5uZXIgPSB0aGlzLl9kZWYuc2NoZW1hLl9wYXJzZVN5bmMoe1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChpbm5lci5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgICAgICBpZiAoaW5uZXIuc3RhdHVzID09PSBcImRpcnR5XCIpXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIC8vIHJldHVybiB2YWx1ZSBpcyBpZ25vcmVkXG4gICAgICAgICAgICAgICAgZXhlY3V0ZVJlZmluZW1lbnQoaW5uZXIudmFsdWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogaW5uZXIudmFsdWUgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZWYuc2NoZW1hLl9wYXJzZUFzeW5jKHsgZGF0YTogY3R4LmRhdGEsIHBhdGg6IGN0eC5wYXRoLCBwYXJlbnQ6IGN0eCB9KS50aGVuKChpbm5lcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5uZXIuc3RhdHVzID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5uZXIuc3RhdHVzID09PSBcImRpcnR5XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV4ZWN1dGVSZWZpbmVtZW50KGlubmVyLnZhbHVlKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogaW5uZXIudmFsdWUgfTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVmZmVjdC50eXBlID09PSBcInRyYW5zZm9ybVwiKSB7XG4gICAgICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBiYXNlID0gdGhpcy5fZGVmLnNjaGVtYS5fcGFyc2VTeW5jKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzVmFsaWQoYmFzZSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGVmZmVjdC50cmFuc2Zvcm0oYmFzZS52YWx1ZSwgY2hlY2tDdHgpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQXN5bmNocm9ub3VzIHRyYW5zZm9ybSBlbmNvdW50ZXJlZCBkdXJpbmcgc3luY2hyb25vdXMgcGFyc2Ugb3BlcmF0aW9uLiBVc2UgLnBhcnNlQXN5bmMgaW5zdGVhZC5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiByZXN1bHQgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZWYuc2NoZW1hLl9wYXJzZUFzeW5jKHsgZGF0YTogY3R4LmRhdGEsIHBhdGg6IGN0eC5wYXRoLCBwYXJlbnQ6IGN0eCB9KS50aGVuKChiYXNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNWYWxpZChiYXNlKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGVmZmVjdC50cmFuc2Zvcm0oYmFzZS52YWx1ZSwgY2hlY2tDdHgpKS50aGVuKChyZXN1bHQpID0+ICh7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IHN0YXR1cy52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiByZXN1bHQsXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB1dGlsLmFzc2VydE5ldmVyKGVmZmVjdCk7XG4gICAgfVxufVxuWm9kRWZmZWN0cy5jcmVhdGUgPSAoc2NoZW1hLCBlZmZlY3QsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kRWZmZWN0cyh7XG4gICAgICAgIHNjaGVtYSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RFZmZlY3RzLFxuICAgICAgICBlZmZlY3QsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5ab2RFZmZlY3RzLmNyZWF0ZVdpdGhQcmVwcm9jZXNzID0gKHByZXByb2Nlc3MsIHNjaGVtYSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RFZmZlY3RzKHtcbiAgICAgICAgc2NoZW1hLFxuICAgICAgICBlZmZlY3Q6IHsgdHlwZTogXCJwcmVwcm9jZXNzXCIsIHRyYW5zZm9ybTogcHJlcHJvY2VzcyB9LFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEVmZmVjdHMsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5leHBvcnQgeyBab2RFZmZlY3RzIGFzIFpvZFRyYW5zZm9ybWVyIH07XG5leHBvcnQgY2xhc3MgWm9kT3B0aW9uYWwgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSA9PT0gWm9kUGFyc2VkVHlwZS51bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBPSyh1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuaW5uZXJUeXBlLl9wYXJzZShpbnB1dCk7XG4gICAgfVxuICAgIHVud3JhcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5pbm5lclR5cGU7XG4gICAgfVxufVxuWm9kT3B0aW9uYWwuY3JlYXRlID0gKHR5cGUsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kT3B0aW9uYWwoe1xuICAgICAgICBpbm5lclR5cGU6IHR5cGUsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kT3B0aW9uYWwsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5leHBvcnQgY2xhc3MgWm9kTnVsbGFibGUgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSA9PT0gWm9kUGFyc2VkVHlwZS5udWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gT0sobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5pbm5lclR5cGUuX3BhcnNlKGlucHV0KTtcbiAgICB9XG4gICAgdW53cmFwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmlubmVyVHlwZTtcbiAgICB9XG59XG5ab2ROdWxsYWJsZS5jcmVhdGUgPSAodHlwZSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2ROdWxsYWJsZSh7XG4gICAgICAgIGlubmVyVHlwZTogdHlwZSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2ROdWxsYWJsZSxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmV4cG9ydCBjbGFzcyBab2REZWZhdWx0IGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBsZXQgZGF0YSA9IGN0eC5kYXRhO1xuICAgICAgICBpZiAoY3R4LnBhcnNlZFR5cGUgPT09IFpvZFBhcnNlZFR5cGUudW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBkYXRhID0gdGhpcy5fZGVmLmRlZmF1bHRWYWx1ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuaW5uZXJUeXBlLl9wYXJzZSh7XG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlbW92ZURlZmF1bHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuaW5uZXJUeXBlO1xuICAgIH1cbn1cblpvZERlZmF1bHQuY3JlYXRlID0gKHR5cGUsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kRGVmYXVsdCh7XG4gICAgICAgIGlubmVyVHlwZTogdHlwZSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2REZWZhdWx0LFxuICAgICAgICBkZWZhdWx0VmFsdWU6IHR5cGVvZiBwYXJhbXMuZGVmYXVsdCA9PT0gXCJmdW5jdGlvblwiID8gcGFyYW1zLmRlZmF1bHQgOiAoKSA9PiBwYXJhbXMuZGVmYXVsdCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmV4cG9ydCBjbGFzcyBab2RDYXRjaCBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgLy8gbmV3Q3R4IGlzIHVzZWQgdG8gbm90IGNvbGxlY3QgaXNzdWVzIGZyb20gaW5uZXIgdHlwZXMgaW4gY3R4XG4gICAgICAgIGNvbnN0IG5ld0N0eCA9IHtcbiAgICAgICAgICAgIC4uLmN0eCxcbiAgICAgICAgICAgIGNvbW1vbjoge1xuICAgICAgICAgICAgICAgIC4uLmN0eC5jb21tb24sXG4gICAgICAgICAgICAgICAgaXNzdWVzOiBbXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX2RlZi5pbm5lclR5cGUuX3BhcnNlKHtcbiAgICAgICAgICAgIGRhdGE6IG5ld0N0eC5kYXRhLFxuICAgICAgICAgICAgcGF0aDogbmV3Q3R4LnBhdGgsXG4gICAgICAgICAgICBwYXJlbnQ6IHtcbiAgICAgICAgICAgICAgICAuLi5uZXdDdHgsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGlzQXN5bmMocmVzdWx0KSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IFwidmFsaWRcIixcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHJlc3VsdC5zdGF0dXMgPT09IFwidmFsaWRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgPyByZXN1bHQudmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdGhpcy5fZGVmLmNhdGNoVmFsdWUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldCBlcnJvcigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBab2RFcnJvcihuZXdDdHguY29tbW9uLmlzc3Vlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dDogbmV3Q3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN0YXR1czogXCJ2YWxpZFwiLFxuICAgICAgICAgICAgICAgIHZhbHVlOiByZXN1bHQuc3RhdHVzID09PSBcInZhbGlkXCJcbiAgICAgICAgICAgICAgICAgICAgPyByZXN1bHQudmFsdWVcbiAgICAgICAgICAgICAgICAgICAgOiB0aGlzLl9kZWYuY2F0Y2hWYWx1ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXQgZXJyb3IoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBab2RFcnJvcihuZXdDdHguY29tbW9uLmlzc3Vlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQ6IG5ld0N0eC5kYXRhLFxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVtb3ZlQ2F0Y2goKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuaW5uZXJUeXBlO1xuICAgIH1cbn1cblpvZENhdGNoLmNyZWF0ZSA9ICh0eXBlLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZENhdGNoKHtcbiAgICAgICAgaW5uZXJUeXBlOiB0eXBlLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZENhdGNoLFxuICAgICAgICBjYXRjaFZhbHVlOiB0eXBlb2YgcGFyYW1zLmNhdGNoID09PSBcImZ1bmN0aW9uXCIgPyBwYXJhbXMuY2F0Y2ggOiAoKSA9PiBwYXJhbXMuY2F0Y2gsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5leHBvcnQgY2xhc3MgWm9kTmFOIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICAgICAgaWYgKHBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUubmFuKSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLm5hbixcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHN0YXR1czogXCJ2YWxpZFwiLCB2YWx1ZTogaW5wdXQuZGF0YSB9O1xuICAgIH1cbn1cblpvZE5hTi5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2ROYU4oe1xuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE5hTixcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmV4cG9ydCBjb25zdCBCUkFORCA9IFN5bWJvbChcInpvZF9icmFuZFwiKTtcbmV4cG9ydCBjbGFzcyBab2RCcmFuZGVkIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBjb25zdCBkYXRhID0gY3R4LmRhdGE7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYudHlwZS5fcGFyc2Uoe1xuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgcGFyZW50OiBjdHgsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB1bndyYXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYudHlwZTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgWm9kUGlwZWxpbmUgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBzdGF0dXMsIGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZUFzeW5jID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluUmVzdWx0ID0gYXdhaXQgdGhpcy5fZGVmLmluLl9wYXJzZUFzeW5jKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoaW5SZXN1bHQuc3RhdHVzID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICAgICAgaWYgKGluUmVzdWx0LnN0YXR1cyA9PT0gXCJkaXJ0eVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRElSVFkoaW5SZXN1bHQudmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5vdXQuX3BhcnNlQXN5bmMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogaW5SZXN1bHQudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZUFzeW5jKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBpblJlc3VsdCA9IHRoaXMuX2RlZi5pbi5fcGFyc2VTeW5jKHtcbiAgICAgICAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGluUmVzdWx0LnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICBpZiAoaW5SZXN1bHQuc3RhdHVzID09PSBcImRpcnR5XCIpIHtcbiAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IFwiZGlydHlcIixcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGluUmVzdWx0LnZhbHVlLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVmLm91dC5fcGFyc2VTeW5jKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogaW5SZXN1bHQudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgY3JlYXRlKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RQaXBlbGluZSh7XG4gICAgICAgICAgICBpbjogYSxcbiAgICAgICAgICAgIG91dDogYixcbiAgICAgICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kUGlwZWxpbmUsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBab2RSZWFkb25seSBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9kZWYuaW5uZXJUeXBlLl9wYXJzZShpbnB1dCk7XG4gICAgICAgIGNvbnN0IGZyZWV6ZSA9IChkYXRhKSA9PiB7XG4gICAgICAgICAgICBpZiAoaXNWYWxpZChkYXRhKSkge1xuICAgICAgICAgICAgICAgIGRhdGEudmFsdWUgPSBPYmplY3QuZnJlZXplKGRhdGEudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBpc0FzeW5jKHJlc3VsdCkgPyByZXN1bHQudGhlbigoZGF0YSkgPT4gZnJlZXplKGRhdGEpKSA6IGZyZWV6ZShyZXN1bHQpO1xuICAgIH1cbiAgICB1bndyYXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuaW5uZXJUeXBlO1xuICAgIH1cbn1cblpvZFJlYWRvbmx5LmNyZWF0ZSA9ICh0eXBlLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZFJlYWRvbmx5KHtcbiAgICAgICAgaW5uZXJUeXBlOiB0eXBlLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFJlYWRvbmx5LFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vLy8vLy8vLyAgICAgICAgICAgICAgICAgICAgLy8vLy8vLy8vL1xuLy8vLy8vLy8vLyAgICAgIHouY3VzdG9tICAgICAgLy8vLy8vLy8vL1xuLy8vLy8vLy8vLyAgICAgICAgICAgICAgICAgICAgLy8vLy8vLy8vL1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuZnVuY3Rpb24gY2xlYW5QYXJhbXMocGFyYW1zLCBkYXRhKSB7XG4gICAgY29uc3QgcCA9IHR5cGVvZiBwYXJhbXMgPT09IFwiZnVuY3Rpb25cIiA/IHBhcmFtcyhkYXRhKSA6IHR5cGVvZiBwYXJhbXMgPT09IFwic3RyaW5nXCIgPyB7IG1lc3NhZ2U6IHBhcmFtcyB9IDogcGFyYW1zO1xuICAgIGNvbnN0IHAyID0gdHlwZW9mIHAgPT09IFwic3RyaW5nXCIgPyB7IG1lc3NhZ2U6IHAgfSA6IHA7XG4gICAgcmV0dXJuIHAyO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGN1c3RvbShjaGVjaywgX3BhcmFtcyA9IHt9LCBcbi8qKlxuICogQGRlcHJlY2F0ZWRcbiAqXG4gKiBQYXNzIGBmYXRhbGAgaW50byB0aGUgcGFyYW1zIG9iamVjdCBpbnN0ZWFkOlxuICpcbiAqIGBgYHRzXG4gKiB6LnN0cmluZygpLmN1c3RvbSgodmFsKSA9PiB2YWwubGVuZ3RoID4gNSwgeyBmYXRhbDogZmFsc2UgfSlcbiAqIGBgYFxuICpcbiAqL1xuZmF0YWwpIHtcbiAgICBpZiAoY2hlY2spXG4gICAgICAgIHJldHVybiBab2RBbnkuY3JlYXRlKCkuc3VwZXJSZWZpbmUoKGRhdGEsIGN0eCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgciA9IGNoZWNrKGRhdGEpO1xuICAgICAgICAgICAgaWYgKHIgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHIudGhlbigocikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IGNsZWFuUGFyYW1zKF9wYXJhbXMsIGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgX2ZhdGFsID0gcGFyYW1zLmZhdGFsID8/IGZhdGFsID8/IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguYWRkSXNzdWUoeyBjb2RlOiBcImN1c3RvbVwiLCAuLi5wYXJhbXMsIGZhdGFsOiBfZmF0YWwgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IGNsZWFuUGFyYW1zKF9wYXJhbXMsIGRhdGEpO1xuICAgICAgICAgICAgICAgIGNvbnN0IF9mYXRhbCA9IHBhcmFtcy5mYXRhbCA/PyBmYXRhbCA/PyB0cnVlO1xuICAgICAgICAgICAgICAgIGN0eC5hZGRJc3N1ZSh7IGNvZGU6IFwiY3VzdG9tXCIsIC4uLnBhcmFtcywgZmF0YWw6IF9mYXRhbCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSk7XG4gICAgcmV0dXJuIFpvZEFueS5jcmVhdGUoKTtcbn1cbmV4cG9ydCB7IFpvZFR5cGUgYXMgU2NoZW1hLCBab2RUeXBlIGFzIFpvZFNjaGVtYSB9O1xuZXhwb3J0IGNvbnN0IGxhdGUgPSB7XG4gICAgb2JqZWN0OiBab2RPYmplY3QubGF6eWNyZWF0ZSxcbn07XG5leHBvcnQgdmFyIFpvZEZpcnN0UGFydHlUeXBlS2luZDtcbihmdW5jdGlvbiAoWm9kRmlyc3RQYXJ0eVR5cGVLaW5kKSB7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kU3RyaW5nXCJdID0gXCJab2RTdHJpbmdcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2ROdW1iZXJcIl0gPSBcIlpvZE51bWJlclwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZE5hTlwiXSA9IFwiWm9kTmFOXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kQmlnSW50XCJdID0gXCJab2RCaWdJbnRcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RCb29sZWFuXCJdID0gXCJab2RCb29sZWFuXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kRGF0ZVwiXSA9IFwiWm9kRGF0ZVwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZFN5bWJvbFwiXSA9IFwiWm9kU3ltYm9sXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kVW5kZWZpbmVkXCJdID0gXCJab2RVbmRlZmluZWRcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2ROdWxsXCJdID0gXCJab2ROdWxsXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kQW55XCJdID0gXCJab2RBbnlcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RVbmtub3duXCJdID0gXCJab2RVbmtub3duXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kTmV2ZXJcIl0gPSBcIlpvZE5ldmVyXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kVm9pZFwiXSA9IFwiWm9kVm9pZFwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZEFycmF5XCJdID0gXCJab2RBcnJheVwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZE9iamVjdFwiXSA9IFwiWm9kT2JqZWN0XCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kVW5pb25cIl0gPSBcIlpvZFVuaW9uXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kRGlzY3JpbWluYXRlZFVuaW9uXCJdID0gXCJab2REaXNjcmltaW5hdGVkVW5pb25cIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RJbnRlcnNlY3Rpb25cIl0gPSBcIlpvZEludGVyc2VjdGlvblwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZFR1cGxlXCJdID0gXCJab2RUdXBsZVwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZFJlY29yZFwiXSA9IFwiWm9kUmVjb3JkXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kTWFwXCJdID0gXCJab2RNYXBcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RTZXRcIl0gPSBcIlpvZFNldFwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZEZ1bmN0aW9uXCJdID0gXCJab2RGdW5jdGlvblwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZExhenlcIl0gPSBcIlpvZExhenlcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RMaXRlcmFsXCJdID0gXCJab2RMaXRlcmFsXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kRW51bVwiXSA9IFwiWm9kRW51bVwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZEVmZmVjdHNcIl0gPSBcIlpvZEVmZmVjdHNcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2ROYXRpdmVFbnVtXCJdID0gXCJab2ROYXRpdmVFbnVtXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kT3B0aW9uYWxcIl0gPSBcIlpvZE9wdGlvbmFsXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kTnVsbGFibGVcIl0gPSBcIlpvZE51bGxhYmxlXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kRGVmYXVsdFwiXSA9IFwiWm9kRGVmYXVsdFwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZENhdGNoXCJdID0gXCJab2RDYXRjaFwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZFByb21pc2VcIl0gPSBcIlpvZFByb21pc2VcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RCcmFuZGVkXCJdID0gXCJab2RCcmFuZGVkXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kUGlwZWxpbmVcIl0gPSBcIlpvZFBpcGVsaW5lXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kUmVhZG9ubHlcIl0gPSBcIlpvZFJlYWRvbmx5XCI7XG59KShab2RGaXJzdFBhcnR5VHlwZUtpbmQgfHwgKFpvZEZpcnN0UGFydHlUeXBlS2luZCA9IHt9KSk7XG4vLyByZXF1aXJlcyBUUyA0LjQrXG5jbGFzcyBDbGFzcyB7XG4gICAgY29uc3RydWN0b3IoLi4uXykgeyB9XG59XG5jb25zdCBpbnN0YW5jZU9mVHlwZSA9IChcbi8vIGNvbnN0IGluc3RhbmNlT2ZUeXBlID0gPFQgZXh0ZW5kcyBuZXcgKC4uLmFyZ3M6IGFueVtdKSA9PiBhbnk+KFxuY2xzLCBwYXJhbXMgPSB7XG4gICAgbWVzc2FnZTogYElucHV0IG5vdCBpbnN0YW5jZSBvZiAke2Nscy5uYW1lfWAsXG59KSA9PiBjdXN0b20oKGRhdGEpID0+IGRhdGEgaW5zdGFuY2VvZiBjbHMsIHBhcmFtcyk7XG5jb25zdCBzdHJpbmdUeXBlID0gWm9kU3RyaW5nLmNyZWF0ZTtcbmNvbnN0IG51bWJlclR5cGUgPSBab2ROdW1iZXIuY3JlYXRlO1xuY29uc3QgbmFuVHlwZSA9IFpvZE5hTi5jcmVhdGU7XG5jb25zdCBiaWdJbnRUeXBlID0gWm9kQmlnSW50LmNyZWF0ZTtcbmNvbnN0IGJvb2xlYW5UeXBlID0gWm9kQm9vbGVhbi5jcmVhdGU7XG5jb25zdCBkYXRlVHlwZSA9IFpvZERhdGUuY3JlYXRlO1xuY29uc3Qgc3ltYm9sVHlwZSA9IFpvZFN5bWJvbC5jcmVhdGU7XG5jb25zdCB1bmRlZmluZWRUeXBlID0gWm9kVW5kZWZpbmVkLmNyZWF0ZTtcbmNvbnN0IG51bGxUeXBlID0gWm9kTnVsbC5jcmVhdGU7XG5jb25zdCBhbnlUeXBlID0gWm9kQW55LmNyZWF0ZTtcbmNvbnN0IHVua25vd25UeXBlID0gWm9kVW5rbm93bi5jcmVhdGU7XG5jb25zdCBuZXZlclR5cGUgPSBab2ROZXZlci5jcmVhdGU7XG5jb25zdCB2b2lkVHlwZSA9IFpvZFZvaWQuY3JlYXRlO1xuY29uc3QgYXJyYXlUeXBlID0gWm9kQXJyYXkuY3JlYXRlO1xuY29uc3Qgb2JqZWN0VHlwZSA9IFpvZE9iamVjdC5jcmVhdGU7XG5jb25zdCBzdHJpY3RPYmplY3RUeXBlID0gWm9kT2JqZWN0LnN0cmljdENyZWF0ZTtcbmNvbnN0IHVuaW9uVHlwZSA9IFpvZFVuaW9uLmNyZWF0ZTtcbmNvbnN0IGRpc2NyaW1pbmF0ZWRVbmlvblR5cGUgPSBab2REaXNjcmltaW5hdGVkVW5pb24uY3JlYXRlO1xuY29uc3QgaW50ZXJzZWN0aW9uVHlwZSA9IFpvZEludGVyc2VjdGlvbi5jcmVhdGU7XG5jb25zdCB0dXBsZVR5cGUgPSBab2RUdXBsZS5jcmVhdGU7XG5jb25zdCByZWNvcmRUeXBlID0gWm9kUmVjb3JkLmNyZWF0ZTtcbmNvbnN0IG1hcFR5cGUgPSBab2RNYXAuY3JlYXRlO1xuY29uc3Qgc2V0VHlwZSA9IFpvZFNldC5jcmVhdGU7XG5jb25zdCBmdW5jdGlvblR5cGUgPSBab2RGdW5jdGlvbi5jcmVhdGU7XG5jb25zdCBsYXp5VHlwZSA9IFpvZExhenkuY3JlYXRlO1xuY29uc3QgbGl0ZXJhbFR5cGUgPSBab2RMaXRlcmFsLmNyZWF0ZTtcbmNvbnN0IGVudW1UeXBlID0gWm9kRW51bS5jcmVhdGU7XG5jb25zdCBuYXRpdmVFbnVtVHlwZSA9IFpvZE5hdGl2ZUVudW0uY3JlYXRlO1xuY29uc3QgcHJvbWlzZVR5cGUgPSBab2RQcm9taXNlLmNyZWF0ZTtcbmNvbnN0IGVmZmVjdHNUeXBlID0gWm9kRWZmZWN0cy5jcmVhdGU7XG5jb25zdCBvcHRpb25hbFR5cGUgPSBab2RPcHRpb25hbC5jcmVhdGU7XG5jb25zdCBudWxsYWJsZVR5cGUgPSBab2ROdWxsYWJsZS5jcmVhdGU7XG5jb25zdCBwcmVwcm9jZXNzVHlwZSA9IFpvZEVmZmVjdHMuY3JlYXRlV2l0aFByZXByb2Nlc3M7XG5jb25zdCBwaXBlbGluZVR5cGUgPSBab2RQaXBlbGluZS5jcmVhdGU7XG5jb25zdCBvc3RyaW5nID0gKCkgPT4gc3RyaW5nVHlwZSgpLm9wdGlvbmFsKCk7XG5jb25zdCBvbnVtYmVyID0gKCkgPT4gbnVtYmVyVHlwZSgpLm9wdGlvbmFsKCk7XG5jb25zdCBvYm9vbGVhbiA9ICgpID0+IGJvb2xlYW5UeXBlKCkub3B0aW9uYWwoKTtcbmV4cG9ydCBjb25zdCBjb2VyY2UgPSB7XG4gICAgc3RyaW5nOiAoKGFyZykgPT4gWm9kU3RyaW5nLmNyZWF0ZSh7IC4uLmFyZywgY29lcmNlOiB0cnVlIH0pKSxcbiAgICBudW1iZXI6ICgoYXJnKSA9PiBab2ROdW1iZXIuY3JlYXRlKHsgLi4uYXJnLCBjb2VyY2U6IHRydWUgfSkpLFxuICAgIGJvb2xlYW46ICgoYXJnKSA9PiBab2RCb29sZWFuLmNyZWF0ZSh7XG4gICAgICAgIC4uLmFyZyxcbiAgICAgICAgY29lcmNlOiB0cnVlLFxuICAgIH0pKSxcbiAgICBiaWdpbnQ6ICgoYXJnKSA9PiBab2RCaWdJbnQuY3JlYXRlKHsgLi4uYXJnLCBjb2VyY2U6IHRydWUgfSkpLFxuICAgIGRhdGU6ICgoYXJnKSA9PiBab2REYXRlLmNyZWF0ZSh7IC4uLmFyZywgY29lcmNlOiB0cnVlIH0pKSxcbn07XG5leHBvcnQgeyBhbnlUeXBlIGFzIGFueSwgYXJyYXlUeXBlIGFzIGFycmF5LCBiaWdJbnRUeXBlIGFzIGJpZ2ludCwgYm9vbGVhblR5cGUgYXMgYm9vbGVhbiwgZGF0ZVR5cGUgYXMgZGF0ZSwgZGlzY3JpbWluYXRlZFVuaW9uVHlwZSBhcyBkaXNjcmltaW5hdGVkVW5pb24sIGVmZmVjdHNUeXBlIGFzIGVmZmVjdCwgZW51bVR5cGUgYXMgZW51bSwgZnVuY3Rpb25UeXBlIGFzIGZ1bmN0aW9uLCBpbnN0YW5jZU9mVHlwZSBhcyBpbnN0YW5jZW9mLCBpbnRlcnNlY3Rpb25UeXBlIGFzIGludGVyc2VjdGlvbiwgbGF6eVR5cGUgYXMgbGF6eSwgbGl0ZXJhbFR5cGUgYXMgbGl0ZXJhbCwgbWFwVHlwZSBhcyBtYXAsIG5hblR5cGUgYXMgbmFuLCBuYXRpdmVFbnVtVHlwZSBhcyBuYXRpdmVFbnVtLCBuZXZlclR5cGUgYXMgbmV2ZXIsIG51bGxUeXBlIGFzIG51bGwsIG51bGxhYmxlVHlwZSBhcyBudWxsYWJsZSwgbnVtYmVyVHlwZSBhcyBudW1iZXIsIG9iamVjdFR5cGUgYXMgb2JqZWN0LCBvYm9vbGVhbiwgb251bWJlciwgb3B0aW9uYWxUeXBlIGFzIG9wdGlvbmFsLCBvc3RyaW5nLCBwaXBlbGluZVR5cGUgYXMgcGlwZWxpbmUsIHByZXByb2Nlc3NUeXBlIGFzIHByZXByb2Nlc3MsIHByb21pc2VUeXBlIGFzIHByb21pc2UsIHJlY29yZFR5cGUgYXMgcmVjb3JkLCBzZXRUeXBlIGFzIHNldCwgc3RyaWN0T2JqZWN0VHlwZSBhcyBzdHJpY3RPYmplY3QsIHN0cmluZ1R5cGUgYXMgc3RyaW5nLCBzeW1ib2xUeXBlIGFzIHN5bWJvbCwgZWZmZWN0c1R5cGUgYXMgdHJhbnNmb3JtZXIsIHR1cGxlVHlwZSBhcyB0dXBsZSwgdW5kZWZpbmVkVHlwZSBhcyB1bmRlZmluZWQsIHVuaW9uVHlwZSBhcyB1bmlvbiwgdW5rbm93blR5cGUgYXMgdW5rbm93biwgdm9pZFR5cGUgYXMgdm9pZCwgfTtcbmV4cG9ydCBjb25zdCBORVZFUiA9IElOVkFMSUQ7XG4iLCJpbXBvcnQgeyBpbml0VFJQQyB9IGZyb20gJ0B0cnBjL3NlcnZlcic7XG5pbXBvcnQgeyB6IH0gZnJvbSAnem9kJztcbmltcG9ydCB0eXBlIHsgU25hcHNob3RQYXlsb2FkLCBXU1Jlc3BvbnNlLCBSZWNvcmRlZEFjdGlvbiwgVGFiSW5mbywgT3duZWRUYWJzRW50cnkgfSBmcm9tICcuL3R5cGVzJztcblxuY29uc3QgdCA9IGluaXRUUlBDLmNyZWF0ZSh7XG4gIGlzU2VydmVyOiBmYWxzZSxcbiAgYWxsb3dPdXRzaWRlT2ZTZXJ2ZXI6IHRydWUsXG59KTtcblxuZXhwb3J0IGludGVyZmFjZSBCYWNrZ3JvdW5kU3RhdGUge1xuICB3c1VybDogc3RyaW5nO1xuICB3c0Nvbm5lY3RlZDogYm9vbGVhbjtcbiAgbGFzdEVycm9yOiBzdHJpbmcgfCBudWxsO1xuICBsYXN0Q29tbWFuZDogdW5rbm93biB8IG51bGw7XG4gIGxhc3RTbmFwc2hvdDogdW5rbm93biB8IG51bGw7XG4gIHRhcmdldFRhYklkOiBudW1iZXIgfCBudWxsO1xuICByZWNvcmRpbmc6IGJvb2xlYW47XG4gIHJlY29yZGluZ0NvdW50OiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQmFja2dyb3VuZEhhbmRsZXJzIHtcbiAgZ2V0U3RhdGU6ICgpID0+IEJhY2tncm91bmRTdGF0ZTtcbiAgY29ubmVjdDogKHVybDogc3RyaW5nKSA9PiB2b2lkO1xuICBkaXNjb25uZWN0OiAoKSA9PiB2b2lkO1xuICBzZW5kQ2xpY2s6IChzZWxlY3Rvcjogc3RyaW5nKSA9PiBQcm9taXNlPFdTUmVzcG9uc2U+O1xuICBzZW5kU25hcHNob3Q6IChwYXlsb2FkOiBTbmFwc2hvdFBheWxvYWQpID0+IFByb21pc2U8V1NSZXNwb25zZT47XG4gIGxpc3RUYWJzOiAoKSA9PiBQcm9taXNlPFRhYkluZm9bXT47XG4gIGxpc3RPd25lZFRhYnM6ICgpID0+IFByb21pc2U8T3duZWRUYWJzRW50cnlbXT47XG4gIHNldFRhcmdldFRhYjogKHRhYklkOiBudW1iZXIgfCBudWxsKSA9PiB2b2lkO1xuICBzdGFydFJlY29yZGluZzogKCkgPT4gUHJvbWlzZTx2b2lkPjtcbiAgc3RvcFJlY29yZGluZzogKCkgPT4gUHJvbWlzZTx2b2lkPjtcbiAgY2xlYXJSZWNvcmRpbmc6ICgpID0+IHZvaWQ7XG4gIGdldFJlY29yZGluZzogKCkgPT4gUmVjb3JkZWRBY3Rpb25bXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUJhY2tncm91bmRSb3V0ZXIoaGFuZGxlcnM6IEJhY2tncm91bmRIYW5kbGVycykge1xuICByZXR1cm4gdC5yb3V0ZXIoe1xuICAgIGdldFN0YXRlOiB0LnByb2NlZHVyZS5xdWVyeSgoKSA9PiBoYW5kbGVycy5nZXRTdGF0ZSgpKSxcbiAgICBsaXN0VGFiczogdC5wcm9jZWR1cmUucXVlcnkoKCkgPT4gaGFuZGxlcnMubGlzdFRhYnMoKSksXG4gICAgbGlzdE93bmVkVGFiczogdC5wcm9jZWR1cmUucXVlcnkoKCkgPT4gaGFuZGxlcnMubGlzdE93bmVkVGFicygpKSxcbiAgICBzdGFydFJlY29yZGluZzogdC5wcm9jZWR1cmUubXV0YXRpb24oYXN5bmMgKCkgPT4ge1xuICAgICAgYXdhaXQgaGFuZGxlcnMuc3RhcnRSZWNvcmRpbmcoKTtcbiAgICAgIHJldHVybiB7IG9rOiB0cnVlIH07XG4gICAgfSksXG4gICAgc3RvcFJlY29yZGluZzogdC5wcm9jZWR1cmUubXV0YXRpb24oYXN5bmMgKCkgPT4ge1xuICAgICAgYXdhaXQgaGFuZGxlcnMuc3RvcFJlY29yZGluZygpO1xuICAgICAgcmV0dXJuIHsgb2s6IHRydWUgfTtcbiAgICB9KSxcbiAgICBjbGVhclJlY29yZGluZzogdC5wcm9jZWR1cmUubXV0YXRpb24oKCkgPT4ge1xuICAgICAgaGFuZGxlcnMuY2xlYXJSZWNvcmRpbmcoKTtcbiAgICAgIHJldHVybiB7IG9rOiB0cnVlIH07XG4gICAgfSksXG4gICAgZ2V0UmVjb3JkaW5nOiB0LnByb2NlZHVyZS5xdWVyeSgoKSA9PiBoYW5kbGVycy5nZXRSZWNvcmRpbmcoKSksXG4gICAgc2V0VGFyZ2V0VGFiOiB0LnByb2NlZHVyZVxuICAgICAgLmlucHV0KHoub2JqZWN0KHsgdGFiSWQ6IHoubnVtYmVyKCkuaW50KCkubnVsbGFibGUoKSB9KSlcbiAgICAgIC5tdXRhdGlvbigoeyBpbnB1dCB9KSA9PiB7XG4gICAgICAgIGhhbmRsZXJzLnNldFRhcmdldFRhYihpbnB1dC50YWJJZCk7XG4gICAgICAgIHJldHVybiB7IG9rOiB0cnVlIH07XG4gICAgICB9KSxcbiAgICBjb25uZWN0OiB0LnByb2NlZHVyZS5pbnB1dCh6Lm9iamVjdCh7IHVybDogei5zdHJpbmcoKS5taW4oMSkgfSkpLm11dGF0aW9uKCh7IGlucHV0IH0pID0+IHtcbiAgICAgIGhhbmRsZXJzLmNvbm5lY3QoaW5wdXQudXJsKTtcbiAgICAgIHJldHVybiB7IG9rOiB0cnVlIH07XG4gICAgfSksXG4gICAgZGlzY29ubmVjdDogdC5wcm9jZWR1cmUubXV0YXRpb24oKCkgPT4ge1xuICAgICAgaGFuZGxlcnMuZGlzY29ubmVjdCgpO1xuICAgICAgcmV0dXJuIHsgb2s6IHRydWUgfTtcbiAgICB9KSxcbiAgICBzZW5kQ2xpY2s6IHQucHJvY2VkdXJlLmlucHV0KHoub2JqZWN0KHsgc2VsZWN0b3I6IHouc3RyaW5nKCkubWluKDEpIH0pKS5tdXRhdGlvbigoeyBpbnB1dCB9KSA9PiB7XG4gICAgICByZXR1cm4gaGFuZGxlcnMuc2VuZENsaWNrKGlucHV0LnNlbGVjdG9yKTtcbiAgICB9KSxcbiAgICBzZW5kU25hcHNob3Q6IHQucHJvY2VkdXJlXG4gICAgICAuaW5wdXQoei5vYmplY3Qoe1xuICAgICAgICBpbmNsdWRlSGlkZGVuOiB6LmJvb2xlYW4oKS5vcHRpb25hbCgpLFxuICAgICAgICBtYXhFbGVtZW50czogei5udW1iZXIoKS5vcHRpb25hbCgpLFxuICAgICAgICBtYXhUZXh0OiB6Lm51bWJlcigpLm9wdGlvbmFsKCksXG4gICAgICB9KSlcbiAgICAgIC5tdXRhdGlvbigoeyBpbnB1dCB9KSA9PiBoYW5kbGVycy5zZW5kU25hcHNob3QoaW5wdXQpKSxcbiAgfSk7XG59XG5cbmV4cG9ydCB0eXBlIEJhY2tncm91bmRSb3V0ZXIgPSBSZXR1cm5UeXBlPHR5cGVvZiBjcmVhdGVCYWNrZ3JvdW5kUm91dGVyPjtcbiIsImltcG9ydCB7IGNyZWF0ZUNocm9tZUhhbmRsZXIgfSBmcm9tICd0cnBjLWJyb3dzZXIvYWRhcHRlcic7XG5pbXBvcnQgeyBjaHJvbWVMaW5rIH0gZnJvbSAndHJwYy1icm93c2VyL2xpbmsnO1xuaW1wb3J0IHsgY3JlYXRlVFJQQ1Byb3h5Q2xpZW50IH0gZnJvbSAnQHRycGMvY2xpZW50JztcbmltcG9ydCB7IGJyb3dzZXIsIGRlZmluZUJhY2tncm91bmQgfSBmcm9tICcjaW1wb3J0cyc7XG5cbmltcG9ydCB7IGNyZWF0ZUJhY2tncm91bmRSb3V0ZXIgfSBmcm9tICcuL3NoYXJlZC9iYWNrZ3JvdW5kUm91dGVyJztcbmltcG9ydCB0eXBlIHsgQ29udGVudFJvdXRlciB9IGZyb20gJy4vc2hhcmVkL2NvbnRlbnRSb3V0ZXInO1xuaW1wb3J0IHR5cGUge1xuICBXU0NvbW1hbmQsXG4gIFdTUmVzcG9uc2UsXG4gIENsaWNrUGF5bG9hZCxcbiAgU25hcHNob3RQYXlsb2FkLFxuICBTbmFwc2hvdERhdGEsXG4gIFNjcm9sbFBheWxvYWQsXG4gIFdhaXRGb3JTZWxlY3RvclBheWxvYWQsXG4gIE5hdmlnYXRlUGF5bG9hZCxcbiAgVHlwZVBheWxvYWQsXG4gIEhvdmVyUGF5bG9hZCxcbiAgRmluZFBheWxvYWQsXG4gIEZpbmRSZXNwb25zZSxcbiAgRW50ZXJQYXlsb2FkLFxuICBTZWxlY3RQYXlsb2FkLFxuICBTY3JlZW5zaG90UGF5bG9hZCxcbiAgU2NyZWVuc2hvdFJlc3BvbnNlLFxuICBTY3JlZW5zaG90UHJlcFJlc3BvbnNlLFxuICBSZWNvcmRlZEFjdGlvbixcbiAgUmVjb3JkaW5nU3RhdGVSZXNwb25zZSxcbiAgVGFiSW5mbyxcbiAgT3duZWRUYWJzRW50cnksXG4gIE9wZW5UYWJQYXlsb2FkLFxuICBDbG9zZVRhYlBheWxvYWQsXG4gIENsYWltVGFiUGF5bG9hZCxcbiAgUmVsZWFzZVRhYlBheWxvYWQsXG4gIFNldFRhYlNoYXJpbmdQYXlsb2FkLFxufSBmcm9tICcuL3NoYXJlZC90eXBlcyc7XG5cbmxldCB3czogV2ViU29ja2V0IHwgbnVsbCA9IG51bGw7XG5sZXQgd3NVcmwgPSAnd3M6Ly9sb2NhbGhvc3Q6OTA5OS93cyc7XG5sZXQgd3NDb25uZWN0ZWQgPSBmYWxzZTtcbmxldCBsYXN0RXJyb3I6IHN0cmluZyB8IG51bGwgPSBudWxsO1xubGV0IGxhc3RDb21tYW5kOiBXU0NvbW1hbmQgfCBudWxsID0gbnVsbDtcbmxldCBsYXN0U25hcHNob3Q6IFNuYXBzaG90RGF0YSB8IG51bGwgPSBudWxsO1xubGV0IHRhcmdldFRhYklkOiBudW1iZXIgfCBudWxsID0gbnVsbDtcbmxldCByZWNvcmRpbmcgPSBmYWxzZTtcbmxldCByZWNvcmRlZEFjdGlvbnM6IFJlY29yZGVkQWN0aW9uW10gPSBbXTtcbmNvbnN0IHRhYk93bmVycyA9IG5ldyBNYXA8bnVtYmVyLCBUYWJPd25lcnNoaXA+KCk7XG5jb25zdCBzZXNzaW9uVGFicyA9IG5ldyBNYXA8c3RyaW5nLCBTZXQ8bnVtYmVyPj4oKTtcblxuY29uc3QgY2hyb21lQXBpID0gKGdsb2JhbFRoaXMuY2hyb21lID8/IChicm93c2VyIGFzIHVua25vd24gYXMgdHlwZW9mIGNocm9tZSkpO1xuXG5jb25zdCBoYW5kbGVSdW50aW1lTWVzc2FnZSA9IChtZXNzYWdlOiB1bmtub3duKSA9PiB7XG4gIGlmICgobWVzc2FnZSBhcyBhbnkpPy50eXBlID09PSAncmVjb3JkX2V2ZW50JyAmJiByZWNvcmRpbmcpIHtcbiAgICBjb25zdCBwYXlsb2FkID0gKG1lc3NhZ2UgYXMgYW55KS5wYXlsb2FkIGFzIFJlY29yZGVkQWN0aW9uO1xuICAgIGlmIChwYXlsb2FkPy50eXBlICYmIHBheWxvYWQ/LnRpbWVzdGFtcCkge1xuICAgICAgcmVjb3JkZWRBY3Rpb25zLnB1c2gocGF5bG9hZCk7XG4gICAgfVxuICB9XG59O1xuXG5hc3luYyBmdW5jdGlvbiBnZXRBY3RpdmVUYWJJZChwcmVmZXJyZWRUYWJJZD86IG51bWJlciB8IG51bGwpOiBQcm9taXNlPG51bWJlciB8IG51bGw+IHtcbiAgaWYgKHByZWZlcnJlZFRhYklkICE9IG51bGwpIHJldHVybiBwcmVmZXJyZWRUYWJJZDtcbiAgaWYgKHRhcmdldFRhYklkICE9IG51bGwpIHJldHVybiB0YXJnZXRUYWJJZDtcbiAgY29uc3QgdGFicyA9IGF3YWl0IGNocm9tZUFwaS50YWJzLnF1ZXJ5KHsgYWN0aXZlOiB0cnVlLCBsYXN0Rm9jdXNlZFdpbmRvdzogdHJ1ZSB9KTtcbiAgY29uc3QgdGFiID0gdGFicy5maW5kKHQgPT4gdC5pZCAhPSBudWxsICYmICF0LnVybD8uc3RhcnRzV2l0aCgnY2hyb21lOi8vJykgJiYgIXQudXJsPy5zdGFydHNXaXRoKCdjaHJvbWUtZXh0ZW5zaW9uOi8vJykpO1xuICByZXR1cm4gdGFiPy5pZCA/PyBudWxsO1xufVxuXG5hc3luYyBmdW5jdGlvbiBsaXN0VGFicygpIHtcbiAgY29uc3QgdGFicyA9IGF3YWl0IGNocm9tZUFwaS50YWJzLnF1ZXJ5KHt9KTtcbiAgcmV0dXJuIHRhYnNcbiAgICAuZmlsdGVyKHQgPT4gdC5pZCAhPSBudWxsICYmIHQudXJsICYmICF0LnVybC5zdGFydHNXaXRoKCdjaHJvbWU6Ly8nKSAmJiAhdC51cmwuc3RhcnRzV2l0aCgnY2hyb21lLWV4dGVuc2lvbjovLycpKVxuICAgIC5tYXAodCA9PiAoeyBpZDogdC5pZCBhcyBudW1iZXIsIHRpdGxlOiB0LnRpdGxlIHx8ICdVbnRpdGxlZCcsIHVybDogdC51cmwgfHwgJycgfSkpO1xufVxuXG5hc3luYyBmdW5jdGlvbiBsaXN0T3duZWRUYWJzKCk6IFByb21pc2U8T3duZWRUYWJzRW50cnlbXT4ge1xuICBjb25zdCB0YWJzID0gYXdhaXQgbGlzdFRhYnMoKTtcbiAgY29uc3QgdGFiTWFwID0gbmV3IE1hcDxudW1iZXIsIFRhYkluZm8+KCk7XG4gIGZvciAoY29uc3QgdGFiIG9mIHRhYnMpIHRhYk1hcC5zZXQodGFiLmlkLCB0YWIpO1xuICBjb25zdCBlbnRyaWVzOiBPd25lZFRhYnNFbnRyeVtdID0gW107XG4gIGZvciAoY29uc3QgW3Nlc3Npb25JZCwgc2V0XSBvZiBzZXNzaW9uVGFicykge1xuICAgIGNvbnN0IG93bmVkOiBUYWJJbmZvW10gPSBbXTtcbiAgICBmb3IgKGNvbnN0IHRhYklkIG9mIHNldCkge1xuICAgICAgY29uc3QgaW5mbyA9IHRhYk1hcC5nZXQodGFiSWQpO1xuICAgICAgaWYgKGluZm8gJiYgYWxsb3dUYWJBY2Nlc3ModGFiSWQsIHNlc3Npb25JZCkpIHtcbiAgICAgICAgb3duZWQucHVzaChpbmZvKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZW50cmllcy5wdXNoKHsgc2Vzc2lvbklkLCB0YWJzOiBvd25lZCB9KTtcbiAgfVxuICByZXR1cm4gZW50cmllcztcbn1cblxudHlwZSBUYWJPd25lcnNoaXAgPSB7XG4gIG1vZGU6ICdleGNsdXNpdmUnIHwgJ3NoYXJlZCc7XG4gIG93bmVyczogU2V0PHN0cmluZz47XG4gIGFsbG93U2hhcmVkOiBib29sZWFuO1xufTtcblxuZnVuY3Rpb24gZ2V0T3duZXIodGFiSWQ6IG51bWJlcik6IFRhYk93bmVyc2hpcCB8IHVuZGVmaW5lZCB7XG4gIHJldHVybiB0YWJPd25lcnMuZ2V0KHRhYklkKTtcbn1cblxuZnVuY3Rpb24gZW5zdXJlT3duZXIodGFiSWQ6IG51bWJlciwgc2Vzc2lvbklkOiBzdHJpbmcsIG1vZGU6ICdleGNsdXNpdmUnIHwgJ3NoYXJlZCcpIHtcbiAgY29uc3Qgb3duZXJzaGlwID0gdGFiT3duZXJzLmdldCh0YWJJZCk7XG4gIGlmICghb3duZXJzaGlwKSB7XG4gICAgdGFiT3duZXJzLnNldCh0YWJJZCwgeyBtb2RlLCBvd25lcnM6IG5ldyBTZXQoW3Nlc3Npb25JZF0pLCBhbGxvd1NoYXJlZDogZmFsc2UgfSk7XG4gICAgYWRkU2Vzc2lvblRhYihzZXNzaW9uSWQsIHRhYklkKTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKG1vZGUgPT09ICdzaGFyZWQnKSB7XG4gICAgb3duZXJzaGlwLm1vZGUgPSAnc2hhcmVkJztcbiAgICBvd25lcnNoaXAub3duZXJzLmFkZChzZXNzaW9uSWQpO1xuICB9IGVsc2Uge1xuICAgIG93bmVyc2hpcC5tb2RlID0gJ2V4Y2x1c2l2ZSc7XG4gICAgb3duZXJzaGlwLm93bmVycyA9IG5ldyBTZXQoW3Nlc3Npb25JZF0pO1xuICB9XG4gIGFkZFNlc3Npb25UYWIoc2Vzc2lvbklkLCB0YWJJZCk7XG59XG5cbmZ1bmN0aW9uIHJlbGVhc2VPd25lcih0YWJJZDogbnVtYmVyLCBzZXNzaW9uSWQ6IHN0cmluZykge1xuICBjb25zdCBvd25lcnNoaXAgPSB0YWJPd25lcnMuZ2V0KHRhYklkKTtcbiAgaWYgKCFvd25lcnNoaXApIHJldHVybjtcbiAgb3duZXJzaGlwLm93bmVycy5kZWxldGUoc2Vzc2lvbklkKTtcbiAgcmVtb3ZlU2Vzc2lvblRhYihzZXNzaW9uSWQsIHRhYklkKTtcbiAgaWYgKG93bmVyc2hpcC5vd25lcnMuc2l6ZSA9PT0gMCkge1xuICAgIHRhYk93bmVycy5kZWxldGUodGFiSWQpO1xuICB9IGVsc2UgaWYgKG93bmVyc2hpcC5tb2RlID09PSAnZXhjbHVzaXZlJykge1xuICAgIGNvbnN0IG5leHQgPSBvd25lcnNoaXAub3duZXJzLnZhbHVlcygpLm5leHQoKS52YWx1ZTtcbiAgICBvd25lcnNoaXAub3duZXJzID0gbmV3IFNldChbbmV4dF0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFsbG93VGFiQWNjZXNzKHRhYklkOiBudW1iZXIsIHNlc3Npb25JZDogc3RyaW5nKTogYm9vbGVhbiB7XG4gIGNvbnN0IG93bmVyc2hpcCA9IHRhYk93bmVycy5nZXQodGFiSWQpO1xuICBpZiAoIW93bmVyc2hpcCkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3duZXJzaGlwLm93bmVycy5oYXMoc2Vzc2lvbklkKTtcbn1cblxuZnVuY3Rpb24gYWRkU2Vzc2lvblRhYihzZXNzaW9uSWQ6IHN0cmluZywgdGFiSWQ6IG51bWJlcikge1xuICBjb25zdCBzZXQgPSBzZXNzaW9uVGFicy5nZXQoc2Vzc2lvbklkKSA/PyBuZXcgU2V0PG51bWJlcj4oKTtcbiAgc2V0LmFkZCh0YWJJZCk7XG4gIHNlc3Npb25UYWJzLnNldChzZXNzaW9uSWQsIHNldCk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVNlc3Npb25UYWIoc2Vzc2lvbklkOiBzdHJpbmcsIHRhYklkOiBudW1iZXIpIHtcbiAgY29uc3Qgc2V0ID0gc2Vzc2lvblRhYnMuZ2V0KHNlc3Npb25JZCk7XG4gIGlmICghc2V0KSByZXR1cm47XG4gIHNldC5kZWxldGUodGFiSWQpO1xuICBpZiAoc2V0LnNpemUgPT09IDApIHtcbiAgICBzZXNzaW9uVGFicy5kZWxldGUoc2Vzc2lvbklkKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZWxlYXNlU2Vzc2lvbihzZXNzaW9uSWQ6IHN0cmluZykge1xuICBjb25zdCBzZXQgPSBzZXNzaW9uVGFicy5nZXQoc2Vzc2lvbklkKTtcbiAgaWYgKCFzZXQpIHJldHVybjtcbiAgZm9yIChjb25zdCB0YWJJZCBvZiBzZXQpIHtcbiAgICByZWxlYXNlT3duZXIodGFiSWQsIHNlc3Npb25JZCk7XG4gIH1cbiAgc2Vzc2lvblRhYnMuZGVsZXRlKHNlc3Npb25JZCk7XG59XG5cbmZ1bmN0aW9uIHJlcXVpcmVTZXNzaW9uKGNtZDogV1NDb21tYW5kKTogc3RyaW5nIHwgbnVsbCB7XG4gIGNvbnN0IHNlc3Npb25JZCA9IChjbWQgYXMgYW55KS5zZXNzaW9uSWQgYXMgc3RyaW5nIHwgdW5kZWZpbmVkO1xuICBpZiAoIXNlc3Npb25JZCB8fCAhc2Vzc2lvbklkLnRyaW0oKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBzZXNzaW9uSWQ7XG59XG5cbmZ1bmN0aW9uIG1ha2VDb250ZW50Q2xpZW50KHRhYklkOiBudW1iZXIpIHtcbiAgY29uc3QgcG9ydCA9IGNocm9tZUFwaS50YWJzLmNvbm5lY3QodGFiSWQsIHsgbmFtZTogJ21jcC1jb250ZW50JyB9KTtcbiAgY29uc3QgY2xpZW50ID0gY3JlYXRlVFJQQ1Byb3h5Q2xpZW50PENvbnRlbnRSb3V0ZXI+KHtcbiAgICBsaW5rczogW2Nocm9tZUxpbmsoeyBwb3J0IH0pXSxcbiAgfSk7XG4gIHJldHVybiB7IGNsaWVudCwgcG9ydCB9O1xufVxuXG5hc3luYyBmdW5jdGlvbiBoYW5kbGVDbGljayhwYXlsb2FkOiBDbGlja1BheWxvYWQsIHRhYklkT3ZlcnJpZGU/OiBudW1iZXIgfCBudWxsLCBzZXNzaW9uSWQ/OiBzdHJpbmcgfCBudWxsKTogUHJvbWlzZTxXU1Jlc3BvbnNlPiB7XG4gIGNvbnN0IHRhYklkID0gYXdhaXQgZ2V0QWN0aXZlVGFiSWQodGFiSWRPdmVycmlkZSk7XG4gIGlmICghdGFiSWQpIHtcbiAgICByZXR1cm4geyBpZDogJycsIG9rOiBmYWxzZSwgZXJyb3I6ICdObyBhY3RpdmUgdGFiIGF2YWlsYWJsZScsIGVycm9yQ29kZTogJ05PX0FDVElWRV9UQUInIH07XG4gIH1cbiAgaWYgKCFzZXNzaW9uSWQgfHwgIWFsbG93VGFiQWNjZXNzKHRhYklkLCBzZXNzaW9uSWQpKSB7XG4gICAgcmV0dXJuIHsgaWQ6ICcnLCBvazogZmFsc2UsIGVycm9yOiAnVGFiIG5vdCBvd25lZCBieSBzZXNzaW9uJywgZXJyb3JDb2RlOiAnVEFCX05PVF9PV05FRCcgfTtcbiAgfVxuICBjb25zdCB7IGNsaWVudCwgcG9ydCB9ID0gbWFrZUNvbnRlbnRDbGllbnQodGFiSWQpO1xuICB0cnkge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGNsaWVudC5jbGljay5tdXRhdGUoeyBzZWxlY3RvcjogcGF5bG9hZC5zZWxlY3RvciB9KTtcbiAgICByZXR1cm4geyBpZDogJycsIG9rOiByZXMub2sgIT09IGZhbHNlLCBlcnJvcjogcmVzLmVycm9yLCBlcnJvckNvZGU6IHJlcy5lcnJvckNvZGUsIGRhdGE6IHJlcy5kYXRhIH07XG4gIH0gZmluYWxseSB7XG4gICAgcG9ydC5kaXNjb25uZWN0KCk7XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gaGFuZGxlU25hcHNob3QocGF5bG9hZDogU25hcHNob3RQYXlsb2FkLCB0YWJJZE92ZXJyaWRlPzogbnVtYmVyIHwgbnVsbCwgc2Vzc2lvbklkPzogc3RyaW5nIHwgbnVsbCk6IFByb21pc2U8V1NSZXNwb25zZT4ge1xuICBjb25zdCB0YWJJZCA9IGF3YWl0IGdldEFjdGl2ZVRhYklkKHRhYklkT3ZlcnJpZGUpO1xuICBpZiAoIXRhYklkKSB7XG4gICAgcmV0dXJuIHsgaWQ6ICcnLCBvazogZmFsc2UsIGVycm9yOiAnTm8gYWN0aXZlIHRhYiBhdmFpbGFibGUnLCBlcnJvckNvZGU6ICdOT19BQ1RJVkVfVEFCJyB9O1xuICB9XG4gIGlmICghc2Vzc2lvbklkIHx8ICFhbGxvd1RhYkFjY2Vzcyh0YWJJZCwgc2Vzc2lvbklkKSkge1xuICAgIHJldHVybiB7IGlkOiAnJywgb2s6IGZhbHNlLCBlcnJvcjogJ1RhYiBub3Qgb3duZWQgYnkgc2Vzc2lvbicsIGVycm9yQ29kZTogJ1RBQl9OT1RfT1dORUQnIH07XG4gIH1cbiAgY29uc3QgeyBjbGllbnQsIHBvcnQgfSA9IG1ha2VDb250ZW50Q2xpZW50KHRhYklkKTtcbiAgdHJ5IHtcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgY2xpZW50LnNuYXBzaG90LnF1ZXJ5KHtcbiAgICAgIGluY2x1ZGVIaWRkZW46IHBheWxvYWQuaW5jbHVkZUhpZGRlbixcbiAgICAgIG1heEVsZW1lbnRzOiBwYXlsb2FkLm1heEVsZW1lbnRzLFxuICAgICAgbWF4VGV4dDogcGF5bG9hZC5tYXhUZXh0LFxuICAgICAgaW5jbHVkZUhUTUw6IHBheWxvYWQuaW5jbHVkZUhUTUwsXG4gICAgICBtYXhIVE1MOiBwYXlsb2FkLm1heEhUTUwsXG4gICAgICBtYXhIVE1MVG9rZW5zOiBwYXlsb2FkLm1heEhUTUxUb2tlbnMsXG4gICAgfSk7XG4gICAgbGFzdFNuYXBzaG90ID0gZGF0YTtcbiAgICByZXR1cm4geyBpZDogJycsIG9rOiB0cnVlLCBkYXRhIH07XG4gIH0gZmluYWxseSB7XG4gICAgcG9ydC5kaXNjb25uZWN0KCk7XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gaGFuZGxlU2Nyb2xsKHBheWxvYWQ6IFNjcm9sbFBheWxvYWQsIHRhYklkT3ZlcnJpZGU/OiBudW1iZXIgfCBudWxsLCBzZXNzaW9uSWQ/OiBzdHJpbmcgfCBudWxsKTogUHJvbWlzZTxXU1Jlc3BvbnNlPiB7XG4gIGNvbnN0IHRhYklkID0gYXdhaXQgZ2V0QWN0aXZlVGFiSWQodGFiSWRPdmVycmlkZSk7XG4gIGlmICghdGFiSWQpIHtcbiAgICByZXR1cm4geyBpZDogJycsIG9rOiBmYWxzZSwgZXJyb3I6ICdObyBhY3RpdmUgdGFiIGF2YWlsYWJsZScsIGVycm9yQ29kZTogJ05PX0FDVElWRV9UQUInIH07XG4gIH1cbiAgaWYgKCFzZXNzaW9uSWQgfHwgIWFsbG93VGFiQWNjZXNzKHRhYklkLCBzZXNzaW9uSWQpKSB7XG4gICAgcmV0dXJuIHsgaWQ6ICcnLCBvazogZmFsc2UsIGVycm9yOiAnVGFiIG5vdCBvd25lZCBieSBzZXNzaW9uJywgZXJyb3JDb2RlOiAnVEFCX05PVF9PV05FRCcgfTtcbiAgfVxuICBjb25zdCB7IGNsaWVudCwgcG9ydCB9ID0gbWFrZUNvbnRlbnRDbGllbnQodGFiSWQpO1xuICB0cnkge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGNsaWVudC5zY3JvbGwubXV0YXRlKHtcbiAgICAgIGRlbHRhWDogcGF5bG9hZC5kZWx0YVgsXG4gICAgICBkZWx0YVk6IHBheWxvYWQuZGVsdGFZLFxuICAgICAgc2VsZWN0b3I6IHBheWxvYWQuc2VsZWN0b3IsXG4gICAgICBiZWhhdmlvcjogcGF5bG9hZC5iZWhhdmlvcixcbiAgICAgIGJsb2NrOiBwYXlsb2FkLmJsb2NrLFxuICAgIH0pO1xuICAgIHJldHVybiB7IGlkOiAnJywgb2s6IHJlcy5vayAhPT0gZmFsc2UsIGVycm9yOiByZXMuZXJyb3IsIGVycm9yQ29kZTogcmVzLmVycm9yQ29kZSwgZGF0YTogcmVzLmRhdGEgfTtcbiAgfSBmaW5hbGx5IHtcbiAgICBwb3J0LmRpc2Nvbm5lY3QoKTtcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBoYW5kbGVXYWl0Rm9yU2VsZWN0b3IocGF5bG9hZDogV2FpdEZvclNlbGVjdG9yUGF5bG9hZCwgdGFiSWRPdmVycmlkZT86IG51bWJlciB8IG51bGwsIHNlc3Npb25JZD86IHN0cmluZyB8IG51bGwpOiBQcm9taXNlPFdTUmVzcG9uc2U+IHtcbiAgY29uc3QgdGFiSWQgPSBhd2FpdCBnZXRBY3RpdmVUYWJJZCh0YWJJZE92ZXJyaWRlKTtcbiAgaWYgKCF0YWJJZCkge1xuICAgIHJldHVybiB7IGlkOiAnJywgb2s6IGZhbHNlLCBlcnJvcjogJ05vIGFjdGl2ZSB0YWIgYXZhaWxhYmxlJywgZXJyb3JDb2RlOiAnTk9fQUNUSVZFX1RBQicgfTtcbiAgfVxuICBpZiAoIXNlc3Npb25JZCB8fCAhYWxsb3dUYWJBY2Nlc3ModGFiSWQsIHNlc3Npb25JZCkpIHtcbiAgICByZXR1cm4geyBpZDogJycsIG9rOiBmYWxzZSwgZXJyb3I6ICdUYWIgbm90IG93bmVkIGJ5IHNlc3Npb24nLCBlcnJvckNvZGU6ICdUQUJfTk9UX09XTkVEJyB9O1xuICB9XG4gIGNvbnN0IHsgY2xpZW50LCBwb3J0IH0gPSBtYWtlQ29udGVudENsaWVudCh0YWJJZCk7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgY2xpZW50LndhaXRGb3JTZWxlY3Rvci5tdXRhdGUoe1xuICAgICAgc2VsZWN0b3I6IHBheWxvYWQuc2VsZWN0b3IsXG4gICAgICB0aW1lb3V0TXM6IHBheWxvYWQudGltZW91dE1zLFxuICAgIH0pO1xuICAgIHJldHVybiB7IGlkOiAnJywgb2s6IHJlcy5vayAhPT0gZmFsc2UsIGVycm9yOiByZXMuZXJyb3IsIGVycm9yQ29kZTogcmVzLmVycm9yQ29kZSwgZGF0YTogcmVzLmRhdGEgfTtcbiAgfSBmaW5hbGx5IHtcbiAgICBwb3J0LmRpc2Nvbm5lY3QoKTtcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBoYW5kbGVOYXZpZ2F0ZShwYXlsb2FkOiBOYXZpZ2F0ZVBheWxvYWQsIHRhYklkT3ZlcnJpZGU/OiBudW1iZXIgfCBudWxsLCBzZXNzaW9uSWQ/OiBzdHJpbmcgfCBudWxsKTogUHJvbWlzZTxXU1Jlc3BvbnNlPiB7XG4gIGNvbnN0IHRhYklkID0gYXdhaXQgZ2V0QWN0aXZlVGFiSWQodGFiSWRPdmVycmlkZSk7XG4gIGlmICghdGFiSWQpIHtcbiAgICByZXR1cm4geyBpZDogJycsIG9rOiBmYWxzZSwgZXJyb3I6ICdObyBhY3RpdmUgdGFiIGF2YWlsYWJsZScsIGVycm9yQ29kZTogJ05PX0FDVElWRV9UQUInIH07XG4gIH1cbiAgaWYgKCFzZXNzaW9uSWQgfHwgIWFsbG93VGFiQWNjZXNzKHRhYklkLCBzZXNzaW9uSWQpKSB7XG4gICAgcmV0dXJuIHsgaWQ6ICcnLCBvazogZmFsc2UsIGVycm9yOiAnVGFiIG5vdCBvd25lZCBieSBzZXNzaW9uJywgZXJyb3JDb2RlOiAnVEFCX05PVF9PV05FRCcgfTtcbiAgfVxuICBjb25zdCB7IGNsaWVudCwgcG9ydCB9ID0gbWFrZUNvbnRlbnRDbGllbnQodGFiSWQpO1xuICB0cnkge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGNsaWVudC5uYXZpZ2F0ZS5tdXRhdGUoeyB1cmw6IHBheWxvYWQudXJsIH0pO1xuICAgIHJldHVybiB7IGlkOiAnJywgb2s6IHJlcy5vayAhPT0gZmFsc2UsIGVycm9yOiByZXMuZXJyb3IsIGVycm9yQ29kZTogcmVzLmVycm9yQ29kZSwgZGF0YTogcmVzLmRhdGEgfTtcbiAgfSBmaW5hbGx5IHtcbiAgICBwb3J0LmRpc2Nvbm5lY3QoKTtcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBoYW5kbGVUeXBlKHBheWxvYWQ6IFR5cGVQYXlsb2FkLCB0YWJJZE92ZXJyaWRlPzogbnVtYmVyIHwgbnVsbCwgc2Vzc2lvbklkPzogc3RyaW5nIHwgbnVsbCk6IFByb21pc2U8V1NSZXNwb25zZT4ge1xuICBjb25zdCB0YWJJZCA9IGF3YWl0IGdldEFjdGl2ZVRhYklkKHRhYklkT3ZlcnJpZGUpO1xuICBpZiAoIXRhYklkKSB7XG4gICAgcmV0dXJuIHsgaWQ6ICcnLCBvazogZmFsc2UsIGVycm9yOiAnTm8gYWN0aXZlIHRhYiBhdmFpbGFibGUnLCBlcnJvckNvZGU6ICdOT19BQ1RJVkVfVEFCJyB9O1xuICB9XG4gIGlmICghc2Vzc2lvbklkIHx8ICFhbGxvd1RhYkFjY2Vzcyh0YWJJZCwgc2Vzc2lvbklkKSkge1xuICAgIHJldHVybiB7IGlkOiAnJywgb2s6IGZhbHNlLCBlcnJvcjogJ1RhYiBub3Qgb3duZWQgYnkgc2Vzc2lvbicsIGVycm9yQ29kZTogJ1RBQl9OT1RfT1dORUQnIH07XG4gIH1cbiAgY29uc3QgeyBjbGllbnQsIHBvcnQgfSA9IG1ha2VDb250ZW50Q2xpZW50KHRhYklkKTtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBjbGllbnQudHlwZS5tdXRhdGUoe1xuICAgICAgc2VsZWN0b3I6IHBheWxvYWQuc2VsZWN0b3IsXG4gICAgICB0ZXh0OiBwYXlsb2FkLnRleHQsXG4gICAgICBwcmVzc0VudGVyOiBwYXlsb2FkLnByZXNzRW50ZXIsXG4gICAgfSk7XG4gICAgcmV0dXJuIHsgaWQ6ICcnLCBvazogcmVzLm9rICE9PSBmYWxzZSwgZXJyb3I6IHJlcy5lcnJvciwgZXJyb3JDb2RlOiByZXMuZXJyb3JDb2RlLCBkYXRhOiByZXMuZGF0YSB9O1xuICB9IGZpbmFsbHkge1xuICAgIHBvcnQuZGlzY29ubmVjdCgpO1xuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGhhbmRsZUVudGVyKHBheWxvYWQ6IEVudGVyUGF5bG9hZCwgdGFiSWRPdmVycmlkZT86IG51bWJlciB8IG51bGwsIHNlc3Npb25JZD86IHN0cmluZyB8IG51bGwpOiBQcm9taXNlPFdTUmVzcG9uc2U+IHtcbiAgY29uc3QgdGFiSWQgPSBhd2FpdCBnZXRBY3RpdmVUYWJJZCh0YWJJZE92ZXJyaWRlKTtcbiAgaWYgKCF0YWJJZCkge1xuICAgIHJldHVybiB7IGlkOiAnJywgb2s6IGZhbHNlLCBlcnJvcjogJ05vIGFjdGl2ZSB0YWIgYXZhaWxhYmxlJywgZXJyb3JDb2RlOiAnTk9fQUNUSVZFX1RBQicgfTtcbiAgfVxuICBpZiAoIXNlc3Npb25JZCB8fCAhYWxsb3dUYWJBY2Nlc3ModGFiSWQsIHNlc3Npb25JZCkpIHtcbiAgICByZXR1cm4geyBpZDogJycsIG9rOiBmYWxzZSwgZXJyb3I6ICdUYWIgbm90IG93bmVkIGJ5IHNlc3Npb24nLCBlcnJvckNvZGU6ICdUQUJfTk9UX09XTkVEJyB9O1xuICB9XG4gIGNvbnN0IHsgY2xpZW50LCBwb3J0IH0gPSBtYWtlQ29udGVudENsaWVudCh0YWJJZCk7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgY2xpZW50LmVudGVyLm11dGF0ZSh7IHNlbGVjdG9yOiBwYXlsb2FkLnNlbGVjdG9yLCBrZXk6IHBheWxvYWQua2V5IH0pO1xuICAgIHJldHVybiB7IGlkOiAnJywgb2s6IHJlcy5vayAhPT0gZmFsc2UsIGVycm9yOiByZXMuZXJyb3IsIGVycm9yQ29kZTogcmVzLmVycm9yQ29kZSwgZGF0YTogcmVzLmRhdGEgfTtcbiAgfSBmaW5hbGx5IHtcbiAgICBwb3J0LmRpc2Nvbm5lY3QoKTtcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBoYW5kbGVTZWxlY3QocGF5bG9hZDogU2VsZWN0UGF5bG9hZCwgdGFiSWRPdmVycmlkZT86IG51bWJlciB8IG51bGwsIHNlc3Npb25JZD86IHN0cmluZyB8IG51bGwpOiBQcm9taXNlPFdTUmVzcG9uc2U+IHtcbiAgY29uc3QgdGFiSWQgPSBhd2FpdCBnZXRBY3RpdmVUYWJJZCh0YWJJZE92ZXJyaWRlKTtcbiAgaWYgKCF0YWJJZCkge1xuICAgIHJldHVybiB7IGlkOiAnJywgb2s6IGZhbHNlLCBlcnJvcjogJ05vIGFjdGl2ZSB0YWIgYXZhaWxhYmxlJywgZXJyb3JDb2RlOiAnTk9fQUNUSVZFX1RBQicgfTtcbiAgfVxuICBpZiAoIXNlc3Npb25JZCB8fCAhYWxsb3dUYWJBY2Nlc3ModGFiSWQsIHNlc3Npb25JZCkpIHtcbiAgICByZXR1cm4geyBpZDogJycsIG9rOiBmYWxzZSwgZXJyb3I6ICdUYWIgbm90IG93bmVkIGJ5IHNlc3Npb24nLCBlcnJvckNvZGU6ICdUQUJfTk9UX09XTkVEJyB9O1xuICB9XG4gIGNvbnN0IHsgY2xpZW50LCBwb3J0IH0gPSBtYWtlQ29udGVudENsaWVudCh0YWJJZCk7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgY2xpZW50LnNlbGVjdC5tdXRhdGUoe1xuICAgICAgc2VsZWN0b3I6IHBheWxvYWQuc2VsZWN0b3IsXG4gICAgICB2YWx1ZTogcGF5bG9hZC52YWx1ZSxcbiAgICAgIGxhYmVsOiBwYXlsb2FkLmxhYmVsLFxuICAgICAgaW5kZXg6IHBheWxvYWQuaW5kZXgsXG4gICAgICB2YWx1ZXM6IHBheWxvYWQudmFsdWVzLFxuICAgICAgbGFiZWxzOiBwYXlsb2FkLmxhYmVscyxcbiAgICAgIGluZGljZXM6IHBheWxvYWQuaW5kaWNlcyxcbiAgICAgIG1hdGNoTW9kZTogcGF5bG9hZC5tYXRjaE1vZGUsXG4gICAgICB0b2dnbGU6IHBheWxvYWQudG9nZ2xlLFxuICAgIH0pO1xuICAgIHJldHVybiB7IGlkOiAnJywgb2s6IHJlcy5vayAhPT0gZmFsc2UsIGVycm9yOiByZXMuZXJyb3IsIGVycm9yQ29kZTogcmVzLmVycm9yQ29kZSwgZGF0YTogcmVzLmRhdGEgfTtcbiAgfSBmaW5hbGx5IHtcbiAgICBwb3J0LmRpc2Nvbm5lY3QoKTtcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBoYW5kbGVTY3JlZW5zaG90KHBheWxvYWQ6IFNjcmVlbnNob3RQYXlsb2FkLCB0YWJJZE92ZXJyaWRlPzogbnVtYmVyIHwgbnVsbCwgc2Vzc2lvbklkPzogc3RyaW5nIHwgbnVsbCk6IFByb21pc2U8V1NSZXNwb25zZT4ge1xuICBjb25zdCB0YWJJZCA9IGF3YWl0IGdldEFjdGl2ZVRhYklkKHRhYklkT3ZlcnJpZGUpO1xuICBpZiAoIXRhYklkKSB7XG4gICAgcmV0dXJuIHsgaWQ6ICcnLCBvazogZmFsc2UsIGVycm9yOiAnTm8gYWN0aXZlIHRhYiBhdmFpbGFibGUnLCBlcnJvckNvZGU6ICdOT19BQ1RJVkVfVEFCJyB9O1xuICB9XG4gIGlmICghc2Vzc2lvbklkIHx8ICFhbGxvd1RhYkFjY2Vzcyh0YWJJZCwgc2Vzc2lvbklkKSkge1xuICAgIHJldHVybiB7IGlkOiAnJywgb2s6IGZhbHNlLCBlcnJvcjogJ1RhYiBub3Qgb3duZWQgYnkgc2Vzc2lvbicsIGVycm9yQ29kZTogJ1RBQl9OT1RfT1dORUQnIH07XG4gIH1cbiAgY29uc3QgeyBjbGllbnQsIHBvcnQgfSA9IG1ha2VDb250ZW50Q2xpZW50KHRhYklkKTtcbiAgdHJ5IHtcbiAgICBjb25zdCBwcmVwID0gYXdhaXQgY2xpZW50LnNjcmVlbnNob3RQcmVwLm11dGF0ZSh7XG4gICAgICBzZWxlY3RvcjogcGF5bG9hZC5zZWxlY3RvcixcbiAgICAgIHBhZGRpbmc6IHBheWxvYWQucGFkZGluZyxcbiAgICAgIGZvcm1hdDogcGF5bG9hZC5mb3JtYXQsXG4gICAgICBxdWFsaXR5OiBwYXlsb2FkLnF1YWxpdHksXG4gICAgICBtYXhXaWR0aDogcGF5bG9hZC5tYXhXaWR0aCxcbiAgICAgIG1heEhlaWdodDogcGF5bG9hZC5tYXhIZWlnaHQsXG4gICAgfSk7XG4gICAgaWYgKCFwcmVwLm9rKSB7XG4gICAgICByZXR1cm4geyBpZDogJycsIG9rOiBmYWxzZSwgZXJyb3I6IHByZXAuZXJyb3IgfHwgJ1NjcmVlbnNob3QgcHJlcCBmYWlsZWQnLCBlcnJvckNvZGU6IHByZXAuZXJyb3JDb2RlIH07XG4gICAgfVxuICAgIGNvbnN0IHJlY3REYXRhID0gcHJlcC5kYXRhIGFzIFNjcmVlbnNob3RQcmVwUmVzcG9uc2U7XG4gICAgY29uc3QgdGFiID0gYXdhaXQgY2hyb21lQXBpLnRhYnMuZ2V0KHRhYklkKTtcbiAgICBjb25zdCBmb3JtYXQgPSBwYXlsb2FkLmZvcm1hdCA/PyAncG5nJztcbiAgICBjb25zdCBxdWFsaXR5ID0gcGF5bG9hZC5xdWFsaXR5ID8/IDAuOTI7XG4gICAgY29uc3QgZGF0YVVybCA9IGF3YWl0IGNocm9tZUFwaS50YWJzLmNhcHR1cmVWaXNpYmxlVGFiKHRhYi53aW5kb3dJZCEsIHtcbiAgICAgIGZvcm1hdCxcbiAgICAgIHF1YWxpdHk6IGZvcm1hdCA9PT0gJ2pwZWcnID8gTWF0aC5yb3VuZChxdWFsaXR5ICogMTAwKSA6IHVuZGVmaW5lZCxcbiAgICB9KTtcbiAgICBjb25zdCBjcm9wcGVkID0gYXdhaXQgY3JvcERhdGFVcmwoXG4gICAgICBkYXRhVXJsLFxuICAgICAgcmVjdERhdGEucmVjdCxcbiAgICAgIHJlY3REYXRhLmRwcixcbiAgICAgIGZvcm1hdCxcbiAgICAgIHF1YWxpdHksXG4gICAgICBwYXlsb2FkLm1heFdpZHRoLFxuICAgICAgcGF5bG9hZC5tYXhIZWlnaHRcbiAgICApO1xuICAgIGNvbnN0IHJlc3BvbnNlOiBTY3JlZW5zaG90UmVzcG9uc2UgPSB7XG4gICAgICBzZWxlY3RvcjogcGF5bG9hZC5zZWxlY3RvciB8fCAndmlld3BvcnQnLFxuICAgICAgZGF0YVVybDogY3JvcHBlZC5kYXRhVXJsLFxuICAgICAgd2lkdGg6IGNyb3BwZWQud2lkdGgsXG4gICAgICBoZWlnaHQ6IGNyb3BwZWQuaGVpZ2h0LFxuICAgICAgZm9ybWF0LFxuICAgIH07XG4gICAgcmV0dXJuIHsgaWQ6ICcnLCBvazogdHJ1ZSwgZGF0YTogcmVzcG9uc2UgfTtcbiAgfSBjYXRjaCAoZXJyOiBhbnkpIHtcbiAgICByZXR1cm4geyBpZDogJycsIG9rOiBmYWxzZSwgZXJyb3I6IGVycj8ubWVzc2FnZSB8fCAnU2NyZWVuc2hvdCBmYWlsZWQnLCBlcnJvckNvZGU6ICdTQ1JFRU5TSE9UX0ZBSUxFRCcgfTtcbiAgfSBmaW5hbGx5IHtcbiAgICBwb3J0LmRpc2Nvbm5lY3QoKTtcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBoYW5kbGVCYWNrKHRhYklkT3ZlcnJpZGU/OiBudW1iZXIgfCBudWxsLCBzZXNzaW9uSWQ/OiBzdHJpbmcgfCBudWxsKTogUHJvbWlzZTxXU1Jlc3BvbnNlPiB7XG4gIGNvbnN0IHRhYklkID0gYXdhaXQgZ2V0QWN0aXZlVGFiSWQodGFiSWRPdmVycmlkZSk7XG4gIGlmICghdGFiSWQpIHtcbiAgICByZXR1cm4geyBpZDogJycsIG9rOiBmYWxzZSwgZXJyb3I6ICdObyBhY3RpdmUgdGFiIGF2YWlsYWJsZScsIGVycm9yQ29kZTogJ05PX0FDVElWRV9UQUInIH07XG4gIH1cbiAgaWYgKCFzZXNzaW9uSWQgfHwgIWFsbG93VGFiQWNjZXNzKHRhYklkLCBzZXNzaW9uSWQpKSB7XG4gICAgcmV0dXJuIHsgaWQ6ICcnLCBvazogZmFsc2UsIGVycm9yOiAnVGFiIG5vdCBvd25lZCBieSBzZXNzaW9uJywgZXJyb3JDb2RlOiAnVEFCX05PVF9PV05FRCcgfTtcbiAgfVxuICBjb25zdCB7IGNsaWVudCwgcG9ydCB9ID0gbWFrZUNvbnRlbnRDbGllbnQodGFiSWQpO1xuICB0cnkge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGNsaWVudC5iYWNrLm11dGF0ZSgpO1xuICAgIHJldHVybiB7IGlkOiAnJywgb2s6IHJlcy5vayAhPT0gZmFsc2UsIGVycm9yOiByZXMuZXJyb3IsIGVycm9yQ29kZTogcmVzLmVycm9yQ29kZSwgZGF0YTogcmVzLmRhdGEgfTtcbiAgfSBmaW5hbGx5IHtcbiAgICBwb3J0LmRpc2Nvbm5lY3QoKTtcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBoYW5kbGVGb3J3YXJkKHRhYklkT3ZlcnJpZGU/OiBudW1iZXIgfCBudWxsLCBzZXNzaW9uSWQ/OiBzdHJpbmcgfCBudWxsKTogUHJvbWlzZTxXU1Jlc3BvbnNlPiB7XG4gIGNvbnN0IHRhYklkID0gYXdhaXQgZ2V0QWN0aXZlVGFiSWQodGFiSWRPdmVycmlkZSk7XG4gIGlmICghdGFiSWQpIHtcbiAgICByZXR1cm4geyBpZDogJycsIG9rOiBmYWxzZSwgZXJyb3I6ICdObyBhY3RpdmUgdGFiIGF2YWlsYWJsZScsIGVycm9yQ29kZTogJ05PX0FDVElWRV9UQUInIH07XG4gIH1cbiAgaWYgKCFzZXNzaW9uSWQgfHwgIWFsbG93VGFiQWNjZXNzKHRhYklkLCBzZXNzaW9uSWQpKSB7XG4gICAgcmV0dXJuIHsgaWQ6ICcnLCBvazogZmFsc2UsIGVycm9yOiAnVGFiIG5vdCBvd25lZCBieSBzZXNzaW9uJywgZXJyb3JDb2RlOiAnVEFCX05PVF9PV05FRCcgfTtcbiAgfVxuICBjb25zdCB7IGNsaWVudCwgcG9ydCB9ID0gbWFrZUNvbnRlbnRDbGllbnQodGFiSWQpO1xuICB0cnkge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGNsaWVudC5mb3J3YXJkLm11dGF0ZSgpO1xuICAgIHJldHVybiB7IGlkOiAnJywgb2s6IHJlcy5vayAhPT0gZmFsc2UsIGVycm9yOiByZXMuZXJyb3IsIGVycm9yQ29kZTogcmVzLmVycm9yQ29kZSwgZGF0YTogcmVzLmRhdGEgfTtcbiAgfSBmaW5hbGx5IHtcbiAgICBwb3J0LmRpc2Nvbm5lY3QoKTtcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBoYW5kbGVIb3ZlcihwYXlsb2FkOiBIb3ZlclBheWxvYWQsIHRhYklkT3ZlcnJpZGU/OiBudW1iZXIgfCBudWxsLCBzZXNzaW9uSWQ/OiBzdHJpbmcgfCBudWxsKTogUHJvbWlzZTxXU1Jlc3BvbnNlPiB7XG4gIGNvbnN0IHRhYklkID0gYXdhaXQgZ2V0QWN0aXZlVGFiSWQodGFiSWRPdmVycmlkZSk7XG4gIGlmICghdGFiSWQpIHtcbiAgICByZXR1cm4geyBpZDogJycsIG9rOiBmYWxzZSwgZXJyb3I6ICdObyBhY3RpdmUgdGFiIGF2YWlsYWJsZScsIGVycm9yQ29kZTogJ05PX0FDVElWRV9UQUInIH07XG4gIH1cbiAgaWYgKCFzZXNzaW9uSWQgfHwgIWFsbG93VGFiQWNjZXNzKHRhYklkLCBzZXNzaW9uSWQpKSB7XG4gICAgcmV0dXJuIHsgaWQ6ICcnLCBvazogZmFsc2UsIGVycm9yOiAnVGFiIG5vdCBvd25lZCBieSBzZXNzaW9uJywgZXJyb3JDb2RlOiAnVEFCX05PVF9PV05FRCcgfTtcbiAgfVxuICBjb25zdCB7IGNsaWVudCwgcG9ydCB9ID0gbWFrZUNvbnRlbnRDbGllbnQodGFiSWQpO1xuICB0cnkge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGNsaWVudC5ob3Zlci5tdXRhdGUoeyBzZWxlY3RvcjogcGF5bG9hZC5zZWxlY3RvciB9KTtcbiAgICByZXR1cm4geyBpZDogJycsIG9rOiByZXMub2sgIT09IGZhbHNlLCBlcnJvcjogcmVzLmVycm9yLCBlcnJvckNvZGU6IHJlcy5lcnJvckNvZGUsIGRhdGE6IHJlcy5kYXRhIH07XG4gIH0gZmluYWxseSB7XG4gICAgcG9ydC5kaXNjb25uZWN0KCk7XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gaGFuZGxlRmluZChwYXlsb2FkOiBGaW5kUGF5bG9hZCwgdGFiSWRPdmVycmlkZT86IG51bWJlciB8IG51bGwsIHNlc3Npb25JZD86IHN0cmluZyB8IG51bGwpOiBQcm9taXNlPFdTUmVzcG9uc2U+IHtcbiAgY29uc3QgdGFiSWQgPSBhd2FpdCBnZXRBY3RpdmVUYWJJZCh0YWJJZE92ZXJyaWRlKTtcbiAgaWYgKCF0YWJJZCkge1xuICAgIHJldHVybiB7IGlkOiAnJywgb2s6IGZhbHNlLCBlcnJvcjogJ05vIGFjdGl2ZSB0YWIgYXZhaWxhYmxlJywgZXJyb3JDb2RlOiAnTk9fQUNUSVZFX1RBQicgfTtcbiAgfVxuICBpZiAoIXNlc3Npb25JZCB8fCAhYWxsb3dUYWJBY2Nlc3ModGFiSWQsIHNlc3Npb25JZCkpIHtcbiAgICByZXR1cm4geyBpZDogJycsIG9rOiBmYWxzZSwgZXJyb3I6ICdUYWIgbm90IG93bmVkIGJ5IHNlc3Npb24nLCBlcnJvckNvZGU6ICdUQUJfTk9UX09XTkVEJyB9O1xuICB9XG4gIGNvbnN0IHsgY2xpZW50LCBwb3J0IH0gPSBtYWtlQ29udGVudENsaWVudCh0YWJJZCk7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgY2xpZW50LmZpbmQubXV0YXRlKHtcbiAgICAgIHRleHQ6IHBheWxvYWQudGV4dCxcbiAgICAgIGxpbWl0OiBwYXlsb2FkLmxpbWl0LFxuICAgICAgcmFkaXVzOiBwYXlsb2FkLnJhZGl1cyxcbiAgICAgIGNhc2VTZW5zaXRpdmU6IHBheWxvYWQuY2FzZVNlbnNpdGl2ZSxcbiAgICB9KTtcbiAgICBpZiAoIXJlcy5vaykge1xuICAgICAgcmV0dXJuIHsgaWQ6ICcnLCBvazogZmFsc2UsIGVycm9yOiByZXMuZXJyb3IgfHwgJ0ZpbmQgZmFpbGVkJywgZXJyb3JDb2RlOiByZXMuZXJyb3JDb2RlIH07XG4gICAgfVxuICAgIHJldHVybiB7IGlkOiAnJywgb2s6IHRydWUsIGRhdGE6IHJlcy5kYXRhIGFzIEZpbmRSZXNwb25zZSB9O1xuICB9IGZpbmFsbHkge1xuICAgIHBvcnQuZGlzY29ubmVjdCgpO1xuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGhhbmRsZUNvbW1hbmQoY21kOiBXU0NvbW1hbmQpIHtcbiAgbGFzdENvbW1hbmQgPSBjbWQ7XG4gIGxldCByZXNwOiBXU1Jlc3BvbnNlID0geyBpZDogY21kLmlkLCBvazogZmFsc2UsIGVycm9yOiAnVW5rbm93biBjb21tYW5kJyB9O1xuICB0cnkge1xuICAgIGNvbnN0IGhhbmRsZXIgPSBjb21tYW5kSGFuZGxlcnNbY21kLnR5cGVdO1xuICAgIGlmICghaGFuZGxlcikge1xuICAgICAgcmVzcCA9IHsgaWQ6IGNtZC5pZCwgb2s6IGZhbHNlLCBlcnJvcjogYFVuc3VwcG9ydGVkIGNvbW1hbmQ6ICR7Y21kLnR5cGV9YCwgZXJyb3JDb2RlOiAnVU5TVVBQT1JURURfQ09NTUFORCcgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgc2Vzc2lvbklkID0gcmVxdWlyZVNlc3Npb24oY21kKTtcbiAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IGhhbmRsZXIoY21kLnBheWxvYWQsIGNtZC50YWJJZCA/PyBudWxsLCBzZXNzaW9uSWQpO1xuICAgICAgcmVzcCA9IHsgLi4ucmVzLCBpZDogY21kLmlkIH07XG4gICAgfVxuICB9IGNhdGNoIChlcnI6IGFueSkge1xuICAgIHJlc3AgPSB7IGlkOiBjbWQuaWQsIG9rOiBmYWxzZSwgZXJyb3I6IGVycj8ubWVzc2FnZSB8fCAnQ29tbWFuZCBmYWlsZWQnLCBlcnJvckNvZGU6ICdDT01NQU5EX0ZBSUxFRCcgfTtcbiAgfVxuICBzZW5kV1MocmVzcCk7XG59XG5cbmNvbnN0IG5vdEltcGxlbWVudGVkID0gYXN5bmMgKG5hbWU6IHN0cmluZyk6IFByb21pc2U8V1NSZXNwb25zZT4gPT4gKHtcbiAgaWQ6ICcnLFxuICBvazogZmFsc2UsXG4gIGVycm9yOiBgJHtuYW1lfSBub3QgaW1wbGVtZW50ZWRgLFxuICBlcnJvckNvZGU6ICdOT1RfSU1QTEVNRU5URUQnLFxufSk7XG5cbmNvbnN0IGNvbW1hbmRIYW5kbGVyczogUmVjb3JkPHN0cmluZywgKHBheWxvYWQ6IHVua25vd24sIHRhYklkOiBudW1iZXIgfCBudWxsLCBzZXNzaW9uSWQ6IHN0cmluZyB8IG51bGwpID0+IFByb21pc2U8V1NSZXNwb25zZT4+ID0ge1xuICBjbGljazogKHBheWxvYWQsIHRhYklkLCBzZXNzaW9uSWQpID0+IGhhbmRsZUNsaWNrKHBheWxvYWQgYXMgQ2xpY2tQYXlsb2FkLCB0YWJJZCwgc2Vzc2lvbklkKSxcbiAgc25hcHNob3Q6IChwYXlsb2FkLCB0YWJJZCwgc2Vzc2lvbklkKSA9PiBoYW5kbGVTbmFwc2hvdChwYXlsb2FkIGFzIFNuYXBzaG90UGF5bG9hZCwgdGFiSWQsIHNlc3Npb25JZCksXG4gIHNjcm9sbDogKHBheWxvYWQsIHRhYklkLCBzZXNzaW9uSWQpID0+IGhhbmRsZVNjcm9sbChwYXlsb2FkIGFzIFNjcm9sbFBheWxvYWQsIHRhYklkLCBzZXNzaW9uSWQpLFxuICBob3ZlcjogKHBheWxvYWQsIHRhYklkLCBzZXNzaW9uSWQpID0+IGhhbmRsZUhvdmVyKHBheWxvYWQgYXMgSG92ZXJQYXlsb2FkLCB0YWJJZCwgc2Vzc2lvbklkKSxcbiAgdHlwZTogKHBheWxvYWQsIHRhYklkLCBzZXNzaW9uSWQpID0+IGhhbmRsZVR5cGUocGF5bG9hZCBhcyBUeXBlUGF5bG9hZCwgdGFiSWQsIHNlc3Npb25JZCksXG4gIGVudGVyOiAocGF5bG9hZCwgdGFiSWQsIHNlc3Npb25JZCkgPT4gaGFuZGxlRW50ZXIocGF5bG9hZCBhcyBFbnRlclBheWxvYWQsIHRhYklkLCBzZXNzaW9uSWQpLFxuICBzZWxlY3Q6IChwYXlsb2FkLCB0YWJJZCwgc2Vzc2lvbklkKSA9PiBoYW5kbGVTZWxlY3QocGF5bG9hZCBhcyBTZWxlY3RQYXlsb2FkLCB0YWJJZCwgc2Vzc2lvbklkKSxcbiAgYmFjazogKF9wYXlsb2FkLCB0YWJJZCwgc2Vzc2lvbklkKSA9PiBoYW5kbGVCYWNrKHRhYklkLCBzZXNzaW9uSWQpLFxuICBmb3J3YXJkOiAoX3BheWxvYWQsIHRhYklkLCBzZXNzaW9uSWQpID0+IGhhbmRsZUZvcndhcmQodGFiSWQsIHNlc3Npb25JZCksXG4gIHdhaXRGb3JTZWxlY3RvcjogKHBheWxvYWQsIHRhYklkLCBzZXNzaW9uSWQpID0+IGhhbmRsZVdhaXRGb3JTZWxlY3RvcihwYXlsb2FkIGFzIFdhaXRGb3JTZWxlY3RvclBheWxvYWQsIHRhYklkLCBzZXNzaW9uSWQpLFxuICBmaW5kOiAocGF5bG9hZCwgdGFiSWQsIHNlc3Npb25JZCkgPT4gaGFuZGxlRmluZChwYXlsb2FkIGFzIEZpbmRQYXlsb2FkLCB0YWJJZCwgc2Vzc2lvbklkKSxcbiAgbmF2aWdhdGU6IChwYXlsb2FkLCB0YWJJZCwgc2Vzc2lvbklkKSA9PiBoYW5kbGVOYXZpZ2F0ZShwYXlsb2FkIGFzIE5hdmlnYXRlUGF5bG9hZCwgdGFiSWQsIHNlc3Npb25JZCksXG4gIHNjcmVlbnNob3Q6IChwYXlsb2FkLCB0YWJJZCwgc2Vzc2lvbklkKSA9PiBoYW5kbGVTY3JlZW5zaG90KHBheWxvYWQgYXMgU2NyZWVuc2hvdFBheWxvYWQsIHRhYklkLCBzZXNzaW9uSWQpLFxuICBzdGFydF9yZWNvcmRpbmc6IChfcGF5bG9hZCwgdGFiSWQsIHNlc3Npb25JZCkgPT4gaGFuZGxlU3RhcnRSZWNvcmRpbmcoKSxcbiAgc3RvcF9yZWNvcmRpbmc6IChfcGF5bG9hZCwgdGFiSWQsIHNlc3Npb25JZCkgPT4gaGFuZGxlU3RvcFJlY29yZGluZygpLFxuICBnZXRfcmVjb3JkaW5nOiAoX3BheWxvYWQsIHRhYklkLCBzZXNzaW9uSWQpID0+IGhhbmRsZUdldFJlY29yZGluZygpLFxuICBsaXN0X3RhYnM6IChfcGF5bG9hZCwgdGFiSWQsIHNlc3Npb25JZCkgPT4gaGFuZGxlTGlzdFRhYnMoc2Vzc2lvbklkKSxcbiAgb3Blbl90YWI6IChwYXlsb2FkLCBfdGFiSWQsIHNlc3Npb25JZCkgPT4gaGFuZGxlT3BlblRhYihwYXlsb2FkIGFzIE9wZW5UYWJQYXlsb2FkLCBzZXNzaW9uSWQpLFxuICBjbG9zZV90YWI6IChwYXlsb2FkLCBfdGFiSWQsIHNlc3Npb25JZCkgPT4gaGFuZGxlQ2xvc2VUYWIocGF5bG9hZCBhcyBDbG9zZVRhYlBheWxvYWQsIHNlc3Npb25JZCksXG4gIGNsYWltX3RhYjogKHBheWxvYWQsIF90YWJJZCwgc2Vzc2lvbklkKSA9PiBoYW5kbGVDbGFpbVRhYihwYXlsb2FkIGFzIENsYWltVGFiUGF5bG9hZCwgc2Vzc2lvbklkKSxcbiAgcmVsZWFzZV90YWI6IChwYXlsb2FkLCBfdGFiSWQsIHNlc3Npb25JZCkgPT4gaGFuZGxlUmVsZWFzZVRhYihwYXlsb2FkIGFzIFJlbGVhc2VUYWJQYXlsb2FkLCBzZXNzaW9uSWQpLFxuICBzZXRfdGFiX3NoYXJpbmc6IChwYXlsb2FkLCBfdGFiSWQsIHNlc3Npb25JZCkgPT4gaGFuZGxlU2V0VGFiU2hhcmluZyhwYXlsb2FkIGFzIFNldFRhYlNoYXJpbmdQYXlsb2FkLCBzZXNzaW9uSWQpLFxufTtcblxuYXN5bmMgZnVuY3Rpb24gaGFuZGxlU3RhcnRSZWNvcmRpbmcoKTogUHJvbWlzZTxXU1Jlc3BvbnNlPiB7XG4gIGF3YWl0IHJvdXRlclN0YXJ0UmVjb3JkaW5nKCk7XG4gIGNvbnN0IGRhdGE6IFJlY29yZGluZ1N0YXRlUmVzcG9uc2UgPSB7IHJlY29yZGluZzogdHJ1ZSwgY291bnQ6IHJlY29yZGVkQWN0aW9ucy5sZW5ndGggfTtcbiAgcmV0dXJuIHsgaWQ6ICcnLCBvazogdHJ1ZSwgZGF0YSB9O1xufVxuXG5hc3luYyBmdW5jdGlvbiBoYW5kbGVTdG9wUmVjb3JkaW5nKCk6IFByb21pc2U8V1NSZXNwb25zZT4ge1xuICBhd2FpdCByb3V0ZXJTdG9wUmVjb3JkaW5nKCk7XG4gIGNvbnN0IGRhdGE6IFJlY29yZGluZ1N0YXRlUmVzcG9uc2UgPSB7IHJlY29yZGluZzogZmFsc2UsIGNvdW50OiByZWNvcmRlZEFjdGlvbnMubGVuZ3RoIH07XG4gIHJldHVybiB7IGlkOiAnJywgb2s6IHRydWUsIGRhdGEgfTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gaGFuZGxlR2V0UmVjb3JkaW5nKCk6IFByb21pc2U8V1NSZXNwb25zZT4ge1xuICByZXR1cm4geyBpZDogJycsIG9rOiB0cnVlLCBkYXRhOiByZWNvcmRlZEFjdGlvbnMgfTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gaGFuZGxlTGlzdFRhYnMoc2Vzc2lvbklkOiBzdHJpbmcgfCBudWxsKTogUHJvbWlzZTxXU1Jlc3BvbnNlPiB7XG4gIGlmICghc2Vzc2lvbklkKSB7XG4gICAgcmV0dXJuIHsgaWQ6ICcnLCBvazogZmFsc2UsIGVycm9yOiAnU2Vzc2lvbiBpZCBpcyByZXF1aXJlZCcsIGVycm9yQ29kZTogJ1NFU1NJT05fUkVRVUlSRUQnIH07XG4gIH1cbiAgY29uc3QgdGFicyA9IGF3YWl0IGxpc3RUYWJzKCk7XG4gIGNvbnN0IHNjb3BlZCA9IHRhYnMuZmlsdGVyKHRhYiA9PiBhbGxvd1RhYkFjY2Vzcyh0YWIuaWQsIHNlc3Npb25JZCkpO1xuICByZXR1cm4geyBpZDogJycsIG9rOiB0cnVlLCBkYXRhOiBzY29wZWQgYXMgVGFiSW5mb1tdIH07XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGhhbmRsZU9wZW5UYWIocGF5bG9hZDogT3BlblRhYlBheWxvYWQsIHNlc3Npb25JZDogc3RyaW5nIHwgbnVsbCk6IFByb21pc2U8V1NSZXNwb25zZT4ge1xuICBpZiAoIXNlc3Npb25JZCkge1xuICAgIHJldHVybiB7IGlkOiAnJywgb2s6IGZhbHNlLCBlcnJvcjogJ1Nlc3Npb24gaWQgaXMgcmVxdWlyZWQnLCBlcnJvckNvZGU6ICdTRVNTSU9OX1JFUVVJUkVEJyB9O1xuICB9XG4gIGNvbnN0IHRhYiA9IGF3YWl0IGNocm9tZUFwaS50YWJzLmNyZWF0ZSh7XG4gICAgdXJsOiBwYXlsb2FkLnVybCB8fCAnYWJvdXQ6YmxhbmsnLFxuICAgIGFjdGl2ZTogcGF5bG9hZC5hY3RpdmUgPz8gdHJ1ZSxcbiAgICBwaW5uZWQ6IHBheWxvYWQucGlubmVkID8/IGZhbHNlLFxuICB9KTtcbiAgaWYgKCF0YWI/LmlkKSB7XG4gICAgcmV0dXJuIHsgaWQ6ICcnLCBvazogZmFsc2UsIGVycm9yOiAnRmFpbGVkIHRvIG9wZW4gdGFiJywgZXJyb3JDb2RlOiAnVEFCX0NSRUFURV9GQUlMRUQnIH07XG4gIH1cbiAgZW5zdXJlT3duZXIodGFiLmlkLCBzZXNzaW9uSWQsICdleGNsdXNpdmUnKTtcbiAgY29uc3QgaW5mbzogVGFiSW5mbyA9IHsgaWQ6IHRhYi5pZCwgdGl0bGU6IHRhYi50aXRsZSB8fCAnVW50aXRsZWQnLCB1cmw6IHRhYi51cmwgfHwgcGF5bG9hZC51cmwgfHwgJycgfTtcbiAgcmV0dXJuIHsgaWQ6ICcnLCBvazogdHJ1ZSwgZGF0YTogaW5mbyB9O1xufVxuXG5hc3luYyBmdW5jdGlvbiBoYW5kbGVDbG9zZVRhYihwYXlsb2FkOiBDbG9zZVRhYlBheWxvYWQsIHNlc3Npb25JZDogc3RyaW5nIHwgbnVsbCk6IFByb21pc2U8V1NSZXNwb25zZT4ge1xuICBpZiAoIXNlc3Npb25JZCkge1xuICAgIHJldHVybiB7IGlkOiAnJywgb2s6IGZhbHNlLCBlcnJvcjogJ1Nlc3Npb24gaWQgaXMgcmVxdWlyZWQnLCBlcnJvckNvZGU6ICdTRVNTSU9OX1JFUVVJUkVEJyB9O1xuICB9XG4gIGlmICghcGF5bG9hZD8udGFiSWQpIHtcbiAgICByZXR1cm4geyBpZDogJycsIG9rOiBmYWxzZSwgZXJyb3I6ICd0YWJJZCBpcyByZXF1aXJlZCcsIGVycm9yQ29kZTogJ1RBQl9JRF9SRVFVSVJFRCcgfTtcbiAgfVxuICBpZiAoIWFsbG93VGFiQWNjZXNzKHBheWxvYWQudGFiSWQsIHNlc3Npb25JZCkpIHtcbiAgICByZXR1cm4geyBpZDogJycsIG9rOiBmYWxzZSwgZXJyb3I6ICdUYWIgbm90IG93bmVkIGJ5IHNlc3Npb24nLCBlcnJvckNvZGU6ICdUQUJfTk9UX09XTkVEJyB9O1xuICB9XG4gIGF3YWl0IGNocm9tZUFwaS50YWJzLnJlbW92ZShwYXlsb2FkLnRhYklkKTtcbiAgdGFiT3duZXJzLmRlbGV0ZShwYXlsb2FkLnRhYklkKTtcbiAgcmV0dXJuIHsgaWQ6ICcnLCBvazogdHJ1ZSB9O1xufVxuXG5hc3luYyBmdW5jdGlvbiBoYW5kbGVDbGFpbVRhYihwYXlsb2FkOiBDbGFpbVRhYlBheWxvYWQsIHNlc3Npb25JZDogc3RyaW5nIHwgbnVsbCk6IFByb21pc2U8V1NSZXNwb25zZT4ge1xuICBpZiAoIXNlc3Npb25JZCkge1xuICAgIHJldHVybiB7IGlkOiAnJywgb2s6IGZhbHNlLCBlcnJvcjogJ1Nlc3Npb24gaWQgaXMgcmVxdWlyZWQnLCBlcnJvckNvZGU6ICdTRVNTSU9OX1JFUVVJUkVEJyB9O1xuICB9XG4gIGxldCB0YWJJZCA9IHBheWxvYWQ/LnRhYklkID8/IDA7XG4gIGlmICh0YWJJZCA9PT0gMCAmJiBwYXlsb2FkPy5yZXF1aXJlQWN0aXZlKSB7XG4gICAgY29uc3QgYWN0aXZlVGFicyA9IGF3YWl0IGNocm9tZUFwaS50YWJzLnF1ZXJ5KHsgYWN0aXZlOiB0cnVlLCBsYXN0Rm9jdXNlZFdpbmRvdzogdHJ1ZSB9KTtcbiAgICB0YWJJZCA9IGFjdGl2ZVRhYnMuZmluZCh0ID0+IHQuaWQgIT0gbnVsbCk/LmlkID8/IDA7XG4gIH1cbiAgaWYgKCF0YWJJZCkge1xuICAgIHJldHVybiB7IGlkOiAnJywgb2s6IGZhbHNlLCBlcnJvcjogJ3RhYklkIGlzIHJlcXVpcmVkJywgZXJyb3JDb2RlOiAnVEFCX0lEX1JFUVVJUkVEJyB9O1xuICB9XG4gIGNvbnN0IHRhYiA9IGF3YWl0IGNocm9tZUFwaS50YWJzLmdldCh0YWJJZCkuY2F0Y2goKCkgPT4gbnVsbCk7XG4gIGlmICghdGFiPy5pZCkge1xuICAgIHJldHVybiB7IGlkOiAnJywgb2s6IGZhbHNlLCBlcnJvcjogJ1RhYiBub3QgZm91bmQnLCBlcnJvckNvZGU6ICdUQUJfTk9UX0ZPVU5EJyB9O1xuICB9XG4gIGlmIChwYXlsb2FkLnJlcXVpcmVBY3RpdmUpIHtcbiAgICBjb25zdCBhY3RpdmVUYWJzID0gYXdhaXQgY2hyb21lQXBpLnRhYnMucXVlcnkoeyBhY3RpdmU6IHRydWUsIGxhc3RGb2N1c2VkV2luZG93OiB0cnVlIH0pO1xuICAgIGNvbnN0IGFjdGl2ZUlkID0gYWN0aXZlVGFicy5maW5kKHQgPT4gdC5pZCAhPSBudWxsKT8uaWQ7XG4gICAgaWYgKGFjdGl2ZUlkICE9PSB0YWIuaWQpIHtcbiAgICAgIHJldHVybiB7IGlkOiAnJywgb2s6IGZhbHNlLCBlcnJvcjogJ1RhYiBpcyBub3QgYWN0aXZlJywgZXJyb3JDb2RlOiAnVEFCX05PVF9BQ1RJVkUnIH07XG4gICAgfVxuICB9XG4gIGNvbnN0IG1vZGUgPSBwYXlsb2FkLm1vZGUgPT09ICdzaGFyZWQnID8gJ3NoYXJlZCcgOiAnZXhjbHVzaXZlJztcbiAgY29uc3Qgb3duZXJzaGlwID0gZ2V0T3duZXIodGFiLmlkKTtcbiAgaWYgKCFvd25lcnNoaXAgJiYgbW9kZSA9PT0gJ3NoYXJlZCcpIHtcbiAgICByZXR1cm4geyBpZDogJycsIG9rOiBmYWxzZSwgZXJyb3I6ICdUYWIgbXVzdCBiZSBvd25lZCBiZWZvcmUgc2hhcmluZycsIGVycm9yQ29kZTogJ1RBQl9OT1RfT1dORUQnIH07XG4gIH1cbiAgaWYgKG93bmVyc2hpcCAmJiAhb3duZXJzaGlwLm93bmVycy5oYXMoc2Vzc2lvbklkKSkge1xuICAgIGlmIChtb2RlID09PSAnZXhjbHVzaXZlJykge1xuICAgICAgcmV0dXJuIHsgaWQ6ICcnLCBvazogZmFsc2UsIGVycm9yOiAnVGFiIG93bmVkIGJ5IGFub3RoZXIgc2Vzc2lvbicsIGVycm9yQ29kZTogJ1RBQl9OT1RfT1dORUQnIH07XG4gICAgfVxuICAgIGlmICghb3duZXJzaGlwLmFsbG93U2hhcmVkKSB7XG4gICAgICByZXR1cm4geyBpZDogJycsIG9rOiBmYWxzZSwgZXJyb3I6ICdUYWIgbm90IHNoYXJlYWJsZScsIGVycm9yQ29kZTogJ1RBQl9OT1RfU0hBUkVBQkxFJyB9O1xuICAgIH1cbiAgfVxuICBpZiAobW9kZSA9PT0gJ3NoYXJlZCcgJiYgb3duZXJzaGlwKSB7XG4gICAgb3duZXJzaGlwLmFsbG93U2hhcmVkID0gdHJ1ZTtcbiAgICBvd25lcnNoaXAubW9kZSA9ICdzaGFyZWQnO1xuICAgIGZvciAoY29uc3Qgb3duZXIgb2Ygb3duZXJzaGlwLm93bmVycykge1xuICAgICAgZW5zdXJlT3duZXIodGFiLmlkLCBvd25lciwgJ3NoYXJlZCcpO1xuICAgIH1cbiAgfVxuICBlbnN1cmVPd25lcih0YWIuaWQsIHNlc3Npb25JZCwgbW9kZSk7XG4gIGNvbnN0IGluZm86IFRhYkluZm8gPSB7IGlkOiB0YWIuaWQsIHRpdGxlOiB0YWIudGl0bGUgfHwgJ1VudGl0bGVkJywgdXJsOiB0YWIudXJsIHx8ICcnIH07XG4gIHJldHVybiB7IGlkOiAnJywgb2s6IHRydWUsIGRhdGE6IGluZm8gfTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gaGFuZGxlUmVsZWFzZVRhYihwYXlsb2FkOiBSZWxlYXNlVGFiUGF5bG9hZCwgc2Vzc2lvbklkOiBzdHJpbmcgfCBudWxsKTogUHJvbWlzZTxXU1Jlc3BvbnNlPiB7XG4gIGlmICghc2Vzc2lvbklkKSB7XG4gICAgcmV0dXJuIHsgaWQ6ICcnLCBvazogZmFsc2UsIGVycm9yOiAnU2Vzc2lvbiBpZCBpcyByZXF1aXJlZCcsIGVycm9yQ29kZTogJ1NFU1NJT05fUkVRVUlSRUQnIH07XG4gIH1cbiAgaWYgKCFwYXlsb2FkPy50YWJJZCkge1xuICAgIHJldHVybiB7IGlkOiAnJywgb2s6IGZhbHNlLCBlcnJvcjogJ3RhYklkIGlzIHJlcXVpcmVkJywgZXJyb3JDb2RlOiAnVEFCX0lEX1JFUVVJUkVEJyB9O1xuICB9XG4gIHJlbGVhc2VPd25lcihwYXlsb2FkLnRhYklkLCBzZXNzaW9uSWQpO1xuICByZXR1cm4geyBpZDogJycsIG9rOiB0cnVlIH07XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGhhbmRsZVNldFRhYlNoYXJpbmcocGF5bG9hZDogU2V0VGFiU2hhcmluZ1BheWxvYWQsIHNlc3Npb25JZDogc3RyaW5nIHwgbnVsbCk6IFByb21pc2U8V1NSZXNwb25zZT4ge1xuICBpZiAoIXNlc3Npb25JZCkge1xuICAgIHJldHVybiB7IGlkOiAnJywgb2s6IGZhbHNlLCBlcnJvcjogJ1Nlc3Npb24gaWQgaXMgcmVxdWlyZWQnLCBlcnJvckNvZGU6ICdTRVNTSU9OX1JFUVVJUkVEJyB9O1xuICB9XG4gIGlmICghcGF5bG9hZD8udGFiSWQpIHtcbiAgICByZXR1cm4geyBpZDogJycsIG9rOiBmYWxzZSwgZXJyb3I6ICd0YWJJZCBpcyByZXF1aXJlZCcsIGVycm9yQ29kZTogJ1RBQl9JRF9SRVFVSVJFRCcgfTtcbiAgfVxuICBjb25zdCBvd25lcnNoaXAgPSBnZXRPd25lcihwYXlsb2FkLnRhYklkKTtcbiAgaWYgKCFvd25lcnNoaXAgfHwgIW93bmVyc2hpcC5vd25lcnMuaGFzKHNlc3Npb25JZCkpIHtcbiAgICByZXR1cm4geyBpZDogJycsIG9rOiBmYWxzZSwgZXJyb3I6ICdUYWIgbm90IG93bmVkIGJ5IHNlc3Npb24nLCBlcnJvckNvZGU6ICdUQUJfTk9UX09XTkVEJyB9O1xuICB9XG4gIGlmICghcGF5bG9hZC5hbGxvd1NoYXJlZCAmJiBvd25lcnNoaXAub3duZXJzLnNpemUgPiAxKSB7XG4gICAgcmV0dXJuIHsgaWQ6ICcnLCBvazogZmFsc2UsIGVycm9yOiAnTXVsdGlwbGUgb3duZXJzIGV4aXN0JywgZXJyb3JDb2RlOiAnVEFCX1NIQVJFRF9BQ1RJVkUnIH07XG4gIH1cbiAgb3duZXJzaGlwLmFsbG93U2hhcmVkID0gcGF5bG9hZC5hbGxvd1NoYXJlZDtcbiAgaWYgKCFwYXlsb2FkLmFsbG93U2hhcmVkKSB7XG4gICAgb3duZXJzaGlwLm1vZGUgPSAnZXhjbHVzaXZlJztcbiAgfVxuICByZXR1cm4geyBpZDogJycsIG9rOiB0cnVlIH07XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHJvdXRlclN0YXJ0UmVjb3JkaW5nKCkge1xuICByZWNvcmRpbmcgPSB0cnVlO1xuICBjb25zdCB0YWJzID0gYXdhaXQgY2hyb21lQXBpLnRhYnMucXVlcnkoe30pO1xuICBmb3IgKGNvbnN0IHRhYiBvZiB0YWJzKSB7XG4gICAgaWYgKHRhYi5pZCkge1xuICAgICAgY2hyb21lQXBpLnRhYnMuc2VuZE1lc3NhZ2UodGFiLmlkLCB7IHR5cGU6ICdyZWNvcmRpbmc6c2V0JywgZW5hYmxlZDogdHJ1ZSB9KS5jYXRjaCgoKSA9PiB7fSk7XG4gICAgfVxuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHJvdXRlclN0b3BSZWNvcmRpbmcoKSB7XG4gIHJlY29yZGluZyA9IGZhbHNlO1xuICBjb25zdCB0YWJzID0gYXdhaXQgY2hyb21lQXBpLnRhYnMucXVlcnkoe30pO1xuICBmb3IgKGNvbnN0IHRhYiBvZiB0YWJzKSB7XG4gICAgaWYgKHRhYi5pZCkge1xuICAgICAgY2hyb21lQXBpLnRhYnMuc2VuZE1lc3NhZ2UodGFiLmlkLCB7IHR5cGU6ICdyZWNvcmRpbmc6c2V0JywgZW5hYmxlZDogZmFsc2UgfSkuY2F0Y2goKCkgPT4ge30pO1xuICAgIH1cbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBjcm9wRGF0YVVybChcbiAgZGF0YVVybDogc3RyaW5nLFxuICByZWN0OiB7IHg6IG51bWJlcjsgeTogbnVtYmVyOyB3aWR0aDogbnVtYmVyOyBoZWlnaHQ6IG51bWJlciB9LFxuICBkcHI6IG51bWJlcixcbiAgZm9ybWF0OiAncG5nJyB8ICdqcGVnJyxcbiAgcXVhbGl0eTogbnVtYmVyLFxuICBtYXhXaWR0aD86IG51bWJlcixcbiAgbWF4SGVpZ2h0PzogbnVtYmVyXG4pOiBQcm9taXNlPHsgZGF0YVVybDogc3RyaW5nOyB3aWR0aDogbnVtYmVyOyBoZWlnaHQ6IG51bWJlciB9PiB7XG4gIGlmICh0eXBlb2YgT2Zmc2NyZWVuQ2FudmFzID09PSAndW5kZWZpbmVkJykge1xuICAgIHRocm93IG5ldyBFcnJvcignT2Zmc2NyZWVuQ2FudmFzIGlzIG5vdCBhdmFpbGFibGUnKTtcbiAgfVxuICBjb25zdCBibG9iID0gYXdhaXQgKGF3YWl0IGZldGNoKGRhdGFVcmwpKS5ibG9iKCk7XG4gIGNvbnN0IGJpdG1hcCA9IGF3YWl0IGNyZWF0ZUltYWdlQml0bWFwKGJsb2IpO1xuXG4gIGxldCBzeCA9IE1hdGgubWF4KDAsIHJlY3QueCAqIGRwcik7XG4gIGxldCBzeSA9IE1hdGgubWF4KDAsIHJlY3QueSAqIGRwcik7XG4gIGxldCBzdyA9IE1hdGgubWF4KDEsIHJlY3Qud2lkdGggKiBkcHIpO1xuICBsZXQgc2ggPSBNYXRoLm1heCgxLCByZWN0LmhlaWdodCAqIGRwcik7XG4gIGlmIChzeCArIHN3ID4gYml0bWFwLndpZHRoKSBzdyA9IGJpdG1hcC53aWR0aCAtIHN4O1xuICBpZiAoc3kgKyBzaCA+IGJpdG1hcC5oZWlnaHQpIHNoID0gYml0bWFwLmhlaWdodCAtIHN5O1xuICBpZiAoc3cgPD0gMCB8fCBzaCA8PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDcm9wIGJvdW5kcyBpbnZhbGlkJyk7XG4gIH1cblxuICBsZXQgb3V0VyA9IHN3O1xuICBsZXQgb3V0SCA9IHNoO1xuICBjb25zdCBzY2FsZSA9IGNvbXB1dGVTY2FsZShvdXRXLCBvdXRILCBtYXhXaWR0aCwgbWF4SGVpZ2h0KTtcbiAgb3V0VyA9IE1hdGgubWF4KDEsIE1hdGgucm91bmQob3V0VyAqIHNjYWxlKSk7XG4gIG91dEggPSBNYXRoLm1heCgxLCBNYXRoLnJvdW5kKG91dEggKiBzY2FsZSkpO1xuXG4gIGNvbnN0IGNhbnZhcyA9IG5ldyBPZmZzY3JlZW5DYW52YXMob3V0Vywgb3V0SCk7XG4gIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICBpZiAoIWN0eCkgdGhyb3cgbmV3IEVycm9yKCdDYW52YXMgbm90IGF2YWlsYWJsZScpO1xuICBjdHguZHJhd0ltYWdlKGJpdG1hcCwgc3gsIHN5LCBzdywgc2gsIDAsIDAsIG91dFcsIG91dEgpO1xuXG4gIGNvbnN0IG1pbWUgPSBmb3JtYXQgPT09ICdqcGVnJyA/ICdpbWFnZS9qcGVnJyA6ICdpbWFnZS9wbmcnO1xuICBjb25zdCBibG9iT3V0ID0gYXdhaXQgY2FudmFzLmNvbnZlcnRUb0Jsb2IoeyB0eXBlOiBtaW1lLCBxdWFsaXR5OiBmb3JtYXQgPT09ICdqcGVnJyA/IHF1YWxpdHkgOiB1bmRlZmluZWQgfSk7XG4gIGNvbnN0IG91dFVybCA9IGF3YWl0IGJsb2JUb0RhdGFVcmwoYmxvYk91dCk7XG4gIHJldHVybiB7IGRhdGFVcmw6IG91dFVybCwgd2lkdGg6IG91dFcsIGhlaWdodDogb3V0SCB9O1xufVxuXG5mdW5jdGlvbiBjb21wdXRlU2NhbGUodzogbnVtYmVyLCBoOiBudW1iZXIsIG1heFc/OiBudW1iZXIsIG1heEg/OiBudW1iZXIpOiBudW1iZXIge1xuICBsZXQgc2NhbGUgPSAxO1xuICBpZiAobWF4VyAmJiB3ID4gbWF4Vykge1xuICAgIHNjYWxlID0gTWF0aC5taW4oc2NhbGUsIG1heFcgLyB3KTtcbiAgfVxuICBpZiAobWF4SCAmJiBoID4gbWF4SCkge1xuICAgIHNjYWxlID0gTWF0aC5taW4oc2NhbGUsIG1heEggLyBoKTtcbiAgfVxuICByZXR1cm4gc2NhbGU7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGJsb2JUb0RhdGFVcmwoYmxvYjogQmxvYik6IFByb21pc2U8c3RyaW5nPiB7XG4gIHJldHVybiBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3QgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICByZWFkZXIub25lcnJvciA9ICgpID0+IHJlamVjdChuZXcgRXJyb3IoJ0ZhaWxlZCB0byByZWFkIGJsb2InKSk7XG4gICAgcmVhZGVyLm9ubG9hZCA9ICgpID0+IHJlc29sdmUocmVhZGVyLnJlc3VsdCBhcyBzdHJpbmcpO1xuICAgIHJlYWRlci5yZWFkQXNEYXRhVVJMKGJsb2IpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gc2VuZFdTKHJlc3A6IFdTUmVzcG9uc2UpIHtcbiAgaWYgKCF3cyB8fCB3cy5yZWFkeVN0YXRlICE9PSBXZWJTb2NrZXQuT1BFTikgcmV0dXJuO1xuICB3cy5zZW5kKEpTT04uc3RyaW5naWZ5KHJlc3ApKTtcbn1cblxuZnVuY3Rpb24gY29ubmVjdCh1cmw6IHN0cmluZykge1xuICBpZiAod3MpIHdzLmNsb3NlKCk7XG4gIHdzVXJsID0gdXJsO1xuICB3cyA9IG5ldyBXZWJTb2NrZXQodXJsKTtcbiAgY29uc3Qgc2Vzc2lvbklkcyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICB3cy5vbm9wZW4gPSAoKSA9PiB7XG4gICAgd3NDb25uZWN0ZWQgPSB0cnVlO1xuICAgIGxhc3RFcnJvciA9IG51bGw7XG4gIH07XG4gIHdzLm9uY2xvc2UgPSAoKSA9PiB7XG4gICAgd3NDb25uZWN0ZWQgPSBmYWxzZTtcbiAgICBmb3IgKGNvbnN0IHNlc3Npb25JZCBvZiBzZXNzaW9uSWRzKSB7XG4gICAgICByZWxlYXNlU2Vzc2lvbihzZXNzaW9uSWQpO1xuICAgIH1cbiAgfTtcbiAgd3Mub25lcnJvciA9ICgpID0+IHtcbiAgICBsYXN0RXJyb3IgPSAnV2ViU29ja2V0IGVycm9yJztcbiAgfTtcbiAgd3Mub25tZXNzYWdlID0gKGV2ZW50KSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGNtZCA9IEpTT04ucGFyc2UoZXZlbnQuZGF0YSkgYXMgV1NDb21tYW5kO1xuICAgICAgaWYgKGNtZD8uaWQgJiYgY21kPy50eXBlKSB7XG4gICAgICAgIGlmIChjbWQuc2Vzc2lvbklkKSBzZXNzaW9uSWRzLmFkZChjbWQuc2Vzc2lvbklkKTtcbiAgICAgICAgdm9pZCBoYW5kbGVDb21tYW5kKGNtZCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyOiBhbnkpIHtcbiAgICAgIGxhc3RFcnJvciA9IGVycj8ubWVzc2FnZSB8fCAnSW52YWxpZCBtZXNzYWdlJztcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGRpc2Nvbm5lY3QoKSB7XG4gIGlmICh3cykge1xuICAgIHdzLmNsb3NlKCk7XG4gICAgd3MgPSBudWxsO1xuICB9XG4gIHdzQ29ubmVjdGVkID0gZmFsc2U7XG59XG5cbmNvbnN0IHJvdXRlciA9IGNyZWF0ZUJhY2tncm91bmRSb3V0ZXIoe1xuICBnZXRTdGF0ZTogKCkgPT4gKHtcbiAgICB3c1VybCxcbiAgICB3c0Nvbm5lY3RlZCxcbiAgICBsYXN0RXJyb3IsXG4gICAgbGFzdENvbW1hbmQsXG4gICAgbGFzdFNuYXBzaG90LFxuICAgIHRhcmdldFRhYklkLFxuICAgIHJlY29yZGluZyxcbiAgICByZWNvcmRpbmdDb3VudDogcmVjb3JkZWRBY3Rpb25zLmxlbmd0aCxcbiAgfSksXG4gIGNvbm5lY3QsXG4gIGRpc2Nvbm5lY3QsXG4gIHNlbmRDbGljazogKHNlbGVjdG9yKSA9PiBoYW5kbGVDbGljayh7IHNlbGVjdG9yIH0pLFxuICBzZW5kU25hcHNob3Q6IChwYXlsb2FkKSA9PiBoYW5kbGVTbmFwc2hvdChwYXlsb2FkKSxcbiAgbGlzdFRhYnM6ICgpID0+IGxpc3RUYWJzKCksXG4gIGxpc3RPd25lZFRhYnM6ICgpID0+IGxpc3RPd25lZFRhYnMoKSxcbiAgc2V0VGFyZ2V0VGFiOiAodGFiSWQpID0+IHtcbiAgICB0YXJnZXRUYWJJZCA9IHRhYklkO1xuICB9LFxuICBzdGFydFJlY29yZGluZzogYXN5bmMgKCkgPT4ge1xuICAgIGF3YWl0IHJvdXRlclN0YXJ0UmVjb3JkaW5nKCk7XG4gIH0sXG4gIHN0b3BSZWNvcmRpbmc6IGFzeW5jICgpID0+IHtcbiAgICBhd2FpdCByb3V0ZXJTdG9wUmVjb3JkaW5nKCk7XG4gIH0sXG4gIGNsZWFyUmVjb3JkaW5nOiAoKSA9PiB7XG4gICAgcmVjb3JkZWRBY3Rpb25zID0gW107XG4gIH0sXG4gIGdldFJlY29yZGluZzogKCkgPT4gcmVjb3JkZWRBY3Rpb25zLFxufSk7XG5cbmNvbnN0IHNhZmVDcmVhdGVDaHJvbWVIYW5kbGVyID0gKCkgPT4ge1xuICB0cnkge1xuICAgIGNyZWF0ZUNocm9tZUhhbmRsZXIoe1xuICAgICAgcm91dGVyLFxuICAgICAgb25FcnJvcjogKHsgZXJyb3IgfSkgPT4ge1xuICAgICAgICBsYXN0RXJyb3IgPSBlcnJvci5tZXNzYWdlO1xuICAgICAgfSxcbiAgICAgIGNocm9tZTogY2hyb21lQXBpLFxuICAgIH0pO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjb25zdCBtZXNzYWdlID0gZXJyIGluc3RhbmNlb2YgRXJyb3IgPyBlcnIubWVzc2FnZSA6IFN0cmluZyhlcnIpO1xuICAgIGlmIChtZXNzYWdlLmluY2x1ZGVzKCdub3QgaW1wbGVtZW50ZWQnKSkge1xuICAgICAgY29uc29sZS53YXJuKCdTa2lwcGluZyBjaHJvbWUgaGFuZGxlciBjcmVhdGlvbjogcnVudGltZSBvbkNvbm5lY3Qgbm90IGltcGxlbWVudGVkJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRocm93IGVycjtcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgZGVmaW5lQmFja2dyb3VuZCgoKSA9PiB7XG4gIGNocm9tZUFwaS5zaWRlUGFuZWw/LnNldFBhbmVsQmVoYXZpb3I/Lih7IG9wZW5QYW5lbE9uQWN0aW9uQ2xpY2s6IHRydWUgfSkuY2F0Y2goKCkgPT4ge30pO1xuICBjaHJvbWVBcGkucnVudGltZS5vbk1lc3NhZ2UuYWRkTGlzdGVuZXIoaGFuZGxlUnVudGltZU1lc3NhZ2UpO1xuICBjaHJvbWVBcGkudGFicy5vblJlbW92ZWQuYWRkTGlzdGVuZXIoKHRhYklkKSA9PiB7XG4gICAgdGFiT3duZXJzLmRlbGV0ZSh0YWJJZCk7XG4gICAgZm9yIChjb25zdCBbc2Vzc2lvbklkLCBzZXRdIG9mIHNlc3Npb25UYWJzKSB7XG4gICAgICBpZiAoc2V0Lmhhcyh0YWJJZCkpIHtcbiAgICAgICAgcmVtb3ZlU2Vzc2lvblRhYihzZXNzaW9uSWQsIHRhYklkKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBzYWZlQ3JlYXRlQ2hyb21lSGFuZGxlcigpO1xufSk7XG4iLCIvLyBzcmMvaW5kZXgudHNcbnZhciBfTWF0Y2hQYXR0ZXJuID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihtYXRjaFBhdHRlcm4pIHtcbiAgICBpZiAobWF0Y2hQYXR0ZXJuID09PSBcIjxhbGxfdXJscz5cIikge1xuICAgICAgdGhpcy5pc0FsbFVybHMgPSB0cnVlO1xuICAgICAgdGhpcy5wcm90b2NvbE1hdGNoZXMgPSBbLi4uX01hdGNoUGF0dGVybi5QUk9UT0NPTFNdO1xuICAgICAgdGhpcy5ob3N0bmFtZU1hdGNoID0gXCIqXCI7XG4gICAgICB0aGlzLnBhdGhuYW1lTWF0Y2ggPSBcIipcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZ3JvdXBzID0gLyguKik6XFwvXFwvKC4qPykoXFwvLiopLy5leGVjKG1hdGNoUGF0dGVybik7XG4gICAgICBpZiAoZ3JvdXBzID09IG51bGwpXG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkTWF0Y2hQYXR0ZXJuKG1hdGNoUGF0dGVybiwgXCJJbmNvcnJlY3QgZm9ybWF0XCIpO1xuICAgICAgY29uc3QgW18sIHByb3RvY29sLCBob3N0bmFtZSwgcGF0aG5hbWVdID0gZ3JvdXBzO1xuICAgICAgdmFsaWRhdGVQcm90b2NvbChtYXRjaFBhdHRlcm4sIHByb3RvY29sKTtcbiAgICAgIHZhbGlkYXRlSG9zdG5hbWUobWF0Y2hQYXR0ZXJuLCBob3N0bmFtZSk7XG4gICAgICB2YWxpZGF0ZVBhdGhuYW1lKG1hdGNoUGF0dGVybiwgcGF0aG5hbWUpO1xuICAgICAgdGhpcy5wcm90b2NvbE1hdGNoZXMgPSBwcm90b2NvbCA9PT0gXCIqXCIgPyBbXCJodHRwXCIsIFwiaHR0cHNcIl0gOiBbcHJvdG9jb2xdO1xuICAgICAgdGhpcy5ob3N0bmFtZU1hdGNoID0gaG9zdG5hbWU7XG4gICAgICB0aGlzLnBhdGhuYW1lTWF0Y2ggPSBwYXRobmFtZTtcbiAgICB9XG4gIH1cbiAgaW5jbHVkZXModXJsKSB7XG4gICAgaWYgKHRoaXMuaXNBbGxVcmxzKVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgY29uc3QgdSA9IHR5cGVvZiB1cmwgPT09IFwic3RyaW5nXCIgPyBuZXcgVVJMKHVybCkgOiB1cmwgaW5zdGFuY2VvZiBMb2NhdGlvbiA/IG5ldyBVUkwodXJsLmhyZWYpIDogdXJsO1xuICAgIHJldHVybiAhIXRoaXMucHJvdG9jb2xNYXRjaGVzLmZpbmQoKHByb3RvY29sKSA9PiB7XG4gICAgICBpZiAocHJvdG9jb2wgPT09IFwiaHR0cFwiKVxuICAgICAgICByZXR1cm4gdGhpcy5pc0h0dHBNYXRjaCh1KTtcbiAgICAgIGlmIChwcm90b2NvbCA9PT0gXCJodHRwc1wiKVxuICAgICAgICByZXR1cm4gdGhpcy5pc0h0dHBzTWF0Y2godSk7XG4gICAgICBpZiAocHJvdG9jb2wgPT09IFwiZmlsZVwiKVxuICAgICAgICByZXR1cm4gdGhpcy5pc0ZpbGVNYXRjaCh1KTtcbiAgICAgIGlmIChwcm90b2NvbCA9PT0gXCJmdHBcIilcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNGdHBNYXRjaCh1KTtcbiAgICAgIGlmIChwcm90b2NvbCA9PT0gXCJ1cm5cIilcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNVcm5NYXRjaCh1KTtcbiAgICB9KTtcbiAgfVxuICBpc0h0dHBNYXRjaCh1cmwpIHtcbiAgICByZXR1cm4gdXJsLnByb3RvY29sID09PSBcImh0dHA6XCIgJiYgdGhpcy5pc0hvc3RQYXRoTWF0Y2godXJsKTtcbiAgfVxuICBpc0h0dHBzTWF0Y2godXJsKSB7XG4gICAgcmV0dXJuIHVybC5wcm90b2NvbCA9PT0gXCJodHRwczpcIiAmJiB0aGlzLmlzSG9zdFBhdGhNYXRjaCh1cmwpO1xuICB9XG4gIGlzSG9zdFBhdGhNYXRjaCh1cmwpIHtcbiAgICBpZiAoIXRoaXMuaG9zdG5hbWVNYXRjaCB8fCAhdGhpcy5wYXRobmFtZU1hdGNoKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IGhvc3RuYW1lTWF0Y2hSZWdleHMgPSBbXG4gICAgICB0aGlzLmNvbnZlcnRQYXR0ZXJuVG9SZWdleCh0aGlzLmhvc3RuYW1lTWF0Y2gpLFxuICAgICAgdGhpcy5jb252ZXJ0UGF0dGVyblRvUmVnZXgodGhpcy5ob3N0bmFtZU1hdGNoLnJlcGxhY2UoL15cXCpcXC4vLCBcIlwiKSlcbiAgICBdO1xuICAgIGNvbnN0IHBhdGhuYW1lTWF0Y2hSZWdleCA9IHRoaXMuY29udmVydFBhdHRlcm5Ub1JlZ2V4KHRoaXMucGF0aG5hbWVNYXRjaCk7XG4gICAgcmV0dXJuICEhaG9zdG5hbWVNYXRjaFJlZ2V4cy5maW5kKChyZWdleCkgPT4gcmVnZXgudGVzdCh1cmwuaG9zdG5hbWUpKSAmJiBwYXRobmFtZU1hdGNoUmVnZXgudGVzdCh1cmwucGF0aG5hbWUpO1xuICB9XG4gIGlzRmlsZU1hdGNoKHVybCkge1xuICAgIHRocm93IEVycm9yKFwiTm90IGltcGxlbWVudGVkOiBmaWxlOi8vIHBhdHRlcm4gbWF0Y2hpbmcuIE9wZW4gYSBQUiB0byBhZGQgc3VwcG9ydFwiKTtcbiAgfVxuICBpc0Z0cE1hdGNoKHVybCkge1xuICAgIHRocm93IEVycm9yKFwiTm90IGltcGxlbWVudGVkOiBmdHA6Ly8gcGF0dGVybiBtYXRjaGluZy4gT3BlbiBhIFBSIHRvIGFkZCBzdXBwb3J0XCIpO1xuICB9XG4gIGlzVXJuTWF0Y2godXJsKSB7XG4gICAgdGhyb3cgRXJyb3IoXCJOb3QgaW1wbGVtZW50ZWQ6IHVybjovLyBwYXR0ZXJuIG1hdGNoaW5nLiBPcGVuIGEgUFIgdG8gYWRkIHN1cHBvcnRcIik7XG4gIH1cbiAgY29udmVydFBhdHRlcm5Ub1JlZ2V4KHBhdHRlcm4pIHtcbiAgICBjb25zdCBlc2NhcGVkID0gdGhpcy5lc2NhcGVGb3JSZWdleChwYXR0ZXJuKTtcbiAgICBjb25zdCBzdGFyc1JlcGxhY2VkID0gZXNjYXBlZC5yZXBsYWNlKC9cXFxcXFwqL2csIFwiLipcIik7XG4gICAgcmV0dXJuIFJlZ0V4cChgXiR7c3RhcnNSZXBsYWNlZH0kYCk7XG4gIH1cbiAgZXNjYXBlRm9yUmVnZXgoc3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC9bLiorP14ke30oKXxbXFxdXFxcXF0vZywgXCJcXFxcJCZcIik7XG4gIH1cbn07XG52YXIgTWF0Y2hQYXR0ZXJuID0gX01hdGNoUGF0dGVybjtcbk1hdGNoUGF0dGVybi5QUk9UT0NPTFMgPSBbXCJodHRwXCIsIFwiaHR0cHNcIiwgXCJmaWxlXCIsIFwiZnRwXCIsIFwidXJuXCJdO1xudmFyIEludmFsaWRNYXRjaFBhdHRlcm4gPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IobWF0Y2hQYXR0ZXJuLCByZWFzb24pIHtcbiAgICBzdXBlcihgSW52YWxpZCBtYXRjaCBwYXR0ZXJuIFwiJHttYXRjaFBhdHRlcm59XCI6ICR7cmVhc29ufWApO1xuICB9XG59O1xuZnVuY3Rpb24gdmFsaWRhdGVQcm90b2NvbChtYXRjaFBhdHRlcm4sIHByb3RvY29sKSB7XG4gIGlmICghTWF0Y2hQYXR0ZXJuLlBST1RPQ09MUy5pbmNsdWRlcyhwcm90b2NvbCkgJiYgcHJvdG9jb2wgIT09IFwiKlwiKVxuICAgIHRocm93IG5ldyBJbnZhbGlkTWF0Y2hQYXR0ZXJuKFxuICAgICAgbWF0Y2hQYXR0ZXJuLFxuICAgICAgYCR7cHJvdG9jb2x9IG5vdCBhIHZhbGlkIHByb3RvY29sICgke01hdGNoUGF0dGVybi5QUk9UT0NPTFMuam9pbihcIiwgXCIpfSlgXG4gICAgKTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlSG9zdG5hbWUobWF0Y2hQYXR0ZXJuLCBob3N0bmFtZSkge1xuICBpZiAoaG9zdG5hbWUuaW5jbHVkZXMoXCI6XCIpKVxuICAgIHRocm93IG5ldyBJbnZhbGlkTWF0Y2hQYXR0ZXJuKG1hdGNoUGF0dGVybiwgYEhvc3RuYW1lIGNhbm5vdCBpbmNsdWRlIGEgcG9ydGApO1xuICBpZiAoaG9zdG5hbWUuaW5jbHVkZXMoXCIqXCIpICYmIGhvc3RuYW1lLmxlbmd0aCA+IDEgJiYgIWhvc3RuYW1lLnN0YXJ0c1dpdGgoXCIqLlwiKSlcbiAgICB0aHJvdyBuZXcgSW52YWxpZE1hdGNoUGF0dGVybihcbiAgICAgIG1hdGNoUGF0dGVybixcbiAgICAgIGBJZiB1c2luZyBhIHdpbGRjYXJkICgqKSwgaXQgbXVzdCBnbyBhdCB0aGUgc3RhcnQgb2YgdGhlIGhvc3RuYW1lYFxuICAgICk7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVBhdGhuYW1lKG1hdGNoUGF0dGVybiwgcGF0aG5hbWUpIHtcbiAgcmV0dXJuO1xufVxuZXhwb3J0IHtcbiAgSW52YWxpZE1hdGNoUGF0dGVybixcbiAgTWF0Y2hQYXR0ZXJuXG59O1xuIl0sIm5hbWVzIjpbImJyb3dzZXIiLCJfYnJvd3NlciIsImlzT2JqZWN0IiwiVW5rbm93bkNhdXNlRXJyb3IiLCJnZXRDYXVzZUZyb21Vbmtub3duIiwicmVxdWlyZSQkMCIsImdldFRSUENFcnJvckZyb21Vbmtub3duIiwiVFJQQ0Vycm9yIiwiaW52ZXJ0IiwiVFJQQ19FUlJPUl9DT0RFU19CWV9LRVkiLCJKU09OUlBDMl9UT19IVFRQX0NPREUiLCJnZXRTdGF0dXNDb2RlRnJvbUtleSIsImdldEhUVFBTdGF0dXNDb2RlRnJvbUVycm9yIiwibm9vcCIsImNyZWF0ZUlubmVyUHJveHkiLCJjcmVhdGVSZWN1cnNpdmVQcm94eSIsImNyZWF0ZUZsYXRQcm94eSIsInJlcXVpcmUkJDEiLCJyZXF1aXJlJCQyIiwiZ2V0RGF0YVRyYW5zZm9ybWVyIiwiZGVmYXVsdFRyYW5zZm9ybWVyIiwiZGVmYXVsdEZvcm1hdHRlciIsIm9taXRQcm90b3R5cGUiLCJwcm9jZWR1cmVUeXBlcyIsImlzUm91dGVyIiwiZW1wdHlSb3V0ZXIiLCJyZXNlcnZlZFdvcmRzIiwiY3JlYXRlUm91dGVyRmFjdG9yeSIsInByb2NlZHVyZXMiLCJyb3V0ZXIiLCJjcmVhdGVDYWxsZXJGYWN0b3J5IiwiY2FsbFByb2NlZHVyZSIsImlzU2VydmVyRGVmYXVsdCIsImRpc3QiLCJyZXF1aXJlJCQzIiwicmVxdWlyZSQkNCIsInJlc3VsdCIsImdldFBhcnNlRm4iLCJtZXJnZVdpdGhvdXRPdmVycmlkZXMiLCJjcmVhdGVNaWRkbGV3YXJlRmFjdG9yeSIsImlzUGxhaW5PYmplY3QiLCJjcmVhdGVJbnB1dE1pZGRsZXdhcmUiLCJjcmVhdGVPdXRwdXRNaWRkbGV3YXJlIiwibWlkZGxld2FyZU1hcmtlciIsImNyZWF0ZU5ld0J1aWxkZXIiLCJjcmVhdGVCdWlsZGVyIiwiY3JlYXRlUmVzb2x2ZXIiLCJjcmVhdGVQcm9jZWR1cmVDYWxsZXIiLCJjb2RlYmxvY2siLCJtZXJnZVJvdXRlcnMiLCJUUlBDQnVpbGRlciIsImNyZWF0ZVRSUENJbm5lciIsImluaXRUUlBDIiwiaWRlbnRpdHkiLCJwaXBlRnJvbUFycmF5Iiwib2JzZXJ2YWJsZSIsInNlbGYiLCJvYnNlcnZhYmxlXzEiLCJzaGFyZSIsIk9ic2VydmFibGVBYm9ydEVycm9yIiwib2JzZXJ2YWJsZVRvUHJvbWlzZSIsImNocm9tZSIsImdsb2JhbCIsIndpbmRvdyIsInJlcXVpcmUkJDUiLCJfYSIsIl9iIiwidGhpcyIsImV4cG9ydHMiLCJjcmVhdGVDaGFpbiIsImxpbmsiLCJzaGFyZWQiLCJpc1RSUENDbGllbnRFcnJvciIsIlRSUENDbGllbnRFcnJvciIsImlzVFJQQ0Vycm9yUmVzcG9uc2UiLCJpc1ZhbGlkIiwiaXRlbSIsImh0dHBCYXRjaExpbmsiLCJmZXRjaCIsImh0dHBMaW5rXzEiLCJodHRwTGluayIsImxvZ2dlckxpbmtfMSIsImxvZ2dlckxpbmsiLCJsb2dnZXIiLCJ3c0xpbmtfMSIsImNhbGxiYWNrcyIsIndzTGluayIsInJlcXVpcmUkJDYiLCJyZXF1aXJlJCQ3IiwicmVxdWlyZSQkOCIsInJlcXVpcmUkJDkiLCJUUlBDVW50eXBlZENsaWVudCIsImNsaWVudENhbGxUeXBlTWFwIiwiY2xpZW50Q2FsbFR5cGVUb1Byb2NlZHVyZVR5cGUiLCJjcmVhdGVUUlBDQ2xpZW50UHJveHkiLCJjcmVhdGVUUlBDUHJveHlDbGllbnQiLCJwb3B1cCIsImdldERhdGFUcmFuc2Zvcm1lciQxIiwidXRpbCIsIm9iamVjdFV0aWwiLCJ0IiwiZGVmYXVsdEVycm9yTWFwIiwiZXJyb3JVdGlsIiwiZXJyb3JNYXAiLCJjdHgiLCJpc3N1ZXMiLCJlbGVtZW50cyIsInByb2Nlc3NlZCIsImJhc2UiLCJab2RGaXJzdFBhcnR5VHlwZUtpbmQiLCJ6Lm9iamVjdCIsInoubnVtYmVyIiwiei5zdHJpbmciLCJ6LmJvb2xlYW4iLCJ3cyIsImNocm9tZUxpbmsiLCJjcmVhdGVDaHJvbWVIYW5kbGVyIl0sIm1hcHBpbmdzIjoiOztBQUNPLFFBQU1BLFlBQVUsV0FBVyxTQUFTLFNBQVMsS0FDaEQsV0FBVyxVQUNYLFdBQVc7QUNGUixRQUFNLFVBQVVDO0FDRGhCLFdBQVMsaUJBQWlCLEtBQUs7QUFDcEMsUUFBSSxPQUFPLFFBQVEsT0FBTyxRQUFRLFdBQVksUUFBTyxFQUFFLE1BQU0sSUFBRztBQUNoRSxXQUFPO0FBQUEsRUFDVDs7Ozs7Ozs7Ozs7O0FDQ0ksYUFBU0MsVUFBUyxPQUFPO0FBRXpCLGFBQU8sQ0FBQyxDQUFDLFNBQVMsQ0FBQyxNQUFNLFFBQVEsS0FBSyxLQUFLLE9BQU8sVUFBVTtBQUFBLElBQ2hFO0FBQUEsSUFFQSxNQUFNQywyQkFBMEIsTUFBTTtBQUFBLElBQ3RDO0FBQ0EsYUFBU0MscUJBQW9CLE9BQU87QUFDaEMsVUFBSSxpQkFBaUIsT0FBTztBQUN4QixlQUFPO0FBQUEsTUFDZjtBQUNJLFlBQU0sT0FBTyxPQUFPO0FBQ3BCLFVBQUksU0FBUyxlQUFlLFNBQVMsY0FBYyxVQUFVLE1BQU07QUFDL0QsZUFBTztBQUFBLE1BQ2Y7QUFFSSxVQUFJLFNBQVMsVUFBVTtBQUNuQixlQUFPLElBQUks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UTtBQUNSLGFBQU8sQ0FBQyxDQUFDLEtBQUssS0FBSyxPQUFPLEtBQUssQ0FBQyxPQUFPLEdBQUcsU0FBUyxLQUFLO0FBQUEsSUFDNUQ7QUFBQSxJQUNBLElBQUksVUFBVTtBQUNWLGFBQU8sQ0FBQyxDQUFDLEtBQUssS0FBSyxPQUFPLEtBQUssQ0FBQyxPQUFPLEdBQUcsU0FBUyxPQUFPO0FBQUEsSUFDOUQ7QUFBQSxJQUNBLElBQUksU0FBUztBQUNULGFBQU8sQ0FBQyxDQUFDLEtBQUssS0FBSyxPQUFPLEtBQUssQ0FBQyxPQUFPLEdBQUcsU0FBUyxNQUFNO0FBQUEsSUFDN0Q7QUFBQSxJQUNBLElBQUksV0FBVztBQUNYLGFBQU8sQ0FBQyxDQUFDLEtBQUssS0FBSyxPQUFPLEtBQUssQ0FBQyxPQUFPLEdBQUcsU0FBUyxRQUFRO0FBQUEsSUFDL0Q7QUFBQSxJQUNBLElBQUksU0FBUztBQUNULGFBQU8sQ0FBQyxDQUFDLEtBQUssS0FBSyxPQUFPLEtBQUssQ0FBQyxPQUFPLEdBQUcsU0FBUyxNQUFNO0FBQUEsSUFDN0Q7QUFBQSxJQUNBLElBQUksVUFBVTtBQUNWLGFBQU8sQ0FBQyxDQUFDLEtBQUssS0FBSyxPQUFPLEtBQUssQ0FBQyxPQUFPLEdBQUcsU0FBUyxPQUFPO0FBQUEsSUFDOUQ7QUFBQSxJQUNBLElBQUksU0FBUztBQUNULGFBQU8sQ0FBQyxDQUFDLEtBQUssS0FBSyxPQUFPLEtBQUssQ0FBQyxPQUFPLEdBQUcsU0FBUyxNQUFNO0FBQUEsSUFDN0Q7QUFBQSxJQUNBLElBQUksT0FBTztBQUNQLGFBQU8sQ0FBQyxDQUFDLEtBQUssS0FBSyxPQUFPLEtBQUssQ0FBQyxPQUFPLEdBQUcsU0FBUyxJQUFJO0FBQUEsSUFDM0Q7QUFBQSxJQUNBLElBQUksU0FBUztBQUNULGFBQU8sQ0FBQyxDQUFDLEtBQUssS0FBSyxPQUFPLEtBQUssQ0FBQyxPQUFPLEdBQUcsU0FBUyxNQUFNO0FBQUEsSUFDN0Q7QUFBQSxJQUNBLElBQUksV0FBVztBQUNYLGFBQU8sQ0FBQyxDQUFDLEtBQUssS0FBSyxPQUFP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QUFBQSxFQUVKO0FBRUEsaUJBQUEsZUFBQSxnQkFBQTtBQUNFLFFBQUEsa0JBQUEsS0FBQSxRQUFBO0FBQ0EsUUFBQSxlQUFBLEtBQUEsUUFBQTtBQUNBLFVBQUEsT0FBQSxNQUFBLFVBQUEsS0FBQSxNQUFBLEVBQUEsUUFBQSxNQUFBLG1CQUFBLE1BQUE7QUFDQSxVQUFBLE1BQUEsS0FBQSxLQUFBLENBQUFkLE9BQUFBLEdBQUEsTUFBQSxRQUFBLENBQUFBLEdBQUEsS0FBQSxXQUFBLFdBQUEsS0FBQSxDQUFBQSxHQUFBLEtBQUEsV0FBQSxxQkFBQSxDQUFBO0FBQ0EsV0FBQSxLQUFBLE1BQUE7QUFBQSxFQUNGO0FBRUEsaUJBQUEsV0FBQTtBQUNFLFVBQUEsT0FBQSxNQUFBLFVBQUEsS0FBQSxNQUFBLENBQUEsQ0FBQTtBQUNBLFdBQUEsS0FBQSxPQUFBLENBQUFBLE9BQUFBLEdBQUEsTUFBQSxRQUFBQSxHQUFBLE9BQUEsQ0FBQUEsR0FBQSxJQUFBLFdBQUEsV0FBQSxLQUFBLENBQUFBLEdBQUEsSUFBQSxXQUFBLHFCQUFBLENBQUEsRUFBQSxJQUFBLENBQUFBLFFBQUEsRUFBQSxJQUFBQSxHQUFBLElBQUEsT0FBQUEsR0FBQSxTQUFBLFlBQUEsS0FBQUEsR0FBQSxPQUFBLEdBQUEsRUFBQTtBQUFBLEVBR0Y7QUFFQSxpQkFBQSxnQkFBQTtBQUNFLFVBQUEsT0FBQSxNQUFBLFNBQUE7QUFDQSxVQUFBLFNBQUEsb0JBQUEsSUFBQTtBQUNBLGVBQUEsT0FBQSxLQUFBLFFBQUEsSUFBQSxJQUFBLElBQUEsR0FBQTtBQUNBLFVBQUEsVUFBQSxDQUFBO0FBQ0EsZUFBQSxDQUFBLFdBQUEsR0FBQSxLQUFBLGFBQUE7QUFDRSxZQUFBLFFBQUEsQ0FBQTtBQUNBLGlCQUFBLFNBQUEsS0FBQTtBQUNFLGNBQUEsT0FBQSxPQUFBLElBQUEsS0FBQTtBQUNBLFlBQUEsUUFBQSxlQUFBLE9BQUEsU0FBQSxHQUFBO0FBQ0UsZ0JBQUEsS0FBQSxJQUFBO0FBQUEsUUFBZTtBQUFBLE1BQ2pCO0FBRUYsY0FBQSxLQUFB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LE1BQUEsVUFBQSxTQUFBO0FBQ0EsV0FBQSxLQUFBLElBQUEsR0FBQSxLQUFBLE1BQUEsT0FBQSxLQUFBLENBQUE7QUFDQSxXQUFBLEtBQUEsSUFBQSxHQUFBLEtBQUEsTUFBQSxPQUFBLEtBQUEsQ0FBQTtBQUVBLFVBQUEsU0FBQSxJQUFBLGdCQUFBLE1BQUEsSUFBQTtBQUNBLFVBQUEsTUFBQSxPQUFBLFdBQUEsSUFBQTtBQUNBLFFBQUEsQ0FBQSxJQUFBLE9BQUEsSUFBQSxNQUFBLHNCQUFBO0FBQ0EsUUFBQSxVQUFBLFFBQUEsSUFBQSxJQUFBLElBQUEsSUFBQSxHQUFBLEdBQUEsTUFBQSxJQUFBO0FBRUEsVUFBQSxPQUFBLFdBQUEsU0FBQSxlQUFBO0FBQ0EsVUFBQSxVQUFBLE1BQUEsT0FBQSxjQUFBLEVBQUEsTUFBQSxNQUFBLFNBQUEsV0FBQSxTQUFBLFVBQUEsT0FBQSxDQUFBO0FBQ0EsVUFBQSxTQUFBLE1BQUEsY0FBQSxPQUFBO0FBQ0EsV0FBQSxFQUFBLFNBQUEsUUFBQSxPQUFBLE1BQUEsUUFBQSxLQUFBO0FBQUEsRUFDRjtBQUVBLFdBQUEsYUFBQSxHQUFBLEdBQUEsTUFBQSxNQUFBO0FBQ0UsUUFBQSxRQUFBO0FBQ0EsUUFBQSxRQUFBLElBQUEsTUFBQTtBQUNFLGNBQUEsS0FBQSxJQUFBLE9BQUEsT0FBQSxDQUFBO0FBQUEsSUFBZ0M7QUFFbEMsUUFBQSxRQUFBLElBQUEsTUFBQTtBQUNFLGNBQUEsS0FBQSxJQUFBLE9BQUEsT0FBQSxDQUFBO0FBQUEsSUFBZ0M7QUFFbEMsV0FBQTtBQUFBLEVBQ0Y7QUFFQSxpQkFBQSxjQUFBLE1BQUE7QUFDRSxXQUFBLE1BQUEsSUFBQSxRQUFBLENBQUEsU0FBQSxXQUFBO0FBQ0UsWUFBQSxTQUFBLElBQUEsV0FBQTtBQUNBLGFBQUEsVUFBQSxNQUFBLE9BQUEsSUFBQSxNQUFBLHFCQUFBLENBQUE7QUFDQSxhQUFBLFNBQUEsTUFBQSxRQUFBLE9BQUEsTUFBQTtBQUNBLGFBQUEsY0FBQSxJQUFBO0FBQUEsSUFBeUIsQ0FBQTtBQUFBLEVBRTdC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QixNQUFNO0FBQUEsSUFDckQ7QUFBQSxFQUNGO0FBQ0EsTUFBSSxlQUFlO0FBQ25CLGVBQWEsWUFBWSxDQUFDLFFBQVEsU0FBUyxRQUFRLE9BQU8sS0FBSztBQUMvRCxNQUFJLHNCQUFzQixjQUFjLE1BQU07QUFBQSxJQUM1QyxZQUFZLGNBQWMsUUFBUTtBQUNoQyxZQUFNLDBCQUEwQixZQUFZLE1BQU0sTUFBTSxFQUFFO0FBQUEsSUFDNUQ7QUFBQSxFQUNGO0FBQ0EsV0FBUyxpQkFBaUIsY0FBYyxVQUFVO0FBQ2hELFFBQUksQ0FBQyxhQUFhLFVBQVUsU0FBUyxRQUFRLEtBQUssYUFBYTtBQUM3RCxZQUFNLElBQUk7QUFBQSxRQUNSO0FBQUEsUUFDQSxHQUFHLFFBQVEsMEJBQTBCLGFBQWEsVUFBVSxLQUFLLElBQUksQ0FBQztBQUFBLE1BQzVFO0FBQUEsRUFDQTtBQUNBLFdBQVMsaUJBQWlCLGNBQWMsVUFBVTtBQUNoRCxRQUFJLFNBQVMsU0FBUyxHQUFHO0FBQ3ZCLFlBQU0sSUFBSSxvQkFBb0IsY0FBYyxnQ0FBZ0M7QUFDOUUsUUFBSSxTQUFTLFNBQVMsR0FBRyxLQUFLLFNBQVMsU0FBUyxLQUFLLENBQUMsU0FBUyxXQUFXLElBQUk7QUFDNUUsWUFBTSxJQUFJO0FBQUEsUUFDUjtBQUFBLFFBQ0E7QUFBQSxNQUNOO0FBQUEsRUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OyIsInhfZ29vZ2xlX2lnbm9yZUxpc3QiOlswLDEsMiwzLDQsNSw2LDcsOCw5LDEwLDExLDEyLDEzLDE0LDE1LDE2LDE3LDE4LDE5LDIwLDIxLDIyLDIzLDI0LDI1LDI2LDI3LDI4LDI5LDMwLDMxLDMyLDMzLDM0LDM1LDM2LDM3LDM4LDM5LDQwLDQxLDQyLDQzLDQ0LDQ1LDQ2LDQ3LDQ4LDQ5LDUwLDUxLDU0XX0=
